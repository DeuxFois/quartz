<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Linux Processes Basics In short, processes are running programs on your Linux host that perform operations such as writing to a disk, writing to a file, or running a web server for example."><title>Understanding Processes on Linux</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://deuxfois.github.io/quartz//icon.png><link href=https://deuxfois.github.io/quartz/styles.b54f56dc7e7fdf6be9a4427dc6b0509b.min.css rel=stylesheet><link href=https://deuxfois.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://deuxfois.github.io/quartz/js/darkmode.69b2c08ae0f08c3a3f86259a122e1f06.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/util.39f53d45cb9520bdaf946bd063598b19.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://deuxfois.github.io/quartz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://deuxfois.github.io/quartz/",fetchData=Promise.all([fetch("https://deuxfois.github.io/quartz/indices/linkIndex.138e8e684375e828e1fe07635a41b9e8.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://deuxfois.github.io/quartz/indices/contentIndex.e1731d82502b8cde73f0218db2a97e2f.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!1;drawGraph("https://deuxfois.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://deuxfois.github.io/quartz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/deuxfois.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://deuxfois.github.io/quartz/js/full-text-search.0ec5fb908204b9e13989f2c640c0870b.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://deuxfois.github.io/quartz/>ü™¥ Quartz 3.2</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Understanding Processes on Linux</h1><p class=meta>Last updated
Unknown
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/Master/Concurrence%20dans%20les%20syst%c3%a8mes/Understanding%20Processes%20on%20Linux.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://deuxfois.github.io/quartz/tags/concurrence/>Concurrence</a></li><li><a href=https://deuxfois.github.io/quartz/tags/s1/>S1</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#a-idprocess_initialization_on_linuxaprocess-initialization-on-linux><a id=Process_Initialization_on_Linux></a>Process Initialization on Linux</a></li><li><a href=#a-idprocess_creation_using_fork_and_execaprocess-creation-using-fork-and-exec><a id=Process_Creation_using_Fork_and_Exec></a>Process Creation using Fork and Exec</a><ol><li><a href=#a-idfork_operationafork-operation><a id=Fork_operation></a>Fork operation</a></li><li><a href=#a-idexecute_operationaexecute-operation><a id=Execute_operation></a>Execute operation</a></li><li><a href=#a-idcreating_processes_from_a_shell_environmentacreating-processes-from-a-shell-environment><a id=Creating_processes_from_a_shell_environment></a>Creating processes from a shell environment</a></li></ol></li><li><a href=#a-ididentifying_running_processes_on_linuxaidentifying-running-processes-on-linux><a id=Identifying_running_processes_on_Linux></a>Identifying running processes on Linux</a></li></ol><ol><li><a href=#a-idjobs_and_processes_in_the_current_shellajobs-and-processes-in-the-current-shell><a id=Jobs_and_processes_in_the_current_shell></a>Jobs and processes in the current shell</a></li><li><a href=#a-idusing_the_bg_and_fg_commandsausing-the-bg-and-fg-commands><a id=Using_the_bg_and_fg_commands></a>Using the bg and fg commands</a></li></ol><ol><li><a href=#a-idsignals_categories_explainedasignals-categories-explained><a id=Signals_categories_explained></a>Signals categories explained</a></li><li><a href=#a-idsignals_and_processes_statesasignals-and-processes-states><a id=Signals_and_Processes_States></a>Signals and Processes States</a></li></ol><ol><li><a href=#a-idusing_the_pgrep_commandausing-the-pgrep-command><a id=Using_the_pgrep_command></a>Using the pgrep command</a></li><li><a href=#a-idusing_the_pkill_commandausing-the-pkill-command><a id=Using_the_pkill_command></a>Using the pkill command</a></li></ol><ol><li><a href=#a-idniceness_and_permissionsaniceness-and-permissions><a id=Niceness_and_permissions></a>Niceness and permissions</a></li></ol><ol><li><a href=#a-idusing_top_on_linuxausing-top-on-linux><a id=Using_top_on_Linux></a>Using top on Linux</a></li><li><a href=#a-idusing_htop_on_linuxausing-htop-on-linux><a id=Using_htop_on_Linux></a>Using htop on Linux</a></li></ol></nav></details></aside><a href=#a-idlinux_processes_basicsalinux-processes-basics><h1 id=a-idlinux_processes_basicsalinux-processes-basics><span class=hanchor arialabel=Anchor># </span><a id=Linux_Processes_Basics></a>Linux Processes Basics</h1></a><p>In short, <strong>processes are running programs on your Linux host</strong> that perform operations such as writing to a disk, writing to a file, or running a web server for example.</p><p>Process have a <strong>owner</strong> and they are identified by a <strong>process ID</strong> (also called <strong>PID</strong>)</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/process-identity_9e08338194484bfea0ab2ec0b5780677.png width=auto alt="Process Identifier on Linux"></p><p>On the other hand, <strong>programs</strong> are lines or code or lines of machine instructions stored on a persistent data storage.</p><p>They can just sit on your data storage, or they can be in execution, i.e running as processes.</p><img width=780 height=350 src=../../../_resources/program-process_2ebfb8dc46c54bc0acf6e899021d5d6d.png><p>In order to perform the operations they are assigned to, processes need <strong>resources</strong> : <strong>CPU time</strong>, <strong>memory</strong> (such as <strong>RAM</strong> or <strong>disk space</strong>), but also virtual memory such as <strong>swap space</strong> in case your process gets too greedy.</p><p>Obviously, processes can be <strong>started</strong>, <strong>stopped</strong>, <strong>interrupted</strong> and even <strong>killed</strong>.</p><p>Before issuing any commands, let‚Äôs see how processes are created and managed by the kernel itself.</p><a href=#a-idprocess_initialization_on_linuxaprocess-initialization-on-linux><h2 id=a-idprocess_initialization_on_linuxaprocess-initialization-on-linux><span class=hanchor arialabel=Anchor># </span><a id=Process_Initialization_on_Linux></a>Process Initialization on Linux</h2></a><p>As we already stated, processes are <strong>managed by the Kernel</strong> on Linux.</p><p>However, there is a core concept that you need to understand in order to know how Linux creates processes.</p><p>By default, when you boot a Linux system, your Linux kernel is loaded into memory, it is given a virtual filesystem in the RAM (also called <strong>initramfs</strong>) and the initial commands are executed.</p><p>One of those commands starts <strong>the very first process on Linux.</strong></p><p>Historically, this process was called the
<a href=https://en.wikipedia.org/wiki/Init rel=noopener>init process</a> but it got replaced by the
<a href=https://en.wikipedia.org/wiki/Systemd rel=noopener>systemd initialization process</a> on many recent Linux distributions.</p><p>To prove it, run the following command on your host</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps -aux | head -n 2
</span></span></code></pre></td></tr></table></div></div><img width=780 height=80 src=../../../_resources/systemd_e397c788c4be43d69a5322411ae38665.png><p>As you can see, the systemd process has <strong>a PID of 1.</strong></p><p>If you were to print all processes on your system, using a tree display, you would find that all processes are children of the systemd one.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pstree
</span></span></code></pre></td></tr></table></div></div><p><img src=https://deuxfois.github.io/quartz//../../../_resources/pstree_f8b96a2797534a7aa602060412e2ce6e.png width=auto alt="Listing processes as a tree on Linux"></p><p>It is noteworthy to underline the fact that all those initialization steps (except for the launch of the initial process) are done in a reserved space called <strong>the kernel space.</strong></p><p>The kernel space is <strong>a space reserved to the Kernel</strong> in order for it to run essential system tools properly and to make sure that your entire host is running in a consistent way.</p><p>On the other hand, <strong>user space is reserved for processes</strong> launched by the user and managed by the kernel itself.</p><img width=780 height=372 src=../../../_resources/user-kernel-space_c52325429baa4dd7a68767bc1379d08c.png><p>As a consequence, the systemd process is the very first process launched in the user space.</p><a href=#a-idprocess_creation_using_fork_and_execaprocess-creation-using-fork-and-exec><h2 id=a-idprocess_creation_using_fork_and_execaprocess-creation-using-fork-and-exec><span class=hanchor arialabel=Anchor># </span><a id=Process_Creation_using_Fork_and_Exec></a>Process Creation using Fork and Exec</h2></a><p>When you are creating and running a program on Linux, it generally involves two main steps : <strong>fork</strong> and <strong>execute</strong>.</p><a href=#a-idfork_operationafork-operation><h3 id=a-idfork_operationafork-operation><span class=hanchor arialabel=Anchor># </span><a id=Fork_operation></a>Fork operation</h3></a><p><a href=http://man7.org/linux/man-pages/man2/fork.2.html rel=noopener>Fork</a> is a clone operation, it takes the current process, also called the parent process, and it clones it in a new process with a brand new process ID.</p><p>When forking, everything is copied from the parent process : <strong>the stack</strong>, <strong>the heap</strong>, but also the file descriptors meaning <strong>the standard input, the standard output and the standard error.</strong></p><p>It means that if my parent process was writing to the current shell console, the child process will also write to the shell console.</p><img width=780 height=735 src=../../../_resources/fork_7bb5c5408b814ecd9705276dc6bc559a.png><p>The execution of the cloned process will also start <strong>at the same instruction as the parent process.</strong></p><a href=#a-idexecute_operationaexecute-operation><h3 id=a-idexecute_operationaexecute-operation><span class=hanchor arialabel=Anchor># </span><a id=Execute_operation></a>Execute operation</h3></a><p>The execute operation is used on Linux <strong>to replace the current process image with the image from another process.</strong></p><p>On the previous diagram, we saw that the stack of the parent process contained three instructions left.</p><p>As a consequence, the instructions were copied to the new process but they are not relevant to what we want to execute.</p><p>The
<a href=http://man7.org/linux/man-pages/man3/exec.3.html rel=noopener>exec</a> operation will replace the process image (i.e the set of instructions that need to be executed) by another one.</p><img width=780 height=531 src=../../../_resources/exec_587944a2a3b44172b5aceb9bbd4d0ec4.png><p>If you were for example to execute the exec command in your bash terminal, your shell would terminate as soon as the command is completed as your current process image (your bash interpreter) would be replaced with the context of the command you are trying to launch.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ exec ls -l
</span></span></code></pre></td></tr></table></div></div><p>If you were to trace the system calls done when creating a process, you would find that the first C command called is the exec one.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/strace-linux_76af78a5711b4d2eb63d322830e31d8e.png width=auto alt="Strace process on Linux"></p><a href=#a-idcreating_processes_from_a_shell_environmentacreating-processes-from-a-shell-environment><h3 id=a-idcreating_processes_from_a_shell_environmentacreating-processes-from-a-shell-environment><span class=hanchor arialabel=Anchor># </span><a id=Creating_processes_from_a_shell_environment></a>Creating processes from a shell environment</h3></a><p>When you are launching a shell console, the exact same principles apply when you are launching a command.</p><p>A shell console is a process that waits for input from the user.</p><p>It also launches a bash interpreter when you hit Enter and it provides an environment for your commands to run.</p><p>But the shell follows the steps we described earlier.</p><p>When you hit enter, <strong>the shell is forked to a child process</strong> that will be responsible for running your command. The shell will wait patiently until the execution of the child process finishes.</p><p>On the other hand, <strong>the child process is linked to the same file descriptors</strong> and it may share variables that were declared on a global scope.</p><p>The child process executes the ‚Äú<strong>exec</strong>‚Äù command in order to replace the current process image (which is the shell process image) in the process image of the command you are trying to run.</p><p>The child process will eventually finish and it will print its result to the standard output it inherited from the parent process, in this case the shell console itself.</p><img width=780 height=635 src=../../../_resources/shell-execution_317473d9724b43ac81342e9117ecf762.png><p>Now that you have some basics about how processes are created in your Linux environment, let‚Äôs see some details about processes and how they can be identified easily.</p><a href=#a-ididentifying_running_processes_on_linuxaidentifying-running-processes-on-linux><h2 id=a-ididentifying_running_processes_on_linuxaidentifying-running-processes-on-linux><span class=hanchor arialabel=Anchor># </span><a id=Identifying_running_processes_on_Linux></a>Identifying running processes on Linux</h2></a><p>The easiest way to identify running processes on Linux is to run the <strong>ps</strong> command.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps
</span></span></code></pre></td></tr></table></div></div><p><img src=https://deuxfois.github.io/quartz//../../../_resources/ps-command_fd50a5d8d0e54f1c9283ae08874b314e.png width=auto alt="Listing processes on Linux using ps"></p><p>By default, the ps command will show you the list of the current running processes owned by the current user.</p><p>In this case, only two processes are running for my user : <strong>the bash interpreter</strong> and the <strong>ps command</strong> I have run into it.</p><p>The important part here is that processes have <strong>owners</strong>, most of the time the user who run them in the first place.</p><p>To illustrate this, let‚Äôs have a listing of the first ten processes on your Linux operating system, with a different display format.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps -ef | head -n 10
</span></span></code></pre></td></tr></table></div></div><img width=780 height=190 src=../../../_resources/ps-ef_3517a481daa74e698d8f13d20908d949.png><p>As you can see here, the top ten processes are owned by the user ‚Äú<strong>root</strong>‚Äú.</p><p>This information will be particularly important when it comes to interacting with processes with signals.</p><p>To display the processes that are owned and executed by the current connected user, run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps u
</span></span></code></pre></td></tr></table></div></div><img width=780 height=178 src=../../../_resources/ps-u_f981c147cbec408493dff8fafc9d584f.png><p>There are plenty of different options for the ps command, and they can be seen by running the manual command.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ man ps
</span></span></code></pre></td></tr></table></div></div><p>From experience, the two most important commands in order to see running processes are</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ps aux
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
</span></span></code></pre></td></tr></table></div></div><p>That corresponds to a <strong>BSD-style process listing</strong>, where the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ps -ef
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>UID  PID  PPID C STIME TTY  TIME CMD
</span></span></code></pre></td></tr></table></div></div><p>Corresponds to a <strong>POSIX-style process listing</strong>.</p><p>They are both representing current running processes on a system, but the first one has the ‚Äúu‚Äù option for ‚Äúuser oriented‚Äù which makes it easier to read process metrics.</p><img width=780 height=179 src=../../../_resources/ps-aux_6603779b8edc40c696dfd61a6854361e.png><p>Now that you have seen what processes are and how they can be listed, let‚Äôs see what background and foreground processes are on your host.</p><a href=#a-idbackground_and_foreground_processesabackground-and-foreground-processes><h1 id=a-idbackground_and_foreground_processesabackground-and-foreground-processes><span class=hanchor arialabel=Anchor># </span><a id=Background_and_foreground_processes></a>Background and foreground processes</h1></a><p>The definition of background and foreground processes are pretty self-explanatory.</p><a href=#a-idjobs_and_processes_in_the_current_shellajobs-and-processes-in-the-current-shell><h2 id=a-idjobs_and_processes_in_the_current_shellajobs-and-processes-in-the-current-shell><span class=hanchor arialabel=Anchor># </span><a id=Jobs_and_processes_in_the_current_shell></a>Jobs and processes in the current shell</h2></a><p><strong>A background process on Linux is a process that runs in the background, meaning that it is not actively managed by a user through a shell for example.</strong></p><p>On the opposite side, <strong>a foreground process is a process that can be interacted with via direct user input.</strong></p><p>Let‚Äôs say for example that you have opened a shell terminal, and that you typed the following command in your console.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sleep 10000
</span></span></code></pre></td></tr></table></div></div><p>As you probably noticed, your terminal will hang until the termination of the sleep process. As a consequence, the process is not executed in the background, it is executed in the foreground.</p><p>I am able to interact with it. If I press Ctrl + Z, it will directly send a stop signal to the process for example.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/foreground_a57153f72fa14098a64951fc1f4ec59c.png width=auto alt="Sleep process in bash shell"></p><p>However, there is a way to execute the process in the background.</p><p>To execute a process in the background, simply put a ‚Äú<strong>&</strong>‚Äù sign at the end of your command.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sleep 10000 &amp;
</span></span></code></pre></td></tr></table></div></div><p>As you can see, the control was directly given back to the user and the process started executing in the background</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/background_6cc108d8bfc147d3a6f5544896c455b2.png width=auto alt="Executing a process in the background on Linux"></p><p>To see your process running, in the context of the current shell, you can execute the jobs command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ jobs
</span></span></code></pre></td></tr></table></div></div><p><img src=https://deuxfois.github.io/quartz//../../../_resources/jobs_c7fae9f3f75b4800bc1fb3c1350f6d0a.png width=auto alt="Listing jobs on the shell"></p><p>Jobs are a list of processes that were started in the context of the current shell and that may still be running in the background.</p><p>As you can see in the example above, I have two processes currently running in the background.</p><p>The different columns from left to right represent the the <strong>job ID, the process state</strong> (that you will discover in the next section), and <strong>the command executed.</strong></p><a href=#a-idusing_the_bg_and_fg_commandsausing-the-bg-and-fg-commands><h2 id=a-idusing_the_bg_and_fg_commandsausing-the-bg-and-fg-commands><span class=hanchor arialabel=Anchor># </span><a id=Using_the_bg_and_fg_commands></a>Using the bg and fg commands</h2></a><p>In order to interact with jobs, you have two commands available : <strong>bg</strong> and <strong>fg</strong>.</p><p><strong>The bg command is used on Linux in order to send a process to the background</strong> and the syntax is as follows</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ bg %&lt;job_id&gt;
</span></span></code></pre></td></tr></table></div></div><p>Similarly, in order to send a process to the foreground, you can use the <strong>fg</strong> in the same fashion</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fg %&lt;job_id&gt;
</span></span></code></pre></td></tr></table></div></div><p>If we go back to the list of jobs of our previous example, if I want to bring the job 3 to the foreground, meaning to the current shell window, I would execute the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fg %3
</span></span></code></pre></td></tr></table></div></div><p><img src=https://deuxfois.github.io/quartz//../../../_resources/fg-1_3251249fed57481095751cde8d83d5e8.png width=auto alt="Sending a process to the foreground on Linux"></p><p>By issuing a Ctrl + Z command, I am able to stop the process. I can link it with a bg command in order to send it to the background.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/bg-1_222dbdff777d4b7bacb1b8332c951592.png width=auto alt="Sending a process to the background on Linux"></p><p>Now that you have a better idea of what background and foreground processes are, let‚Äôs see how it is possible for you to interact with process using signals.</p><a href=#a-idinteracting_with_processes_using_signalsainteracting-with-processes-using-signals><h1 id=a-idinteracting_with_processes_using_signalsainteracting-with-processes-using-signals><span class=hanchor arialabel=Anchor># </span><a id=Interacting_with_processes_using_signals></a>Interacting with processes using signals</h1></a><p>On Linux, signals are a form of <strong>interprocess communication</strong> (also called <strong>IPC</strong>) that creates and sends asynchronous notifications to running processes about the occurrence of a specific event.</p><p>Signals are often used in order to <strong>send a kill</strong> or a <strong>termination command</strong> to a process in order to shut it down (also called kill signal).</p><p>In order to send a signal to a process, you have to use the <strong>kill</strong> command.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -&lt;signal number&gt; &lt;pid&gt;|&lt;process_name&gt;
</span></span></code></pre></td></tr></table></div></div><p>For example, in order to force a HTTPD process (PID = 123) to terminate (without a clean shutdown), you would run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -9 123
</span></span></code></pre></td></tr></table></div></div><a href=#a-idsignals_categories_explainedasignals-categories-explained><h2 id=a-idsignals_categories_explainedasignals-categories-explained><span class=hanchor arialabel=Anchor># </span><a id=Signals_categories_explained></a>Signals categories explained</h2></a><p>As explained, there are many signals that one can send in order to notify a specific process.</p><p>Here is the list of the most common used ones :</p><ul><li><p><strong>SIGINT</strong> : short for signal interrupt is a signal used in order to interrupt a running process. It is also the signal that is being sent when a user pressed Ctrl + C on a terminal;</p></li><li><p><strong>SIGHUP</strong> : short for signal hangup is the signal sent by your terminal when it is closed. Similarly to a SIGINT, the process terminates;</p></li><li><p><strong>SIGKILL</strong> : signal used in order to force a process to stop whether it can be gracefully stopped or not. This signal can not be ignored except for the init process (or the systemd one on recent distributions);</p></li><li><p><strong>SIGQUIT</strong> : specific signal sent when a user wants to quit or to exit the current process. It can be invoked by pressing Ctrl + D and it is often used in terminal shells or in SSH sessions;</p></li><li><p><strong>SIGUSR1, SIGUSR2</strong> : those signals are used purely for communication purposes and they can be used in programs in order to implement custom handlers;</p></li><li><p><strong>SIGSTOP</strong> : instructs the process to stop its execution without terminating the process. The process is then waiting to be continued or to be killed completely;</p></li><li><p><strong>SIGCONT</strong> : if the process is marked as stopped, it instructs the process to start its execution again.</p></li></ul><p>In order to see the full list of all signals available, you can run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -l
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
</span></span><span class=line><span class=cl> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
</span></span><span class=line><span class=cl> 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
</span></span><span class=line><span class=cl>13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
</span></span><span class=line><span class=cl>17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
</span></span><span class=line><span class=cl>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
</span></span><span class=line><span class=cl>25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
</span></span><span class=line><span class=cl>29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
</span></span><span class=line><span class=cl>35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
</span></span><span class=line><span class=cl>39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
</span></span><span class=line><span class=cl>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
</span></span><span class=line><span class=cl>47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
</span></span><span class=line><span class=cl>51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
</span></span><span class=line><span class=cl>55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
</span></span><span class=line><span class=cl>59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
</span></span><span class=line><span class=cl>63) SIGRTMAX-1  64) SIGRTMAX
</span></span></code></pre></td></tr></table></div></div><a href=#a-idsignals_and_processes_statesasignals-and-processes-states><h2 id=a-idsignals_and_processes_statesasignals-and-processes-states><span class=hanchor arialabel=Anchor># </span><a id=Signals_and_Processes_States></a>Signals and Processes States</h2></a><p>Now that you know that it is possible to interrupt, kill or stop processes, it is time for you to learn about processes states.</p><p>Processes have many different states, they can be :</p><ul><li><strong>Running</strong> : processes running are the ones using some computational power (such as CPU time) in the current time. A process can also be called ‚Äúrunnable‚Äù if all running conditions are met, and it is waiting for some CPU time by the CPU scheduler.</li><li><strong>Stopped</strong> : a signal is stopped is linked to the SIGSTOP signal or to the Ctrl + Z keyboard shortcut. The process execution is suspended and it is either waiting for a SIGCONT or for a SIGKILL.</li><li><strong>Sleeping</strong> : a sleeping process is a process waiting for some event or for a resource (like a disk) to be available.</li></ul><p>Here is a diagram that represents the different process states linked to the signals you may send to them.</p><img width=780 height=578 src=../../../_resources/process-states_d46dc2a8bdba400ebdfe454727607d60.png><p>Now that you know a bit more about process states, let‚Äôs have a look at the pgrep and pkill commands.</p><a href=#a-idmanipulating_process_with_pgrep_and_pkillamanipulating-process-with-pgrep-and-pkill><h1 id=a-idmanipulating_process_with_pgrep_and_pkillamanipulating-process-with-pgrep-and-pkill><span class=hanchor arialabel=Anchor># </span><a id=Manipulating_process_with_pgrep_and_pkill></a>Manipulating process with pgrep and pkill</h1></a><p>On Linux, there is already a lot that you can do by simply using the ps command.</p><p>You can narrow down your search to one particular process, and you can use the PID in order to kill it completely.</p><p>However, there are two commands that were designed in order for your commands to be even shorter : <strong>pgrep and pkill</strong></p><a href=#a-idusing_the_pgrep_commandausing-the-pgrep-command><h2 id=a-idusing_the_pgrep_commandausing-the-pgrep-command><span class=hanchor arialabel=Anchor># </span><a id=Using_the_pgrep_command></a>Using the pgrep command</h2></a><p>The <strong>pgrep</strong> command is a shortcut for using the ps command piped with the grep command.</p><p><strong>The pgrep command will search for all the occurrences for a specific process using a name or a defined pattern.</strong></p><p>The syntax of the pgrep command is the following one</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pgrep &lt;options&gt; &lt;pattern&gt;
</span></span></code></pre></td></tr></table></div></div><p>For example, if you were to search for all processes named ‚Äúbash‚Äù on your host, you would run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pgrep bash
</span></span></code></pre></td></tr></table></div></div><p>The pgrep command is not restricted to the processes owned by the current user by default.</p><p>If another user was to run the bash command, it would appear in the output of the pgrep command.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/pgrep_976100396f8d4735885da94c52cf88f1.png width=auto alt="Searching for processes using pgrep on Linux"></p><p>It is also possible to search for processes using
<a href=https://en.wikipedia.org/wiki/Glob_%28programming%29 rel=noopener>globbing characters.</a></p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/pgrep-globbing_6f0a4a2cef1b48ff8538d7485058ac17.png width=auto alt="Using globbing characters with pgrep"></p><a href=#a-idusing_the_pkill_commandausing-the-pkill-command><h2 id=a-idusing_the_pkill_commandausing-the-pkill-command><span class=hanchor arialabel=Anchor># </span><a id=Using_the_pkill_command></a>Using the pkill command</h2></a><p>On the other hand, the pkill command is also a shortcut for the ps command used with the kill command.</p><p>The pkill command is used in order to send signal to processes based on their IDs or their names.</p><p>The syntax of the pkill command is as follows</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pkill &lt;options&gt; &lt;pattern&gt;
</span></span></code></pre></td></tr></table></div></div><p>For example, if you want to kill all Firefox windows on your host, you would run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pkill firefox
</span></span></code></pre></td></tr></table></div></div><p>Similarly to the pgrep command, you have the option to narrow down your results by specifying a user with the -u option.</p><p>To kill all processes starting with ‚Äúfire‚Äù and owned by the current user and root, you would run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pkill user,root fire*
</span></span></code></pre></td></tr></table></div></div><p>If you don‚Äôt have the rights to stop a process, you will get a permission denied error message to your standard output.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/permission-denied-1_857780e2ee74434f9ecd810a87ddd2.png width=auto alt></p><p>You also have the option to send specific signals by specifying the signal number in the pkill command</p><p>For example, in order to stop Firefox with a SIGSTOP signal, you would run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pkill -19 firefox
</span></span></code></pre></td></tr></table></div></div><a href=#a-idadjusting_process_priority_using_nice_and_reniceaadjusting-process-priority-using-nice-and-renice><h1 id=a-idadjusting_process_priority_using_nice_and_reniceaadjusting-process-priority-using-nice-and-renice><span class=hanchor arialabel=Anchor># </span><a id=Adjusting_process_priority_using_nice_and_renice></a>Adjusting process priority using nice and renice</h1></a><p>On Linux, not all processes are given the same priority when it comes to the CPU time.</p><p>Some processes, such as very important processes run by root, are given a higher priority in order for the operating system to work on tasks that truly matter to the system.</p><p><strong>Process priority on Linux is called the nice level.</strong></p><p>The nice level is a priority scale going from <strong>-20 to 19.</strong></p><p>The lower you go on the niceness scale, the higher the priority will be.</p><p>Similarly, the higher you are on the niceness scale, the lower your priority will be.</p><p>In order to remember it, you can remember the fact that <strong>‚Äúthe nicer you are, the more you are willing to share resources with others‚Äù.</strong></p><img width=780 height=323 src=../../../_resources/nice_c279a4ea19404e509e57ade59bdd69f7.png><p>In order to start a certain program or process with a given nice level, you will run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nice -n &lt;level&gt; &lt;command&gt;
</span></span></code></pre></td></tr></table></div></div><p>For example, in order to run the tar command with a custom tar level, you would run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nice -n 19 tar -cvf test.tar file
</span></span></code></pre></td></tr></table></div></div><p>Similarly, you can use the renice command in order to set the nice level of a running process to a given value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ renice -n &lt;priority&gt; &lt;pid&gt;
</span></span></code></pre></td></tr></table></div></div><p>For example, if I have a running process with the PID 123, I can use the renice command in order to set its priority to a given value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ renice -n 18 123
</span></span></code></pre></td></tr></table></div></div><a href=#a-idniceness_and_permissionsaniceness-and-permissions><h2 id=a-idniceness_and_permissionsaniceness-and-permissions><span class=hanchor arialabel=Anchor># </span><a id=Niceness_and_permissions></a>Niceness and permissions</h2></a><p>If you are not a member of the sudo group (or a member of the wheel group on Red Hat based distributions), there are some restrictions when it comes to what you can with the nice command.</p><p>To illustrate it, try to run the following command as a non-sudo user</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nice -n -1 tar -cvf test.tar file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nice: cannot set niceness: Permission denied
</span></span></code></pre></td></tr></table></div></div><p><img src=https://deuxfois.github.io/quartz//../../../_resources/nice-permissions_cb4805aadb2a4ccf9dad16a09102b252.png width=auto alt="Permission denied on nice command"></p><p>When it comes to niceness, there is one rule that you need to know :</p><p><strong>As a non-root (or sudo) user, you won‚Äôt be able to set a nice level lower than the default assigned one (which is zero), and you won‚Äôt be able to renice a running process to a lower level than the current one.</strong></p><p>To illustrate the last point, launch a sleep command in the background with a nice value of 2.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nice -n 2 sleep 10000 &amp;
</span></span></code></pre></td></tr></table></div></div><p>Next, identify the process ID of the process you just created.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/sleep-10000_bf4e5eb51bc34b05bb65486bec2fd566.png width=auto alt="searching for a sleep process on Linux using ps"></p><p>Now, try to set the nice level of your process to a value lower to the one you specified in the first place.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ renice -n 1 8363
</span></span></code></pre></td></tr></table></div></div><p><img src=https://deuxfois.github.io/quartz//../../../_resources/renice_c8357ae2878645d2978acb05d5c7c443.png width=auto alt="Using renice to change process priority on Linux"></p><p>As you probably noticed, you won‚Äôt be able to set the niceness level to 1, but only to a value higher than the one you specified.</p><p>Now if you choose to execute the command as sudo, you will be able to set the nice level to a lower value.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/sudo-rence_6e2bd1c55ce249be8991b805f9bc3257.png width=auto alt="Forcing renice on Linux"></p><p>Now that you have a clear idea of the nice and renice commands, let‚Äôs see how you can monitor your processes in real time on Linux.</p><a href=#a-idmonitoring_processes_on_linux_using_top_and_htopamonitoring-processes-on-linux-using-top-and-htop><h1 id=a-idmonitoring_processes_on_linux_using_top_and_htopamonitoring-processes-on-linux-using-top-and-htop><span class=hanchor arialabel=Anchor># </span><a id=Monitoring_processes_on_Linux_using_top_and_htop></a>Monitoring processes on Linux using top and htop</h1></a><p>In a previous article, we discussed how it is possible to build a complete monitoring pipeline in order to
<a href=https://devconnected.com/monitoring-linux-processes-using-prometheus-and-grafana/ rel=noopener>monitor Linux processes in real time.</a></p><a href=#a-idusing_top_on_linuxausing-top-on-linux><h2 id=a-idusing_top_on_linuxausing-top-on-linux><span class=hanchor arialabel=Anchor># </span><a id=Using_top_on_Linux></a>Using top on Linux</h2></a><p><strong>Top is an interactive command that any user can run in order to have a complete and ordered listing of all processes running on a Linux host.</strong></p><p>To run top, simply execute it without any arguments.</p><p>Top will run in interactive mode.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ top
</span></span></code></pre></td></tr></table></div></div><p>If you want to run top for a custom number of iterations, run the following command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ top -n &lt;number&gt;
</span></span></code></pre></td></tr></table></div></div><img width=780 height=292 src=../../../_resources/top_2a990386526b4826808beea8d8fa36d0.png><p>The top command will first show recap statistics about your system at the top, for example the number of tasks running, the percentage of CPU used or the memory consumption.</p><p>Right below it, you have access to a live list of all processes running or sleeping on your host.</p><p>This view will refresh every three seconds, but you can obviously tweak this parameter.</p><p>To increase the refresh rate in the top command, press the ‚Äúd‚Äù command and choose a new refresh rate</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/refresh-rate_43c9ebfc7b0342b3bba2c2eedc1006e0.png width=auto alt="Changing top refresh rate"></p><p>Similarly, you can change the nice value of a running process live by pressing the ‚Äúr‚Äù key on your keyboard.</p><p>The same permissions rules apply if you want to modify processes to a value lower to the one they are already assigned.</p><p>As a consequence, you may need to run the command as sudo.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/renice-top_b0160f9b42d1420fa6210c3ecf0a9cc3.png width=auto alt="Changing process priority on top"></p><a href=#a-idusing_htop_on_linuxausing-htop-on-linux><h2 id=a-idusing_htop_on_linuxausing-htop-on-linux><span class=hanchor arialabel=Anchor># </span><a id=Using_htop_on_Linux></a>Using htop on Linux</h2></a><p>Alternatively, if you are looking for a nicer way to visualize processes on your Linux host, you can use the htop command.</p><p>By default, the htop command is not available on most distributions, so you will need to install it with the following instructions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>$ sudo apt-get install htop
</span></span></code></pre></td></tr></table></div></div><p>If you are running a Red Hat based distribution, run the following commands.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sudo yum -y install epel-release
</span></span><span class=line><span class=cl>$ sudo yum -y update
</span></span><span class=line><span class=cl>$ sudo yum -y install htop
</span></span></code></pre></td></tr></table></div></div><p>Finally, to run the htop command, simply run it without any arguments.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ htop
</span></span></code></pre></td></tr></table></div></div><img width=780 height=472 src=../../../_resources/htop_57f62cd884634cc294953e8acd04ebde.png><p>As you can see, the output is very similar except that it showcases information in a more human friendly output.</p><a href=#a-idconclusionaconclusion><h1 id=a-idconclusionaconclusion><span class=hanchor arialabel=Anchor># </span><a id=Conclusion></a>Conclusion</h1></a><p>In this tutorial, you learnt many concepts about processes : how they are created, how they can be managed and how they can be monitored effectively.</p><p>If you are looking for more tutorials related to Linux system administration, we have a complete section dedicated to it on the website, so make sure to check it out.</p></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/Master/Concurrence/ data-ctx="Understanding Processes on Linux" data-src=/Master/Concurrence class=internal-link></a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://deuxfois.github.io/quartz/js/graph.afdb02e537635f9a611b53a988e5645b.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, ¬© 2022</p><ul><li><a href=https://deuxfois.github.io/quartz/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>