<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Basic Lighting Lighting in the real world is extremely complicated and depends on way too many factors, something we can&rsquo;t afford to calculate on the limited processing power we have."><title>6283. Lighting</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://deuxfois.github.io/quartz//icon.png><link href=https://deuxfois.github.io/quartz/styles.b54f56dc7e7fdf6be9a4427dc6b0509b.min.css rel=stylesheet><link href=https://deuxfois.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://deuxfois.github.io/quartz/js/darkmode.69b2c08ae0f08c3a3f86259a122e1f06.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/util.39f53d45cb9520bdaf946bd063598b19.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://deuxfois.github.io/quartz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://deuxfois.github.io/quartz/",fetchData=Promise.all([fetch("https://deuxfois.github.io/quartz/indices/linkIndex.3df01290fdc158a4687bc6daff285251.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://deuxfois.github.io/quartz/indices/contentIndex.bebee24aa0a352899c4f4530d9968578.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!1;drawGraph("https://deuxfois.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://deuxfois.github.io/quartz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/deuxfois.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://deuxfois.github.io/quartz/js/full-text-search.0ec5fb908204b9e13989f2c640c0870b.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://deuxfois.github.io/quartz/>ðŸª´ Quartz 3.2</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>6283. Lighting</h1><p class=meta>Last updated
Aug 2, 2022
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/Master/Graphisme/Lighting.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://deuxfois.github.io/quartz/tags/graphisme/>Graphisme</a></li><li><a href=https://deuxfois.github.io/quartz/tags/s1/>S1</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#normal-vectors>Normal vectors</a></li><li><a href=#calculating-the-diffuse-color>Calculating the diffuse color</a></li><li><a href=#one-last-thing>One last thing</a></li></ol><ol><li><a href=#exercises>Exercises</a></li></ol></nav></details></aside><a href=#basic-lighting><h1 id=basic-lighting><span class=hanchor arialabel=Anchor># </span>Basic Lighting</h1></a><p>Lighting in the real world is extremely complicated and depends on way too many factors, something we can&rsquo;t afford to calculate on the limited processing power we have. Lighting in OpenGL is therefore based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the Phong lighting model. The major building blocks of the Phong lighting model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components look like on their own and combined:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_phong_8ee6858443a74e57a4b2b67b23c82.png width=auto alt></p><ul><li>Ambient lighting: even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color.</li><li>Diffuse lighting: simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes.</li><li>Specular lighting: simulates the bright spot of a light that appears on shiny objects. Specular highlights are more inclined to the color of the light than the color of the object.</li></ul><p>To create visually interesting scenes we want to at least simulate these 3 lighting components. We&rsquo;ll start with the simplest one: <em>ambient lighting</em>.</p><a href=#ambient-lighting><h1 id=ambient-lighting><span class=hanchor arialabel=Anchor># </span>Ambient lighting</h1></a><p>Light usually does not come from a single light source, but from many light sources scattered all around us, even when they&rsquo;re not immediately visible. One of the properties of light is that it can scatter and bounce in many directions, reaching spots that aren&rsquo;t directly visible; light can thus <em>reflect</em> on other surfaces and have an indirect impact on the lighting of an object. Algorithms that take this into consideration are called global illumination algorithms, but these are complicated and expensive to calculate.</p><p>Since we&rsquo;re not big fans of complicated and expensive algorithms we&rsquo;ll start by using a very simplistic model of global illumination, namely ambient lighting. As you&rsquo;ve seen in the previous section we use a small constant (light) color that we add to the final resulting color of the object&rsquo;s fragments, thus making it look like there is always some scattered light even when there&rsquo;s not a direct light source.</p><p>Adding ambient lighting to the scene is really easy. We take the light&rsquo;s color, multiply it with a small constant ambient factor, multiply this with the object&rsquo;s color, and use that as the fragment&rsquo;s color in the cube object&rsquo;s shader:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> void main()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    float ambientStrength = 0.1;
</span></span><span class=line><span class=cl>    vec3 ambient = ambientStrength * lightColor;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    vec3 result = ambient * objectColor;
</span></span><span class=line><span class=cl>    FragColor = vec4(result, 1.0);
</span></span><span class=line><span class=cl>} 
</span></span></code></pre></td></tr></table></div></div><p>If you&rsquo;d now run the program, you&rsquo;ll notice that the first stage of lighting is now successfully applied to the object. The object is quite dark, but not completely since ambient lighting is applied (note that the light cube is unaffected because we use a different shader). It should look something like this:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/ambient_lighting_4686363ba886497699db0ae2358218e6.png width=auto alt></p><a href=#diffuse-lighting><h1 id=diffuse-lighting><span class=hanchor arialabel=Anchor># </span>Diffuse lighting</h1></a><p>Ambient lighting by itself doesn&rsquo;t produce the most interesting results, but diffuse lighting however will start to give a significant visual impact on the object. Diffuse lighting gives the object more brightness the closer its fragments are aligned to the light rays from a light source. To give you a better understanding of diffuse lighting take a look at the following image:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/diffuse_light_b8f7990b6fea411ba10b504bca0f124d.png width=auto alt></p><p>To the left we find a light source with a light ray targeted at a single fragment of our object. We need to measure at what angle the light ray touches the fragment. If the light ray is perpendicular to the object&rsquo;s surface the light has the greatest impact. To measure the angle between the light ray and the fragment we use something called a normal vector, that is a vector perpendicular to the fragment&rsquo;s surface (here depicted as a yellow arrow); we&rsquo;ll get to that later. The angle between the two vectors can then easily be calculated with the dot product.</p><p>You may remember from the
<a href=https://learnopengl.com/Getting-started/Transformations rel=noopener>transformations</a> chapter that, the lower the angle between two unit vectors, the more the dot product is inclined towards a value of 1. When the angle between both vectors is 90 degrees, the dot product becomes 0. The same applies to <a id=MathJax-Element-1-Frame></a><a id=MathJax-Span-1></a><a id=MathJax-Span-2></a><a id=MathJax-Span-3></a>Î¸</p><p>$\theta$: the larger <a id=MathJax-Element-2-Frame></a><a id=MathJax-Span-4></a><a id=MathJax-Span-5></a><a id=MathJax-Span-6></a>Î¸</p><p>$\theta$ becomes, the less of an impact the light should have on the fragment&rsquo;s color.</p><p>Note that to get (only) the cosine of the angle between both vectors we will work with <em>unit vectors</em> (vectors of length <code>1</code>) so we need to make sure all the vectors are normalized, otherwise the dot product returns more than just the cosine (see
<a href=https://learnopengl.com/Getting-started/Transformations rel=noopener>Transformations</a>).</p><p>The resulting dot product thus returns a scalar that we can use to calculate the light&rsquo;s impact on the fragment&rsquo;s color, resulting in differently lit fragments based on their orientation towards the light.</p><p>So, what do we need to calculate diffuse lighting:</p><ul><li>Normal vector: a vector that is perpendicular to the vertex&rsquo; surface.</li><li>The directed light ray: a direction vector that is the difference vector between the light&rsquo;s position and the fragment&rsquo;s position. To calculate this light ray we need the light&rsquo;s position vector and the fragment&rsquo;s position vector.</li></ul><a href=#normal-vectors><h2 id=normal-vectors><span class=hanchor arialabel=Anchor># </span>Normal vectors</h2></a><p>A normal vector is a (unit) vector that is perpendicular to the surface of a vertex. Since a vertex by itself has no surface (it&rsquo;s just a single point in space) we retrieve a normal vector by using its surrounding vertices to figure out the surface of the vertex. We can use a little trick to calculate the normal vectors for all the cube&rsquo;s vertices by using the cross product, but since a 3D cube is not a complicated shape we can simply manually add them to the vertex data. The updated vertex data array can be found
<a href="https://learnopengl.com/code_viewer.php?code=lighting/basic_lighting_vertex_data" rel=noopener>here</a>. Try to visualize that the normals are indeed vectors perpendicular to each plane&rsquo;s surface (a cube consists of 6 planes).</p><p>Since we added extra data to the vertex array we should update the cube&rsquo;s vertex shader:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> #version 330 core
</span></span><span class=line><span class=cl>layout (location = 0) in vec3 aPos;
</span></span><span class=line><span class=cl>layout (location = 1) in vec3 aNormal;
</span></span><span class=line><span class=cl>... 
</span></span></code></pre></td></tr></table></div></div><p>Now that we added a normal vector to each of the vertices and updated the vertex shader we should update the vertex attribute pointers as well. Note that the light source&rsquo;s cube uses the same vertex array for its vertex data, but the lamp shader has no use of the newly added normal vectors. We don&rsquo;t have to update the lamp&rsquo;s shaders or attribute configurations, but we have to at least modify the vertex attribute pointers to reflect the new vertex array&rsquo;s size:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
</span></span><span class=line><span class=cl>glEnableVertexAttribArray(0); 
</span></span></code></pre></td></tr></table></div></div><p>We only want to use the first <code>3</code> floats of each vertex and ignore the last <code>3</code> floats so we only need to update the <em>stride</em> parameter to <code>6</code> times the size of a <code>float</code> and we&rsquo;re done.</p><p>It may look inefficient using vertex data that is not completely used by the lamp shader, but the vertex data is already stored in the GPU&rsquo;s memory from the container object so we don&rsquo;t have to store new data into the GPU&rsquo;s memory. This actually makes it more efficient compared to allocating a new VBO specifically for the lamp.</p><p>All the lighting calculations are done in the fragment shader so we need to forward the normal vectors from the vertex shader to the fragment shader. Let&rsquo;s do that:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> out vec3 Normal;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void main()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    gl_Position = projection * view * model * vec4(aPos, 1.0);
</span></span><span class=line><span class=cl>    Normal = aNormal;
</span></span><span class=line><span class=cl>} 
</span></span></code></pre></td></tr></table></div></div><p>What&rsquo;s left to do is declare the corresponding input variable in the fragment shader:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> in vec3 Normal; 
</span></span></code></pre></td></tr></table></div></div><a href=#calculating-the-diffuse-color><h2 id=calculating-the-diffuse-color><span class=hanchor arialabel=Anchor># </span>Calculating the diffuse color</h2></a><p>We now have the normal vector for each vertex, but we still need the light&rsquo;s position vector and the fragment&rsquo;s position vector. Since the light&rsquo;s position is a single static variable we can declare it as a uniform in the fragment shader:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> uniform vec3 lightPos; 
</span></span></code></pre></td></tr></table></div></div><p>And then update the uniform in the render loop (or outside since it doesn&rsquo;t change per frame). We use the lightPos vector declared in the previous chapter as the location of the diffuse light source:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> lightingShader.setVec3(&#34;lightPos&#34;, lightPos); 
</span></span></code></pre></td></tr></table></div></div><p>Then the last thing we need is the actual fragment&rsquo;s position. We&rsquo;re going to do all the lighting calculations in world space so we want a vertex position that is in world space first. We can accomplish this by multiplying the vertex position attribute with the model matrix only (not the view and projection matrix) to transform it to world space coordinates. This can easily be accomplished in the vertex shader so let&rsquo;s declare an output variable and calculate its world space coordinates:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> out vec3 FragPos;  
</span></span><span class=line><span class=cl>out vec3 Normal;
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>void main()
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    gl_Position = projection * view * model * vec4(aPos, 1.0);
</span></span><span class=line><span class=cl>    FragPos = vec3(model * vec4(aPos, 1.0));
</span></span><span class=line><span class=cl>    Normal = aNormal;
</span></span><span class=line><span class=cl>} 
</span></span></code></pre></td></tr></table></div></div><p>And lastly add the corresponding input variable to the fragment shader:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> in vec3 FragPos; 
</span></span></code></pre></td></tr></table></div></div><p>This <code>in</code> variable will be interpolated from the 3 world position vectors of the triangle to form the FragPos vector that is the per-fragment world position. Now that all the required variables are set we can start the lighting calculations.</p><p>The first thing we need to calculate is the direction vector between the light source and the fragment&rsquo;s position. From the previous section we know that the light&rsquo;s direction vector is the difference vector between the light&rsquo;s position vector and the fragment&rsquo;s position vector. As you may remember from the
<a href=https://learnopengl.com/Getting-started/Transformations rel=noopener>transformations</a> chapter we can easily calculate this difference by subtracting both vectors from each other. We also want to make sure all the relevant vectors end up as unit vectors so we normalize both the normal and the resulting direction vector:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> vec3 norm = normalize(Normal);
</span></span><span class=line><span class=cl>vec3 lightDir = normalize(lightPos - FragPos); 
</span></span></code></pre></td></tr></table></div></div><p>When calculating lighting we usually do not care about the magnitude of a vector or their position; we only care about their direction. Because we only care about their direction almost all the calculations are done with unit vectors since it simplifies most calculations (like the dot product). So when doing lighting calculations, make sure you always normalize the relevant vectors to ensure they&rsquo;re actual unit vectors. Forgetting to normalize a vector is a popular mistake.</p><p>Next we need to calculate the diffuse impact of the light on the current fragment by taking the dot product between the norm and lightDir vectors. The resulting value is then multiplied with the light&rsquo;s color to get the diffuse component, resulting in a darker diffuse component the greater the angle between both vectors:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> float diff = max(dot(norm, lightDir), 0.0);
</span></span><span class=line><span class=cl>vec3 diffuse = diff * lightColor; 
</span></span></code></pre></td></tr></table></div></div><p>If the angle between both vectors is greater than <code>90</code> degrees then the result of the dot product will actually become negative and we end up with a negative diffuse component. For that reason we use the max function that returns the highest of both its parameters to make sure the diffuse component (and thus the colors) never become negative. Lighting for negative colors is not really defined so it&rsquo;s best to stay away from that, unless you&rsquo;re one of those eccentric artists.</p><p>Now that we have both an ambient and a diffuse component we add both colors to each other and then multiply the result with the color of the object to get the resulting fragment&rsquo;s output color:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> vec3 result = (ambient + diffuse) * objectColor;
</span></span><span class=line><span class=cl>FragColor = vec4(result, 1.0); 
</span></span></code></pre></td></tr></table></div></div><p>If your application (and shaders) compiled successfully you should see something like this:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_diffuse_40d47f7205724c858edecbc3e82.png width=auto alt></p><p>You can see that with diffuse lighting the cube starts to look like an actual cube again. Try visualizing the normal vectors in your head and move the camera around the cube to see that the larger the angle between the normal vector and the light&rsquo;s direction vector, the darker the fragment becomes.</p><p>Feel free to compare your source code with the complete source code
<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.1.basic_lighting_diffuse/basic_lighting_diffuse.cpp" rel=noopener>here</a> if you&rsquo;re stuck.</p><a href=#one-last-thing><h2 id=one-last-thing><span class=hanchor arialabel=Anchor># </span>One last thing</h2></a><p>in the previous section we passed the normal vector directly from the vertex shader to the fragment shader. However, the calculations in the fragment shader are all done in world space, so shouldn&rsquo;t we transform the normal vectors to world space coordinates as well? Basically yes, but it&rsquo;s not as simple as simply multiplying it with a model matrix.</p><p>First of all, normal vectors are only direction vectors and do not represent a specific position in space. Second, normal vectors do not have a homogeneous coordinate (the <code>w</code> component of a vertex position). This means that translations should not have any effect on the normal vectors. So if we want to multiply the normal vectors with a model matrix we want to remove the translation part of the matrix by taking the upper-left <code>3x3</code> matrix of the model matrix (note that we could also set the <code>w</code> component of a normal vector to <code>0</code> and multiply with the 4x4 matrix).</p><p>Second, if the model matrix would perform a non-uniform scale, the vertices would be changed in such a way that the normal vector is not perpendicular to the surface anymore. The following image shows the effect such a model matrix (with non-uniform scaling) has on a normal vector:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_normal_transforma_7571bfabe2d346df9.png width=auto alt></p><p>Whenever we apply a non-uniform scale (note: a uniform scale only changes the normal&rsquo;s magnitude, not its direction, which is easily fixed by normalizing it) the normal vectors are not perpendicular to the corresponding surface anymore which distorts the lighting.</p><p>The trick of fixing this behavior is to use a different model matrix specifically tailored for normal vectors. This matrix is called the normal matrix and uses a few linear algebraic operations to remove the effect of wrongly scaling the normal vectors. If you want to know how this matrix is calculated I suggest the following
<a href=http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/ rel=noopener>article</a>.</p><p>The normal matrix is defined as &rsquo;the transpose of the inverse of the upper-left 3x3 part of the model matrix&rsquo;. Phew, that&rsquo;s a mouthful and if you don&rsquo;t really understand what that means, don&rsquo;t worry; we haven&rsquo;t discussed inverse and transpose matrices yet. Note that most resources define the normal matrix as derived from the model-view matrix, but since we&rsquo;re working in world space (and not in view space) we will derive it from the model matrix.</p><p>In the vertex shader we can generate the normal matrix by using the inverse and transpose functions in the vertex shader that work on any matrix type. Note that we cast the matrix to a 3x3 matrix to ensure it loses its translation properties and that it can multiply with the <code>vec3</code> normal vector:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> Normal = mat3(transpose(inverse(model))) * aNormal; 
</span></span></code></pre></td></tr></table></div></div><p>Inversing matrices is a costly operation for shaders, so wherever possible try to avoid doing inverse operations since they have to be done on each vertex of your scene. For learning purposes this is fine, but for an efficient application you&rsquo;ll likely want to calculate the normal matrix on the CPU and send it to the shaders via a uniform before drawing (just like the model matrix).</p><p>In the diffuse lighting section the lighting was fine because we didn&rsquo;t do any scaling on the object, so there was not really a need to use a normal matrix and we could&rsquo;ve just multiplied the normals with the model matrix. If you are doing a non-uniform scale however, it is essential that you multiply your normal vectors with the normal matrix.</p><a href=#specular-lighting><h1 id=specular-lighting><span class=hanchor arialabel=Anchor># </span>Specular Lighting</h1></a><p>If you&rsquo;re not exhausted already by all the lighting talk we can start finishing the Phong lighting model by adding specular highlights.</p><p>Similar to diffuse lighting, specular lighting is based on the light&rsquo;s direction vector and the object&rsquo;s normal vectors, but this time it is also based on the view direction e.g. from what direction the player is looking at the fragment. Specular lighting is based on the reflective properties of surfaces. If we think of the object&rsquo;s surface as a mirror, the specular lighting is the strongest wherever we would see the light reflected on the surface. You can see this effect in the following image:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_specular_theory_8f17acfe99e94197958.png width=auto alt></p><p>We calculate a reflection vector by reflecting the light direction around the normal vector. Then we calculate the angular distance between this reflection vector and the view direction. The closer the angle between them, the greater the impact of the specular light. The resulting effect is that we see a bit of a highlight when we&rsquo;re looking at the light&rsquo;s direction reflected via the surface.</p><p>The view vector is the one extra variable we need for specular lighting which we can calculate using the viewer&rsquo;s world space position and the fragment&rsquo;s position. Then we calculate the specular&rsquo;s intensity, multiply this with the light color and add this to the ambient and diffuse components.</p><p>We chose to do the lighting calculations in world space, but most people tend to prefer doing lighting in view space. An advantage of view space is that the viewer&rsquo;s position is always at <code>(0,0,0)</code> so you already got the position of the viewer for free. However, I find calculating lighting in world space more intuitive for learning purposes. If you still want to calculate lighting in view space you want to transform all the relevant vectors with the view matrix as well (don&rsquo;t forget to change the normal matrix too).</p><p>To get the world space coordinates of the viewer we simply take the position vector of the camera object (which is the viewer of course). So let&rsquo;s add another uniform to the fragment shader and pass the camera position vector to the shader:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> uniform vec3 viewPos; 
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> lightingShader.setVec3(&#34;viewPos&#34;, camera.Position); 
</span></span></code></pre></td></tr></table></div></div><p>Now that we have all the required variables we can calculate the specular intensity. First we define a specular intensity value to give the specular highlight a medium-bright color so that it doesn&rsquo;t have too much of an impact:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> float specularStrength = 0.5; 
</span></span></code></pre></td></tr></table></div></div><p>If we would set this to <code>1.0f</code> we&rsquo;d get a really bright specular component which is a bit too much for a coral cube. In the
<a href=https://learnopengl.com/Lighting/Materials rel=noopener>next</a> chapter we&rsquo;ll talk about properly setting all these lighting intensities and how they affect the objects. Next we calculate the view direction vector and the corresponding reflect vector along the normal axis:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> vec3 viewDir = normalize(viewPos - FragPos);
</span></span><span class=line><span class=cl>vec3 reflectDir = reflect(-lightDir, norm); 
</span></span></code></pre></td></tr></table></div></div><p>Note that we negate the <code>lightDir</code> vector. The <code>reflect</code> function expects the first vector to point <strong>from</strong> the light source towards the fragment&rsquo;s position, but the <code>lightDir</code> vector is currently pointing the other way around: from the fragment <strong>towards</strong> the light source (this depends on the order of subtraction earlier on when we calculated the <code>lightDir</code> vector). To make sure we get the correct <code>reflect</code> vector we reverse its direction by negating the <code>lightDir</code> vector first. The second argument expects a normal vector so we supply the normalized <code>norm</code> vector.</p><p>Then what&rsquo;s left to do is to actually calculate the specular component. This is accomplished with the following formula:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
</span></span><span class=line><span class=cl>vec3 specular = specularStrength * spec * lightColor; 
</span></span></code></pre></td></tr></table></div></div><p>We first calculate the dot product between the view direction and the reflect direction (and make sure it&rsquo;s not negative) and then raise it to the power of <code>32</code>. This <code>32</code> value is the shininess value of the highlight. The higher the shininess value of an object, the more it properly reflects the light instead of scattering it all around and thus the smaller the highlight becomes. Below you can see an image that shows the visual impact of different shininess values:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_specular_shinines_cb14d8f9efea4fb38.png width=auto alt></p><p>We don&rsquo;t want the specular component to be too distracting so we keep the exponent at <code>32</code>. The only thing left to do is to add it to the ambient and diffuse components and multiply the combined result with the object&rsquo;s color:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> vec3 result = (ambient + diffuse + specular) * objectColor;
</span></span><span class=line><span class=cl>FragColor = vec4(result, 1.0); 
</span></span></code></pre></td></tr></table></div></div><p>We now calculated all the lighting components of the Phong lighting model. Based on your point of view you should see something like this:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_specular_672da1c1ee304726be1745ff05.png width=auto alt></p><p>You can find the complete source code of the application
<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.2.basic_lighting_specular/basic_lighting_specular.cpp" rel=noopener>here</a>.</p><p>In the earlier days of lighting shaders, developers used to implement the Phong lighting model in the vertex shader. The advantage of doing lighting in the vertex shader is that it is a lot more efficient since there are generally a lot less vertices compared to fragments, so the (expensive) lighting calculations are done less frequently. However, the resulting color value in the vertex shader is the resulting lighting color of that vertex only and the color values of the surrounding fragments are then the result of interpolated lighting colors. The result was that the lighting was not very realistic unless large amounts of vertices were used:</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/basic_lighting_gouruad_0a74f14e60e6473a943dacc2cdc.png width=auto alt></p><p>When the Phong lighting model is implemented in the vertex shader it is called Gouraud shading instead of Phong shading. Note that due to the interpolation the lighting looks somewhat off. The Phong shading gives much smoother lighting results.</p><p>By now you should be starting to see just how powerful shaders are. With little information shaders are able to calculate how lighting affects the fragment&rsquo;s colors for all our objects. In the
<a href=https://learnopengl.com/Lighting/Materials rel=noopener>next</a> chapters we&rsquo;ll be delving much deeper into what we can do with the lighting model.</p><a href=#exercises><h2 id=exercises><span class=hanchor arialabel=Anchor># </span>Exercises</h2></a><ul><li>Right now the light source is a boring static light source that doesn&rsquo;t move. Try to move the light source around the scene over time using either sin or cos. Watching the lighting change over time gives you a good understanding of Phong&rsquo;s lighting model:
<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.3.basic_lighting_exercise1/basic_lighting_exercise1.cpp" rel=noopener>solution</a>.</li><li>Play around with different ambient, diffuse and specular strengths and see how they impact the result. Also experiment with the shininess factor. Try to comprehend why certain values have a certain visual output.</li><li>Do Phong shading in view space instead of world space:
<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.4.basic_lighting_exercise2/basic_lighting_exercise2.cpp" rel=noopener>solution</a>.</li><li>Implement Gouraud shading instead of Phong shading. If you did things right the lighting should
<a href=https://learnopengl.com/img/lighting/basic_lighting_exercise3.png rel=noopener>look a bit off</a> (especially the specular highlights) with the cube object. Try to reason why it looks so weird:
<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.5.basic_lighting_exercise3/basic_lighting_exercise3.cpp" rel=noopener>solution</a>.</li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/Master/Graphisme/ data-ctx=Lighting data-src=/Master/Graphisme class=internal-link></a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://deuxfois.github.io/quartz/js/graph.afdb02e537635f9a611b53a988e5645b.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://deuxfois.github.io/quartz/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>