<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Pipeline  
Diagram of the Rendering Pipeline. The blue boxes are programmable shader stages.
The OpenGL rendering pipeline is initiated when you perform a rendering operation."><title>7 Rendering Pipeline Overview</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://deuxfois.github.io/quartz//icon.png><link href=https://deuxfois.github.io/quartz/styles.d8a987f1e2fe9697c22b7adab02c48f3.min.css rel=stylesheet><link href=https://deuxfois.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://deuxfois.github.io/quartz/js/darkmode.69b2c08ae0f08c3a3f86259a122e1f06.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/util.39f53d45cb9520bdaf946bd063598b19.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://deuxfois.github.io/quartz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://deuxfois.github.io/quartz/",fetchData=Promise.all([fetch("https://deuxfois.github.io/quartz/indices/linkIndex.cf5f75478a25b54cf11cd15365cb5ef7.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://deuxfois.github.io/quartz/indices/contentIndex.7bdeb870267d145f6ac57b085313536b.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://deuxfois.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://deuxfois.github.io/quartz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/deuxfois.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://deuxfois.github.io/quartz/js/full-text-search.0ec5fb908204b9e13989f2c640c0870b.min.js></script><div class=singlePage><button onclick=history.back() class=back-button>↩</button><header><h1 id=page-title><a href=https://deuxfois.github.io/quartz/>⛄ DeuxFoi's blog</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>7 Rendering Pipeline Overview</h1><ul class=tags><li><a href=https://deuxfois.github.io/quartz/tags/graphisme/>Graphisme</a></li><li><a href=https://deuxfois.github.io/quartz/tags/s1/>S1</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#pipeline>Pipeline</a></li><li><a href=#a-idvertex_specificationavertex-specification><a id=Vertex_Specification></a>Vertex Specification</a><ol><li><a href=#a-idvertex_renderingavertex-rendering><a id=Vertex_Rendering></a>Vertex Rendering</a></li></ol></li><li><a href=#a-idvertex_processingavertex-processing><a id=Vertex_Processing></a>Vertex Processing</a><ol><li><a href=#a-idvertex_shaderavertex-shader><a id=Vertex_shader></a>Vertex shader</a></li><li><a href=#a-idtessellationatessellation><a id=Tessellation></a>Tessellation</a></li><li><a href=#a-idgeometry_shaderageometry-shader><a id=Geometry_Shader></a>Geometry Shader</a></li></ol></li><li><a href=#a-idvertex_post-processingavertex-post-processing><a id=Vertex_post-processing></a>Vertex post-processing</a><ol><li><a href=#a-idtransform_feedbackatransform-feedback><a id=Transform_Feedback></a>Transform Feedback</a></li><li><a href=#a-idprimitive_assemblyaprimitive-assembly><a id=Primitive_assembly></a>Primitive assembly</a></li><li><a href=#a-idclippingaclipping><a id=Clipping></a>Clipping</a></li><li><a href=#a-idface_cullingaface-culling><a id=Face_culling></a>Face culling</a></li></ol></li><li><a href=#a-idrasterizationarasterization><a id=Rasterization></a>Rasterization</a></li><li><a href=#a-idfragment_processingafragment-processing><a id=Fragment_Processing></a>Fragment Processing</a></li><li><a href=#a-idper-sample_operationsaper-sample-operations><a id=Per-Sample_Operations></a>Per-Sample Operations</a></li></ol></nav></details></aside><a href=#pipeline><h2 id=pipeline><span class=hanchor arialabel=Anchor># </span>Pipeline</h2></a><p><a href=https://www.khronos.org/opengl/wiki/File:RenderingPipeline.png rel=noopener><img src=https://deuxfois.github.io/quartz//../../../_resources/RenderingPipeline_209ab5335c7a46e1ae5945f0f505f8c2.png width=auto alt="Rendering Pipeline Flowchart"></a></p><p>Diagram of the Rendering Pipeline. The blue boxes are programmable shader stages.</p><p>The OpenGL rendering pipeline is initiated when you perform a
<a href=https://www.khronos.org/opengl/wiki/Vertex_Rendering rel=noopener>rendering operation</a>. Rendering operations require the presence of a
<a href=https://www.khronos.org/opengl/wiki/Vertex_Specification rel=noopener>properly-defined vertex array object</a> and a linked
<a href=https://www.khronos.org/opengl/wiki/Program_Object rel=noopener>Program Object</a> or
<a href=https://www.khronos.org/opengl/wiki/Program_Pipeline_Object rel=noopener>Program Pipeline Object</a> which provides the
<a href=https://www.khronos.org/opengl/wiki/Shader rel=noopener>shaders</a> for the programmable pipeline stages.</p><p>Once initiated, the pipeline operates in the following order:</p><ol><li><a href=https://www.khronos.org/opengl/wiki/Vertex_Processing rel=noopener>Vertex Processing</a>:<ol><li>Each vertex retrieved from the vertex arrays (as defined by the VAO) is acted upon by a
<a href=https://www.khronos.org/opengl/wiki/Vertex_Shader rel=noopener>Vertex Shader</a>. Each vertex in the stream is processed in turn into an output vertex.</li><li>Optional primitive
<a href=https://www.khronos.org/opengl/wiki/Tessellation rel=noopener>tessellation stages</a>.</li><li>Optional
<a href=https://www.khronos.org/opengl/wiki/Geometry_Shader rel=noopener>Geometry Shader</a> primitive processing. The output is a sequence of primitives.</li></ol></li><li><a href=https://www.khronos.org/opengl/wiki/Vertex_Post-Processing rel=noopener>Vertex Post-Processing</a>, the outputs of the last stage are adjusted or shipped to different locations.<ol><li><a href=https://www.khronos.org/opengl/wiki/Transform_Feedback rel=noopener>Transform Feedback</a> happens here.</li><li><a href=https://www.khronos.org/opengl/wiki/Primitive_Assembly rel=noopener>Primitive Assembly</a></li><li>Primitive
<a href=https://www.khronos.org/opengl/wiki/Clipping rel=noopener>Clipping</a>, the
<a href=https://www.khronos.org/opengl/wiki/Perspective_Divide rel=noopener>perspective divide</a>, and the
<a href=https://www.khronos.org/opengl/wiki/Viewport_Transform rel=noopener>viewport transform</a> to window space.</li></ol></li><li><a href=https://www.khronos.org/opengl/wiki/Rasterization rel=noopener>Scan conversion and primitive parameter interpolation</a>, which generates a number of
<a href=https://www.khronos.org/opengl/wiki/Fragment rel=noopener>Fragments</a>.</li><li>A
<a href=https://www.khronos.org/opengl/wiki/Fragment_Shader rel=noopener>Fragment Shader</a> processes each fragment. Each fragment generates a number of outputs.</li><li><a href=https://www.khronos.org/opengl/wiki/Per-Sample_Processing rel=noopener>Per-Sample_Processing</a>, including but not limited to:<ol><li><a href=https://www.khronos.org/opengl/wiki/Scissor_Test rel=noopener>Scissor Test</a></li><li><a href=https://www.khronos.org/opengl/wiki/Stencil_Test rel=noopener>Stencil Test</a></li><li><a href=https://www.khronos.org/opengl/wiki/Depth_Test rel=noopener>Depth Test</a></li><li><a href=https://www.khronos.org/opengl/wiki/Blending rel=noopener>Blending</a></li><li><a href=https://www.khronos.org/opengl/wiki/Logical_Operation rel=noopener>Logical Operation</a></li><li><a href=https://www.khronos.org/opengl/wiki/Write_Mask rel=noopener>Write Mask</a></li></ol></li></ol><a href=#a-idvertex_specificationavertex-specification><h2 id=a-idvertex_specificationavertex-specification><span class=hanchor arialabel=Anchor># </span><a id=Vertex_Specification></a>Vertex Specification</h2></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Vertex_Specification rel=noopener>Vertex Specification</a></p><p>The process of vertex specification is where the application sets up an ordered list of vertices to send to the pipeline. These vertices define the boundaries of a <em>primitive</em>.</p><p>Primitives are basic drawing shapes, like triangles, lines, and points. Exactly how the list of vertices is interpreted as primitives is handled via a later stage.</p><p>This part of the pipeline deals with a number of objects like
<a href=https://www.khronos.org/opengl/wiki/Vertex_Array_Objects rel=noopener>Vertex Array Objects</a> and
<a href=https://www.khronos.org/opengl/wiki/Vertex_Buffer_Objects rel=noopener>Vertex Buffer Objects</a>. Vertex Array Objects define what data each vertex has, while Vertex Buffer Objects store the actual vertex data itself.</p><p>A vertex&rsquo;s data is a series of
<a href=https://www.khronos.org/opengl/wiki/Vertex_Attributes rel=noopener>attributes</a>. Each attribute is a small set of data that the next stage will do computations on. While a set of attributes do specify a vertex, there is nothing that says that part of a vertex&rsquo;s attribute set needs to be a position or normal. Attribute data is entirely arbitrary; the only meaning assigned to any of it happens in the vertex processing stage.</p><a href=#a-idvertex_renderingavertex-rendering><h3 id=a-idvertex_renderingavertex-rendering><span class=hanchor arialabel=Anchor># </span><a id=Vertex_Rendering></a>Vertex Rendering</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Vertex_Rendering rel=noopener>Vertex Rendering</a></p><p>Once the vertex data is properly specified, it is then rendered as a
<a href=https://www.khronos.org/opengl/wiki/Primitive rel=noopener>Primitive</a> via a drawing command.</p><a href=#a-idvertex_processingavertex-processing><h2 id=a-idvertex_processingavertex-processing><span class=hanchor arialabel=Anchor># </span><a id=Vertex_Processing></a>Vertex Processing</h2></a><p>Vertices fetched due to the prior vertex rendering stage begin their processing here. The vertex processing stages are almost all
<a href=https://www.khronos.org/opengl/wiki/Shader rel=noopener>programmable operations</a>. This allows user code to customize the way vertices are processed. Each stage represents a different kind of shader operation.</p><p>Many of these stages are optional.</p><a href=#a-idvertex_shaderavertex-shader><h3 id=a-idvertex_shaderavertex-shader><span class=hanchor arialabel=Anchor># </span><a id=Vertex_shader></a>Vertex shader</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Vertex_Shader rel=noopener>Vertex Shader</a></p><p>Vertex shaders perform basic processing of each individual vertex. Vertex shaders receive the attribute inputs from the vertex rendering and converts each incoming vertex into a single outgoing vertex based on an arbitrary,
<a href=https://www.khronos.org/opengl/wiki/Shader rel=noopener>user-defined program</a>.</p><p>Vertex shaders can have user-defined outputs, but there is also a special output that represents the final position of the vertex. If there are no subsequent vertex processing stages, vertex shaders are expected to fill in this position with the clip-space position of the vertex, for rendering purposes.</p><p>One limitation on vertex processing is that each input vertex <em>must</em> map to a specific output vertex. And because
<a href=https://www.khronos.org/opengl/wiki/Shader_Invocation rel=noopener>vertex shader invocations</a> cannot share state between them, the input attributes to output vertex data mapping is 1:1. That is, if you feed the exact same attributes to the same vertex shader in the same primitive, you will get the same output vertex data. This gives implementations the right to optimize vertex processing; if they can detect that they&rsquo;re about to process a previously processed vertex, they can use the previously processed data stored in a
<a href=https://www.khronos.org/opengl/wiki/Post_Transform_Cache rel=noopener>post-transform cache</a>. Thus they do not have to run the vertex processing on that data again.</p><p>Vertex shaders are not optional.</p><a href=#a-idtessellationatessellation><h3 id=a-idtessellationatessellation><span class=hanchor arialabel=Anchor># </span><a id=Tessellation></a>Tessellation</h3></a><p>| | | |
| &mdash; | &mdash; | &mdash; |Tessellation
| Core in version | | 4.6 |
| Core since version | | 4.0 |
| Core ARB extension |
<a href=http://www.opengl.org/registry/specs/ARB/tessellation_shader.txt rel=noopener>ARB_tessellation_shader</a> | |</p><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Tessellation_Shader rel=noopener>Tessellation Shader</a></p><p>Primitives can be tessellated using two shader stages and a fixed-function tessellator between them. The
<a href=https://www.khronos.org/opengl/wiki/Tessellation_Control_Shader rel=noopener>Tessellation Control Shader</a> (TCS) stage comes first, and it determines the amount of tessellation to apply to a primitive, as well as ensuring connectivity between adjacent tessellated primitives. The
<a href=https://www.khronos.org/opengl/wiki/Tessellation_Evaluation_Shader rel=noopener>Tessellation Evaluation Shader</a> (TES) stage comes last, and it applies the interpolation or other operations used to compute user-defined data values for primitives generated by the fixed-function tessellation process.</p><p>Tessellation as a process is optional. Tessellation is considered active if a TES is active. The TCS is optional, but a TCS can only be used alongside a TES.</p><a href=#a-idgeometry_shaderageometry-shader><h3 id=a-idgeometry_shaderageometry-shader><span class=hanchor arialabel=Anchor># </span><a id=Geometry_Shader></a>Geometry Shader</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Geometry_Shader rel=noopener>Geometry Shader</a></p><p>Geometry shaders are user-defined programs that process each incoming primitive, returning zero or more output primitives.</p><p>The input primitives for geometry shaders are the output primitives from a subset of the
<a href=https://www.khronos.org/opengl/wiki/Primitive_Assembly rel=noopener>Primitive Assembly</a> process. So if you send a triangle strip as a single primitive, what the geometry shader will see is a series of triangles.</p><p>However, there are a number of input primitive types that are defined specifically for geometry shaders. These adjacency primitives give GS&rsquo;s a larger view of the primitives; they provide access to vertices of primitives adjacent to the current one.</p><p>The output of a GS is zero or more simple primitives, much like the output of primitive assembly. The GS is able to remove primitives, or tessellate them by outputting many primitives for a single input. The GS can also tinker with the vertex values themselves, either doing some of the work for the vertex shader, or just to interpolate the values when tessellating them. Geometry shaders can even convert primitives to different types; input point primitives can become triangles, or lines can become points.</p><p>Geometry shaders are optional.</p><a href=#a-idvertex_post-processingavertex-post-processing><h2 id=a-idvertex_post-processingavertex-post-processing><span class=hanchor arialabel=Anchor># </span><a id=Vertex_post-processing></a>Vertex post-processing</h2></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Vertex_Post-Processing rel=noopener>Vertex Post-Processing</a></p><p>After the shader-based vertex processing, vertices undergo a number of fixed-function processing steps.</p><a href=#a-idtransform_feedbackatransform-feedback><h3 id=a-idtransform_feedbackatransform-feedback><span class=hanchor arialabel=Anchor># </span><a id=Transform_Feedback></a>Transform Feedback</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Transform_Feedback rel=noopener>Transform Feedback</a></p><p>The outputs of the geometry shader or primitive assembly are written to a series of
<a href=https://www.khronos.org/opengl/wiki/Buffer_Objects rel=noopener>buffer objects</a> that have been setup for this purpose. This is called transform feedback mode; it allows the user to transform data via vertex and geometry shaders, then hold on to that data for use later.</p><p>The data output into the transform feedback buffer is the data from each primitive emitted by this step.</p><a href=#a-idprimitive_assemblyaprimitive-assembly><h3 id=a-idprimitive_assemblyaprimitive-assembly><span class=hanchor arialabel=Anchor># </span><a id=Primitive_assembly></a>Primitive assembly</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Primitive_Assembly rel=noopener>Primitive Assembly</a></p><p>Primitive assembly is the process of collecting a run of vertex data output from the prior stages and composing it into a sequence of primitives. The type of primitive the user rendered with determines how this process works.</p><p>The output of this process is an ordered sequence of simple primitives (lines, points, or triangles). If the input is a triangle strip primitive containing 12 vertices, for example, the output of this process will be 10 triangles.</p><p>If tessellation or geometry shaders are active, then a limited form of primitive assembly is executed before these
<a href=https://www.khronos.org/opengl/wiki/Vertex_Processing rel=noopener>Vertex Processing</a> stages. This is used to feed those particular shader stages with individual primitives, rather than a sequence of vertices.</p><p>The rendering pipeline can also be aborted at this stage. This allows the use of
<a href=https://www.khronos.org/opengl/wiki/Transform_Feedback rel=noopener>Transform Feedback</a> operations, without having to actually render something.</p><a href=#a-idclippingaclipping><h3 id=a-idclippingaclipping><span class=hanchor arialabel=Anchor># </span><a id=Clipping></a>Clipping</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Clipping rel=noopener>Clipping</a></p><p>The primitives are then clipped. Clipping means that primitives that lie on the boundary between the inside of the viewing volume and the outside are split into several primitives, such that the entire primitive lies in the volume. Also, the last
<a href=https://www.khronos.org/opengl/wiki/Vertex_Processing rel=noopener>Vertex Processing</a> shader stage can specify user-defined clipping operations, on a per-vertex basis.</p><p>The vertex positions are transformed from clip-space to window space via the
<a href=https://www.khronos.org/opengl/wiki/Perspective_Divide rel=noopener>Perspective Divide</a> and the
<a href=https://www.khronos.org/opengl/wiki/Viewport_Transform rel=noopener>Viewport Transform</a>.</p><a href=#a-idface_cullingaface-culling><h3 id=a-idface_cullingaface-culling><span class=hanchor arialabel=Anchor># </span><a id=Face_culling></a>Face culling</h3></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Face_Culling rel=noopener>Face Culling</a></p><p>Triangle primitives can be culled (ie: discarded without rendering) based on the triangle&rsquo;s facing in window space. This allows you to avoid rendering triangles facing away from the viewer. For closed surfaces, such triangles would naturally be covered up by triangles facing the user, so there is never any need to render them. Face culling is a way to avoid rendering such primitives.</p><a href=#a-idrasterizationarasterization><h2 id=a-idrasterizationarasterization><span class=hanchor arialabel=Anchor># </span><a id=Rasterization></a>Rasterization</h2></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Rasterization rel=noopener>Rasterization</a></p><p>Primitives that reach this stage are then rasterized in the order in which they were given. The result of rasterizing a primitive is a sequence of <em><a href=https://www.khronos.org/opengl/wiki/Fragment rel=noopener>Fragments</a></em>.</p><p>A fragment is a set of state that is used to compute the final data for a pixel (or sample if
<a href=https://www.khronos.org/opengl/wiki/Multisampling rel=noopener>multisampling</a> is enabled) in the output framebuffer. The state for a fragment includes its position in screen-space, the sample coverage if multisampling is enabled, and a list of arbitrary data that was output from the previous vertex or geometry shader.</p><p>This last set of data is computed by interpolating between the data values in the vertices for the fragment. The style of interpolation is defined by the shader that outputed those values.</p><a href=#a-idfragment_processingafragment-processing><h2 id=a-idfragment_processingafragment-processing><span class=hanchor arialabel=Anchor># </span><a id=Fragment_Processing></a>Fragment Processing</h2></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Fragment_Shader rel=noopener>Fragment Shader</a></p><p>The data for each fragment from the rasterization stage is processed by a fragment shader. The output from a fragment shader is a list of colors for each of the color buffers being written to, a depth value, and a stencil value. Fragment shaders are not able to set the stencil data for a fragment, but they do have control over the color and depth values.</p><p>Fragment shaders are optional. If you render without a fragment shader, the depth (and stencil) values of the fragment get their usual values. But the value of all of the colors that a fragment could have are undefined. Rendering without a fragment shader is useful when rendering only a primitive&rsquo;s default depth information to the depth buffer, such as when performing
<a href=https://www.khronos.org/opengl/wiki/Occlusion_Query rel=noopener>Occlusion Query</a> tests.</p><a href=#a-idper-sample_operationsaper-sample-operations><h2 id=a-idper-sample_operationsaper-sample-operations><span class=hanchor arialabel=Anchor># </span><a id=Per-Sample_Operations></a>Per-Sample Operations</h2></a><p>Main article:
<a href=https://www.khronos.org/opengl/wiki/Per-Sample_Processing rel=noopener>Per-Sample_Processing</a></p><p>The fragment data output from the fragment processor is then passed through a sequence of steps.</p><p>The first step is a sequence of culling tests; if a test is active and the fragment fails the test, the underlying pixels/samples are not updated (usually). Many of these tests are only active if the user activates them. The tests are:</p><ul><li>Pixel ownership test: Fails if the fragment&rsquo;s pixel is not &ldquo;owned&rdquo; by OpenGL (if another window is overlapping with the GL window). Always passes when using a
<a href=https://www.khronos.org/opengl/wiki/Framebuffer_Object rel=noopener>Framebuffer Object</a>. Failure means that the pixel contains undefined values.</li><li><a href=https://www.khronos.org/opengl/wiki/Scissor_Test rel=noopener>Scissor Test</a>: When enabled, the test fails if the fragment&rsquo;s pixel lies outside of a specified rectangle of the screen.</li><li><a href=https://www.khronos.org/opengl/wiki/Stencil_Test rel=noopener>Stencil Test</a>: When enabled, the test fails if the stencil value provided by the test does not compare as the user specifies against the stencil value from the underlying sample in the stencil buffer. Note that the stencil value in the framebuffer can still be modified even if the stencil test fails (and even if the depth test fails).</li><li><a href=https://www.khronos.org/opengl/wiki/Depth_Test rel=noopener>Depth Test</a>: When enabled, the test fails if the fragment&rsquo;s depth does not compare as the user specifies against the depth value from the underlying sample in the depth buffer.</li></ul><p><strong>Note:</strong> Though these are specified to happen after the
<a href=https://www.khronos.org/opengl/wiki/Fragment_Shader rel=noopener>Fragment Shader</a>, they can be made to happen
<a href=https://www.khronos.org/opengl/wiki/Early_Fragment_Test rel=noopener>before the fragment shader</a> under certain conditions. If they happen before the FS, then any culling of the fragment will also prevent the fragment shader from executing, this saving performance.</p><p>After this,
<a href=https://www.khronos.org/opengl/wiki/Blending rel=noopener>color blending</a> happens. For each fragment color value, there is a specific blending operation between it and the color already in the framebuffer at that location.
<a href=https://www.khronos.org/opengl/wiki/Logical_Operation rel=noopener>Logical Operations</a> may also take place in lieu of blending, which perform bitwise operations between the fragment colors and framebuffer colors.</p><p>Lastly, the fragment data is written to the framebuffer.
<a href=https://www.khronos.org/opengl/wiki/Write_Mask rel=noopener>Masking operations</a> allow the user to prevent writes to certain values. Color, depth, and stencil writes can be masked on and off; individual color channels can be masked as well.</p></article><hr><div class=page-end><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://deuxfois.github.io/quartz/js/graph.243ea0d4fc79317e06f846bd698ba136.js></script></div></div><div id=contact_buttons><footer><p>Made by DeuxFois using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://deuxfois.github.io/quartz/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>