<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Les shaders en GLSL Bonjour Ã  tous ! :)
Vous Ãªtes-vous jamais demandÃ© comment Ã©taient faits les superbes effets 3D Ã  la mode comme on en voit dans les jeux vidÃ©os rÃ©cents, comme par exemple lâ€™eau, lâ€™HDR ou lâ€™effet de flou de vitesse dans les jeux de voiture ?"><title>Tutoriel : Les shaders en GLSL</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://deuxfois.github.io/quartz//icon.png><link href=https://deuxfois.github.io/quartz/styles.b54f56dc7e7fdf6be9a4427dc6b0509b.min.css rel=stylesheet><link href=https://deuxfois.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://deuxfois.github.io/quartz/js/darkmode.69b2c08ae0f08c3a3f86259a122e1f06.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/util.39f53d45cb9520bdaf946bd063598b19.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://deuxfois.github.io/quartz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://deuxfois.github.io/quartz/",fetchData=Promise.all([fetch("https://deuxfois.github.io/quartz/indices/linkIndex.3df01290fdc158a4687bc6daff285251.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://deuxfois.github.io/quartz/indices/contentIndex.bebee24aa0a352899c4f4530d9968578.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!1;drawGraph("https://deuxfois.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://deuxfois.github.io/quartz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/deuxfois.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://deuxfois.github.io/quartz/js/full-text-search.0ec5fb908204b9e13989f2c640c0870b.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://deuxfois.github.io/quartz/>ğŸª´ Quartz 3.2</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Tutoriel : Les shaders en GLSL</h1><p class=meta>Last updated
Aug 2, 2022
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/Master/Graphisme/Tutoriel%20_%20Les%20shaders%20en%20GLSL.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://deuxfois.github.io/quartz/tags/graphisme/>Graphisme</a></li><li><a href=https://deuxfois.github.io/quartz/tags/s1/>S1</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#cest-quoi->Câ€™est quoi ?</a></li><li><a href=#la-programmation-gpu>La programmation GPU</a><ol><li><a href=#en-assembleur->En assembleur ?</a></li></ol></li><li><a href=#pourquoi-faire->Pourquoi faire ?</a></li><li><a href=#le-traitement-dun-vertex-et-dun-pixel-cest-quoi->Le traitement dâ€™un vertex et dâ€™un pixel, câ€™est quoi ?</a></li><li><a href=#un-exemple-concret->Un exemple concret ?</a></li><li><a href=#comment-faire->Comment faire ?</a></li><li><a href=#programmer-un-shader-cest-dur->Programmer un shader, câ€™est dur ?</a></li><li><a href=#programmer-un-shader-avec-quel-ide->Programmer un shader, avec quel IDE ?</a></li><li><a href=#programmer-un-shader-avec-quel-compilateur->Programmer un shader, avec quel compilateur ?</a><ol><li><a href=#les-spÃ©cifications-du-langage>Les spÃ©cifications du langage</a></li></ol></li></ol><ol><li><a href=#crÃ©ation-dun-shader>CrÃ©ation dâ€™un shader</a></li><li><a href=#les-extensions-des-shaders>Les extensions des shaders</a></li><li><a href=#crÃ©ation-dun-shader-1>CrÃ©ation dâ€™un shader</a></li><li><a href=#envoi-dun-code-source-Ã -un-shader>Envoi dâ€™un code source Ã  un shader</a></li><li><a href=#charger-un-code-source-Ã -partir-dun-fichier>Charger un code source Ã  partir dâ€™un fichier</a></li><li><a href=#compilation-dun-shader>Compilation dâ€™un shader</a></li><li><a href=#compiler-un-shader>Compiler un shader</a></li><li><a href=#vÃ©rifier-le-succÃ¨s-dune-compilation>VÃ©rifier le succÃ¨s dâ€™une compilation</a></li><li><a href=#rÃ©cupÃ©rer-les-messages-derreur-de-la-compilation>RÃ©cupÃ©rer les messages dâ€™erreur de la compilation</a></li><li><a href=#crÃ©ation-et-utilisation-dun-program>CrÃ©ation et utilisation dâ€™un program</a></li><li><a href=#crÃ©er-un-objet-de-program>CrÃ©er un objet de program</a></li><li><a href=#association-dun-ou-plusieurs-shaders-Ã -un-program>Association dâ€™un ou plusieurs shaders Ã  un program</a></li><li><a href=#liage-dun-program-de-shader>Liage dâ€™un program de shader</a></li><li><a href=#utiliser-un-program-de-shader>Utiliser un program de shader</a></li></ol><ol><li><a href=#les-bases-du-langage>Les bases du langage</a></li><li><a href=#une-forte-ressemblance-avec-le-c>Une forte ressemblance avec le C</a></li><li><a href=#les-variables>Les variables</a></li><li><a href=#les-opÃ©rateurs>Les opÃ©rateurs</a><ol><li><a href=#la-surcharge-des-opÃ©rateurs>La surcharge des opÃ©rateurs</a></li><li><a href=#les-limites-de-la-surcharge>Les limites de la surcharge</a></li></ol></li><li><a href=#le-cast>Le cast</a><ol><li><a href=#initialiser-le-contenu-dun-vecteur>Initialiser le contenu dâ€™un vecteur</a></li><li><a href=#et-les-matrices->Et les matricesâ€¦ ?</a></li></ol></li><li><a href=#les-commentaires>Les commentaires</a></li><li><a href=#les-tableaux>Les tableaux</a><ol><li><a href=#les-tableaux-Ã -deux-dimensions>Les tableaux Ã  deux dimensions</a></li></ol></li></ol><ol><li><a href=#un-vertex-shader--Ã§a-fait-quoi->Un vertex shader : Ã§a fait quoi ?</a></li><li><a href=#quelques-rÃ¨gles-de-programmation>Quelques rÃ¨gles de programmation</a><ol><li><a href=#la-fonction-main>La fonction main</a></li></ol></li><li><a href=#les-variables-dentrÃ©esortie>Les variables dâ€™entrÃ©e/sortie</a><ol><li><a href=#les-variables-dentrÃ©e>Les variables dâ€™entrÃ©e</a></li><li><a href=#les-variables-de-sortie>Les variables de sortie</a></li></ol></li><li><a href=#les-matrices-quelques-variables-dentrÃ©e-supplÃ©mentaires>Les matrices, quelques variables dâ€™entrÃ©e supplÃ©mentaires</a><ol><li><a href=#vous-avez-dit-variable-dentrÃ©e->Vous avez dit â€œvariable dâ€™entrÃ©eâ€ ?</a></li><li><a href=#exercice>Exercice</a></li><li><a href=#correction>Correction</a></li></ol></li><li><a href=#un-pixel-shader>Un pixel shader</a></li><li><a href=#traiter-le-rendu-dun-pixel->Traiter le rendu dâ€™un pixel ?</a><ol><li><a href=#une-limite-en-puissance-assez-restreinte->Une limite en puissance assez restreinte ?</a></li><li><a href=#pourquoi->Pourquoi ?</a></li></ol></li><li><a href=#bon-quest-ce-quon-attend-pour-programmer-Ã§a->Bon, quâ€™est-ce quâ€™on attend pour programmer Ã§a ?</a><ol><li><a href=#le-code-source-de-base>Le code source de base</a></li><li><a href=#les-variables-dentrÃ©e-1>Les variables dâ€™entrÃ©e</a></li><li><a href=#les-variables-de-sortie-1>Les variables de sortie</a></li><li><a href=#programmer-un-simple-pixel-shader>Programmer un simple pixel shader</a></li></ol></li></ol><ol><li><a href=#notions-communes-et-incompatibilitÃ©s-avec-le-c>Notions communes et incompatibilitÃ©s avec le C</a></li><li><a href=#notions-communes>Notions communes</a><ol><li><a href=#les-instructions-ifelse>Les instructions ifâ€¦else</a></li><li><a href=#instructions-break-et-continue>Instructions break et continue</a></li><li><a href=#la-boucle-dowhile>La boucle doâ€¦while</a></li><li><a href=#la-boucle-while>La boucle while</a></li><li><a href=#la-boucle-for>La boucle for</a></li><li><a href=#les-structures>Les structures</a></li><li><a href=#le-prÃ©processeur>Le prÃ©processeur</a></li></ol></li><li><a href=#incompatibilitÃ©s-et-diffÃ©rences>IncompatibilitÃ©s et diffÃ©rences</a><ol><li><a href=#les-dÃ©clarations-de-variables>Les dÃ©clarations de variables</a></li><li><a href=#les-pointeurs-et-linstruction-switch>Les pointeurs et lâ€™instruction switch</a></li></ol></li><li><a href=#crÃ©er-et-surcharger-des-fonctions>CrÃ©er et surcharger des fonctions</a></li><li><a href=#dÃ©clarer-une-simple-fonction>DÃ©clarer une simple fonction</a><ol><li><a href=#paramÃ¨tres-et-valeur-de-retour>ParamÃ¨tres et valeur de retour</a></li></ol></li><li><a href=#la-surcharge-des-fonctions>La surcharge des fonctions</a><ol><li><a href=#notion-de-surcharge>Notion de surcharge</a></li><li><a href=#surcharger-une-fonction>Surcharger une fonction</a></li><li><a href=#exemple-complet>Exemple complet</a></li></ol></li></ol><ol><li><a href=#fonctions-de-manipulation-de-vecteurs>Fonctions de manipulation de vecteurs</a><ol><li><a href=#normalisation-de-vecteurs>Normalisation de vecteurs</a></li><li><a href=#produit-scalaire>Produit scalaire</a></li><li><a href=#produit-vectoriel>Produit vectoriel</a></li><li><a href=#longueur-dun-vecteur>Longueur dâ€™un vecteur</a></li><li><a href=#distance-entre-deux-vecteurs>Distance entre deux vecteurs</a></li></ol></li><li><a href=#la-fonction-ftransform>La fonction <em>ftransform()</em></a></li><li><a href=#encore-quelques-fonctions>Encore quelques fonctions</a><ol><li><a href=#min>min()</a></li><li><a href=#max>max()</a></li><li><a href=#clamp>clamp()</a></li></ol></li><li><a href=#spÃ©cifications-du-glsl>SpÃ©cifications du GLSL</a></li></ol><ol><li><a href=#les-variables-de-type-uniform>Les variables de type uniform</a></li><li><a href=#principe>Principe</a></li></ol><ol><li><a href=#implÃ©mentation-cÃ´tÃ©-api>ImplÃ©mentation cÃ´tÃ© API</a><ol><li><a href=#une-affaire-didentifiants>Une affaire dâ€™identifiants</a></li><li><a href=#rÃ©cupÃ©rer-un-id>RÃ©cupÃ©rer un ID</a></li><li><a href=#assigner-une-valeur>Assigner une valeur</a></li></ol></li><li><a href=#les-diffÃ©rentes-formes-de-gluniform>Les diffÃ©rentes formes de <em>glUniform</em>()*</a><ol><li><a href=#envoi-dune-simple-variable>Envoi dâ€™une simple variable</a></li><li><a href=#envoi-dun-simple-vecteur>Envoi dâ€™un simple vecteur</a></li><li><a href=#Ã©tude-de-la-version-vectorielle-de-gluniform>Ã‰tude de la version vectorielle de glUniform*()</a></li><li><a href=#et-les-matrices--1>Et les matrices ?</a></li></ol></li><li><a href=#les-attributs-de-sommet>Les attributs de sommet</a></li><li><a href=#quest-ce-quun-attribut->Quâ€™est-ce quâ€™un attribut ?</a></li></ol><ol><li><a href=#cÃ´tÃ©-api>CÃ´tÃ© API</a><ol><li><a href=#rÃ©cupÃ©rer-lindex>RÃ©cupÃ©rer lâ€™index</a></li><li><a href=#spÃ©cifier-la-valeur-dun-attribut>SpÃ©cifier la valeur dâ€™un attribut</a></li></ol></li><li><a href=#les-tableaux-dattributs>Les tableaux dâ€™attributs</a></li><li><a href=#activation-des-tableaux-dattributs>Activation des tableaux dâ€™attributs</a></li><li><a href=#envoi-dun-tableau>Envoi dâ€™un tableau</a><ol><li><a href=#et-les-vbos->Et les VBOs ?</a></li></ol></li><li><a href=#dÃ©sactivation-des-tableaux-dattributs>DÃ©sactivation des tableaux dâ€™attributs</a></li><li><a href=#exemple-dutilisation>Exemple dâ€™utilisation</a></li><li><a href=#tÃ©lÃ©chargement>TÃ©lÃ©chargement</a></li><li><a href=#les-vecteurs>Les vecteurs</a></li><li><a href=#les-vecteurs-notions-de-base>Les vecteurs, notions de base</a></li><li><a href=#un-vecteur-cest-quoi->Un vecteur, câ€™est quoi ?</a></li><li><a href=#laddition-de-vecteurs>Lâ€™addition de vecteurs</a><ol><li><a href=#laddition-de-vecteurs-pour-trouver-une-moyenne>Lâ€™addition de vecteurs pour trouver une moyenne</a></li></ol></li><li><a href=#la-soustraction-de-vecteurs>La soustraction de vecteurs</a></li><li><a href=#longueur-et-normalisation>Longueur et normalisation</a></li><li><a href=#une-question-de-longueur>Une question de longueur</a><ol><li><a href=#la-longueur-dun-vecteur-cest-quoi->La longueur dâ€™un vecteur, câ€™est quoi ?</a></li><li><a href=#calculer-la-longueur-dun-vecteur>Calculer la longueur dâ€™un vecteur</a></li></ol></li><li><a href=#la-normalisation>La normalisation</a><ol><li><a href=#reprÃ©sentation-de-la-normalisation>ReprÃ©sentation de la normalisation</a></li><li><a href=#calcul-de-la-normalisation>Calcul de la normalisation</a></li><li><a href=#une-application-pratique>Une application pratique</a></li></ol></li><li><a href=#le-produit-scalaire-dot-product>Le produit scalaire (dot product)</a></li><li><a href=#le-produit-scalaire-comme-calculateur-dangles>Le produit scalaire comme calculateur dâ€™angles</a></li><li><a href=#le-calcul-du-produit-scalaire>Le calcul du produit scalaire</a></li><li><a href=#le-produit-vectoriel-cross-product>Le produit vectoriel (cross product)</a></li><li><a href=#notion-de-normale-dune-face>Notion de â€œnormaleâ€ dâ€™une face</a></li><li><a href=#calcul-du-produit-vectoriel>Calcul du produit vectoriel</a></li></ol></nav></details></aside><a href=#les-shaders-en-glsl><h1 id=les-shaders-en-glsl><span class=hanchor arialabel=Anchor># </span>Les shaders en GLSL</h1></a><p>Bonjour Ã  tous ! :)</p><p>Vous Ãªtes-vous jamais demandÃ© comment Ã©taient faits les superbes effets 3D Ã  la mode comme on en voit dans les jeux vidÃ©os rÃ©cents, comme par exemple lâ€™eau, lâ€™HDR ou lâ€™effet de flou de vitesse dans les jeux de voiture ? Une bonne partie de la rÃ©ponse se trouve dans lâ€™utilisation de
<a href=http://fr.wikipedia.org/wiki/Shader_Model rel=noopener><strong>shaders</strong></a> au sein dâ€™un rendu 3D.</p><p>Vous en avez sans doute dÃ©jÃ  entendu parler (<em>Shader Model 2.0</em>, <em>Shader Model 3.0</em>, â€¦), mais savez-vous vraiment ce quâ€™est un shader ? Savez-vous ce que permet de faire un shader ? Non ? Et bien câ€™est justement ce que je vais essayer de vous apprendre Ã  travers ce tutoriel.</p><p>Ici, je vous apprendrai Ã  programmer dans un langage de programmation de shaders appelÃ© le GLSL. Nous allons tout dâ€™abord voir en quoi cela consiste, comment on sâ€™y prend, et enfin je vous apprendrai Ã  crÃ©er quelques effets graphiques sympathiques :) Allons-y !</p><p>Ce tutoriel nÃ©cessite la lecture du
<a href=http://www.siteduzero.com/tuto-3-5616-0-creez-des-programmes-en-3d-avec-opengl.html rel=noopener>tutoriel sur OpenGL</a> de Kayl,
<a href=http://www.siteduzero.com/tuto-3-23980-1-la-trigonometrie.html rel=noopener>annexe sur la trigonomÃ©trie</a> comprise. Les exemples de code seront Ã©crits en langage C, et la connaissance de ce langage en gÃ©nÃ©ral (ou dâ€™un langage qui lui ressemble syntaxiquement comme le C++ ou le Java) est conseillÃ©e car le GLSL est basÃ© dessus. Je ne vous dÃ©taillerai donc aucune base de la programmation avec GLSL puisquâ€™elles sont quasiment identiques Ã  celles du C (if, else, for, etcâ€¦).</p><a href=#introduction-au-glsl><h1 id=introduction-au-glsl><span class=hanchor arialabel=Anchor># </span>Introduction au GLSL</h1></a><p>Vous vous demandez probablement qui peut bien Ãªtre ce GLSL, et Ã  quoi il peut servir ? o_O</p><p>Je vais, dans ce premier chapitre, essayer de vous expliquer Ã  quoi il peut amener. Nous verrons ce quâ€™il reprÃ©sente exactement et comment il intervient dans un rendu 3D avec OpenGL.</p><p><strong>Que saurais-je faire Ã  la fin de ce tutoriel ?</strong></p><p>Je ne peux pas Ãªtre affirmatif sur ce point, mais je pense pouvoir vous apprendre :</p><ul><li><p>Ã  faire de la lumiÃ¨re. Nous apprendrons Ã  gÃ©rer des lumiÃ¨res avec le GLSL;</p></li><li><p>cel-shading, ou rendu cartoon. Cet effet est trÃ¨s simple Ã  rÃ©aliser, je pense que câ€™est lâ€™un des premiers que nous Ã©tudierons;</p></li><li><p>manipulation de textures. Nous verrons comment dÃ©former simplement nos textures pour donner des effets de distorsion, mais aussi des effets de flou (comme le flou de vitesse de certains jeux de voiture);</p></li><li><p>pseudo-HDR. La gestion de la lumiÃ¨re alliÃ©e Ã  la manipulation des textures nous permettra de rÃ©aliser â€œfacilementâ€ un effet de pseudo-HDR.</p></li></ul><p>Mais avant de voir toutes ces jolies choses, il nous faut tout dâ€™abord connaÃ®tre lâ€™essentiel : quâ€™est-ce que le GLSL, et comment on lâ€™utilise.</p><a href=#cest-quoi-><h2 id=cest-quoi-><span class=hanchor arialabel=Anchor># </span>Câ€™est quoi ?</h2></a><p>A lâ€™origine pensÃ© par
<a href=http://www.pixar.com/ rel=noopener>Pixar</a> pour ses animations vidÃ©os, les shaders ont fait leur apparition dans le domaine du jeu vidÃ©o assez rÃ©cemment et sont aujourdâ€™hui indispensables pour qui veut rÃ©aliser des effets graphiques un tant soit peu Ã©voluÃ©s.</p><p>GLSL (
<a href=http://en.wikipedia.org/wiki/GLSL rel=noopener>Def. GLSL (en)</a>) est lâ€™abrÃ©viation de Open<strong>GL****S</strong>hading <strong>L</strong>anguage, traduisez : langage de programmation de shaders OpenGL. Effectivement, le GLSL est un langage de programmation de shaders.</p><a href=#la-programmation-gpu><h2 id=la-programmation-gpu><span class=hanchor arialabel=Anchor># </span>La programmation GPU</h2></a><p>Le GPU est le processeur de votre carte graphique, câ€™est lui qui calcule vos rendus 3D. La programmation GPU revient donc Ã â€¦ programmer nos calculs de rendus 3D o_O Ah bah tiens, câ€™est la meilleure du siÃ¨cle celle-lÃ  :p</p><p>Les shaders servent Ã  programmer le
<a href="http://jeux.developpez.com/faq/3d/?page=definitions#DEFINITIONS_pipeline" rel=noopener>pipeline</a> de rendu par dÃ©faut de votre carte graphique, appelÃ© le FFP. Les shaders ne sont donc rien de plus que des programmes, donc :</p><ul><li><p>un code source;</p></li><li><p>une compilation;</p></li><li><p>une exÃ©cution.</p></li></ul><p>Ils se diffÃ©rencient toutefois des programmes Ã©crits en C, C++ ou autre langage rÃ©servÃ© Ã  une exÃ©cution CPU, de par leur compilation et leur exÃ©cution. La compilation dâ€™un shader est effectuÃ©e lors du lancement de votre application, et lâ€™exÃ©cution se passe au niveau du GPU, contrairement Ã  vos programmes habituels (C, C++, C#, Java, â€¦) qui eux sont traitÃ©s par le CPU, et câ€™est ce qui fait la puissance et la flexibilitÃ© des shaders dans le rendu 3D en gÃ©nÃ©ral :)</p><a href=#en-assembleur-><h3 id=en-assembleur-><span class=hanchor arialabel=Anchor># </span>En assembleur ?</h3></a><p>Quand on parle de la programmation dâ€™un processeur, on pense gÃ©nÃ©ralement Ã  lâ€™assembleur. Il existe effectivement des langages assembleur pour programmer un GPU, mais nous ne les traiterons pas dans ce tutoriel. Ici, nous ne parlerons que dâ€™un langage de programmation GPU dit de haut niveau, le GLSL. Le GLSL a Ã©tÃ© dÃ©veloppÃ© par lâ€™ARB pour lâ€™API graphique OpenGL afin dâ€™offrir une plus grande souplesse dans la programmation de shaders. DirectX a Ã©galement dÃ©veloppÃ© son propre langage haut niveau pour la programmation de shaders, il sâ€™agit du HLSL, mais il est plutÃ´t hors-sujet, je ne vous en parle quâ€™Ã  titre de comparaison.</p><p>Le GLSL est donc un langage de programmation de shaders de haut niveau, mais Ã  quoi Ã§a ressemble au juste ? Voici le code source dâ€™un shader Ã©crit en GLSL :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_TexCoord[0]Â =Â gl_MultiTexCoord0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_VertexÂ *Â gl_ModelViewMatrix;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Il sâ€™agit lÃ  dâ€™un simple vertex shader.</p><p>Vertex shader ??</p><p>Oui. Il est important de distinguer deux types de shaders diffÃ©rents, remplissant chacun des fonctions bien dÃ©finies et aucunement identiques :</p><ul><li><p>les <strong>vertex shaders</strong> : ce sont des shaders qui interviennent lors du traitement de chaque sommet. Dans les vertex shaders vous pourrez modifier le calcul des diffÃ©rents attributs de vos sommets;</p></li><li><p>les <strong>pixel shaders</strong> : aussi appelÃ©s fragment shaders, ils permettent de traiter le rendu de chaque pixel qui sâ€™affichera Ã  lâ€™Ã©cran. Ces derniers offrent une grande flexibilitÃ© dans le domaine du rendu 3D.</p></li></ul><p>Jâ€™espÃ¨re que vous y voyez Ã  prÃ©sent un peu plus clair ;) Les shaders vous permettent de programmer le traitement de chaque sommet ainsi que de chaque pixel.</p><p>Une nouvelle gÃ©nÃ©ration de shaders vient de faire son apparition avec le nouveau GPU (GeForce8) de nVidia, les <em>geometry shaders</em>. Cette technologie Ã©tant assez nouvelle je nâ€™en parlerai pas. Aussi je nâ€™ai pas les moyens de me procurer ce genre de carte, et beaucoup de gens Ã©tant dans mon cas, lâ€™explication dâ€™une fonctionnalitÃ© que personne ne pourrait exploiter serait plutÃ´t inutile Ã  lâ€™heure actuelle ;)</p><hr><a href=#pourquoi-faire-><h2 id=pourquoi-faire-><span class=hanchor arialabel=Anchor># </span>Pourquoi faire ?</h2></a><p>Les shaders permettent donc de programmer la fonction de traitement dâ€™un vertex ainsi que dâ€™un pixel. Mais Ã  quoi cela rime-t-il ? Quel utilitÃ© cela peut-il bien avoir ?</p><a href=#le-traitement-dun-vertex-et-dun-pixel-cest-quoi-><h2 id=le-traitement-dun-vertex-et-dun-pixel-cest-quoi-><span class=hanchor arialabel=Anchor># </span>Le traitement dâ€™un vertex et dâ€™un pixel, câ€™est quoi ?</h2></a><p>VoilÃ  une bien bonne question :) Quand vous envoyez des donnÃ©es de sommet Ã  OpenGL via les commandes <em>glVertex</em>()<em>, <em>glColor</em>()</em>, <em>glTexCoord</em>()<em>, <em>glNormal</em>()</em>, â€¦ (ou par des tableaux via <em>gl</em>Pointer()* ) OpenGL les stocke et les associe Ã  un ou plusieurs triangles bien dÃ©finis.</p><p>Je rappelle que le triangle est la seule primitive supportÃ©e nativement par toutes les cartes graphiques, les GL_QUADS et autres ne sont que des Ã©mulations via des constructions de plusieurs triangles, dâ€™oÃ¹ leur coÃ»t de traitement plus Ã©levÃ©.</p><p>Le traitement de ce triangle se dÃ©compose par le traitement de ses 3 sommets, puis par une interpolation des donnÃ©es de ses sommets pour obtenir un triangle plein. Ce sont ces deux derniÃ¨res Ã©tapes qui sont traitÃ©es respectivement par le vertex et le pixel shader.</p><p>Le traitement dâ€™un vertex consiste Ã  lui appliquer des transformations matricielle (GL_MODELVIEW, GL_TEXTURE, â€¦) pour obtenir les donnÃ©es des sommets dÃ©finitives qui seront ensuite interpolÃ©es. Le pixel shader reÃ§oit des donnÃ©es interpolÃ©es de couleur et autres attributs traitÃ©s dans le vertex shader.</p><p>Quel est lâ€™intÃ©rÃªt des shaders ?</p><p>Pensez bien quâ€™il y en a un ;) En rÃ©alitÃ©, il y a deux grands avantages Ã  utiliser les shaders. Le premier est quâ€™ils permettent une Ã©norme flexibilitÃ© de rendu. En gÃ©rant le rendu de chaque pixel vous avez un contrÃ´le quasi absolu sur vos rendus 3D et vous pouvez ainsi rÃ©aliser beaucoup dâ€™effets chouettes sans trop vous compliquer la vie. Le second intÃ©rÃªt rÃ©side dans leur principe mÃªme. Ã‰tant exÃ©cutÃ©s par la carte graphique, les shaders ne consomment <strong>pas</strong> de processeur (CPU), ce dernier peut alors souffler un peu et se concentrer sur la gestion de lâ€™IA ou du rÃ©seau par exemple. Dans cette optique de dÃ©charger le processeur, les shaders ont Ã©galement un Ã©norme intÃ©rÃªt si lâ€™on utilise un langage assez â€œgourmandâ€ comme le C# ou le Java, qui sont moins rapides que le C.</p><a href=#un-exemple-concret-><h2 id=un-exemple-concret-><span class=hanchor arialabel=Anchor># </span>Un exemple concret ?</h2></a><p>Mais concrÃ¨tement, quâ€™est-ce quâ€™on peut faire avec des shaders ?</p><p>Il est temps de vous montrer Ã  quoi cela ressemble. Voici deux captures dâ€™Ã©cran de la mÃªme scÃ¨ne, lâ€™une utilisant le FFP standard, lâ€™autre, des shaders.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_640_73c7119f82b84068b.jpg width=auto alt="Image utilisateur"></p><p>Rendu standard</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_640_15af334fbee54bcd9.jpg width=auto alt="Image utilisateur"></p><p>Rendu avec shaders</p><p><em>(source du modÃ¨le 3D et des textures :
<a href=http://mdeverdelhan.developpez.com/tutoriel/dynamiclight/tutoriel6/ rel=noopener>http://mdeverdelhan.developpez.com/tut [â€¦] ht/tutoriel6/</a>)</em></p><p>Les shaders permettent dâ€™ajouter des effets qui peuvent Ãªtre rÃ©alistes, beaux ou encore rigolos, comme le cel-shading (aussi appelÃ© rendu cartoon).</p><p>Hey je veux savoir faire Ã§a !</p><p>Pas de problÃ¨me :) Toutefois soyez prÃ©venus, pour aboutir Ã  un rÃ©sultat tel que vous venez dâ€™en voir, les shaders ne suffisent pas, mais ils constituent une partie importante de la rÃ©alisation dâ€™un tel effet. Et oui, les shaders Ã§a ne fait pas tout, il faudra souvent les associer Ã  des techniques de rendu (rendu offscreen notamment).</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/users.teledisnet.be_web_mde28256_01c6017f34b24ea68.gif width=auto alt="Image utilisateur"></p><p>:â€™(</p><p>Ne pleurez pas, je tÃ¢cherai de vous enseigner ces techniques au fur et Ã  mesure Ã  travers dâ€™autres tutoriels ;) Et puis sachez quâ€™il existe aussi des techniques de rendu qui ne se contentent que des shaders.</p><hr><a href=#comment-faire-><h2 id=comment-faire-><span class=hanchor arialabel=Anchor># </span>Comment faire ?</h2></a><p>MalgrÃ© quelques explications en dÃ©but de chapitre, il est important que vous sachiez avec un peu plus de prÃ©cision comment fonctionne lâ€™implÃ©mentation thÃ©orique des shaders au sein dâ€™un programme OpenGL.</p><a href=#programmer-un-shader-cest-dur-><h2 id=programmer-un-shader-cest-dur-><span class=hanchor arialabel=Anchor># </span>Programmer un shader, câ€™est dur ?</h2></a><p>Pour peu que vous sachiez raisonner logiquement, la programmation dâ€™un shader ne devrait pas vous poser de problÃ¨me ;) Cela nâ€™a en rÃ©alitÃ© rien de sorcier, et si vous maÃ®trisez un temps soit peu la programmation dâ€™un langage procÃ©dural tel que le C, vous vous apercevrez que le GLSL y ressemble beaucoup ;)</p><p>En effet, le GLSL est un langage ressemblant fortement au langage C.</p><p>Cependant, il est important<strong>impÃ©ratif</strong> de distinguer deux choses :</p><ul><li><p>la programmation dâ€™un shader en GLSL;</p></li><li><p>son utilisation au sein dâ€™une application OpenGL.</p></li></ul><p>Ces deux choses sont totalement diffÃ©rentes, il est primordial de bien faire leur distinction. Nous avons dâ€™une part la programmation du shader lui-mÃªme, câ€™est-Ã -dire le codage de la fonction quâ€™il remplira, lâ€™effet graphique quâ€™il produira, dâ€™autre part la dÃ©finition de son utilisation, quand et comment lâ€™utiliser dans notre application.</p><p>Nous pouvons comparer cela Ã  lâ€™utilisation des textures, nous avons dâ€™une part la crÃ©ation de la texture, soit la crÃ©ation de lâ€™image via un logiciel de dessin 2D, et dâ€™autre part le chargement et lâ€™utilisation de cette texture dans notre programme.</p><p>Lâ€™idÃ©e est la mÃªme pour les shaders, nous allons tout dâ€™abord programmer un shader, nous placerons son code source dans un fichier, puis nous programmerons notre application OpenGL et nous chargerons via celle-ci le code source de notre shader afin de lâ€™utiliser Ã  notre convenance au sein de notre programme.</p><a href=#programmer-un-shader-avec-quel-ide-><h2 id=programmer-un-shader-avec-quel-ide-><span class=hanchor arialabel=Anchor># </span>Programmer un shader, avec quel IDE ?</h2></a><p>Il nâ€™existe pas beaucoup dâ€™Ã©diteurs de texte qui colorent le langage GLSL.</p><p>On peut toutefois citer
<a href=http://kate-editor.org/ rel=noopener>Kate</a>, qui bÃ©nÃ©ficie du support de la coloration syntaxique du GLSL, il active automatiquement celle-ci pour tout fichier ayant pour extension .vert pour les vertex shader, ou .frag pour les fragment shader (ou pixel shader).</p><p>Il existe Ã©galement
<a href="http://castano.ludicon.com/page.php?page_id=118" rel=noopener>QShaderEdit</a>, un Ã©diteur qui semble assez pratique ainsi que portable (bien quâ€™il utilise QT), mais que je nâ€™ai jamais testÃ© (merci Ã 
<a href=http://www.siteduzero.com/membres-294-22249.html rel=noopener>XT95</a> pour lâ€™info).</p><a href=#programmer-un-shader-avec-quel-compilateur-><h2 id=programmer-un-shader-avec-quel-compilateur-><span class=hanchor arialabel=Anchor># </span>Programmer un shader, avec quel compilateur ?</h2></a><p>Aucun ! :p</p><p>Vous avez bien lu, il ne vous faut tÃ©lÃ©charger aucun compilateur. Comme je lâ€™ai dÃ©jÃ  dit, les shaders GLSL sont compilÃ©s lors de lâ€™exÃ©cution de votre application, câ€™est OpenGL qui sâ€™en charge ;) Donc rien Ã  faire de particulier ici.</p><p>Vous savez Ã  prÃ©sent qui sont ces fameux shaders, et ce quâ€™ils permettent de rÃ©aliser. Mais vous ne savez pas encore <em>comment</em> le rÃ©aliser. Pour lâ€™instant le plus important est que vous ayez compris leur fonctionnement global, il faut pour cela retenir une chose importante : <strong>les shaders sont des programmes exÃ©cutÃ©s par la carte graphique.</strong></p><p>Ã€ partir de cette bonne base, nous allons Ã©tudier leur fonctionnement plus en profondeur afin de comprendre comment ils marchent rÃ©ellement :)</p><a href=#les-spÃ©cifications-du-langage><h3 id=les-spÃ©cifications-du-langage><span class=hanchor arialabel=Anchor># </span>Les spÃ©cifications du langage</h3></a><p>Pour les adeptes des specs, voici
<a href=http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf rel=noopener>les spÃ©cifications</a> du langage GLSL.</p><hr><a href=#implÃ©mentation-du-glsl-cÃ´tÃ©-api><h1 id=implÃ©mentation-du-glsl-cÃ´tÃ©-api><span class=hanchor arialabel=Anchor># </span>ImplÃ©mentation du GLSL cÃ´tÃ© API</h1></a><p>Vous savez normalement comment fonctionne un shader et quel est son rÃ´le, mais vous ne savez pas encore comment <strong>lâ€™intÃ©grer</strong> dans un programme avec OpenGL. Comment diable va-t-on rÃ©ussir Ã  utiliser une telle chose dans nos programmes OpenGL ? Comment Ã§a marche ? Câ€™est ce que nous allons Ã©tudier dans ce chapitre, nous apprendrons Ã  manier les shaders avec OpenGL.</p><p>Lâ€™implÃ©mentation des shaders se dÃ©compose en plusieurs parties :</p><ul><li><p>premiÃ¨rement, la <strong>crÃ©ation</strong> dâ€™un shader. Nous verrons comment crÃ©er un shader en OpenGL;</p></li><li><p>nous verrons ensuite comment attribuer un contenu Ã  ce shader. Souvenez-vous : un shader est un programme, il possÃ¨de donc un code source. Nous verrons comment <strong>envoyer un code source</strong> Ã  notre shader prÃ©cÃ©demment crÃ©Ã©;</p></li><li><p>une fois le code source spÃ©cifiÃ©, il nous faudra le <strong>compiler</strong>. Il faudra Ã©galement gÃ©rer les erreurs, car comme toute compilation, la compilation dâ€™un shader peut Ã©chouer;</p></li><li><p>notre shader est fin prÃªt, mais il nâ€™est pas encore utilisable. Il nous faudra pour cela crÃ©er un <strong>program</strong>, car celui-ci peut Ãªtre exÃ©cutÃ© directement par la carte graphique.</p></li></ul><p>Ici nous allons uniquement programmer en C avec lâ€™API OpenGL, ne confondez pas ce que nous allons Ã©crire maintenant avec le langage GLSL, celui-ci ne sera Ã©tudiÃ© quâ€™Ã  partir du prochain chapitre.</p><a href=#crÃ©ation-dun-shader><h2 id=crÃ©ation-dun-shader><span class=hanchor arialabel=Anchor># </span>CrÃ©ation dâ€™un shader</h2></a><p>Nous y voilÃ  :)</p><p>Vous vous demandez probablement comment fonctionnent ces tant convoitÃ©s shaders ? En rÃ©alitÃ©, ils ne sont pas difficiles Ã  manier rassurez-vous ;)</p><p>Nous allons voir ici la simple opÃ©ration quâ€™est la crÃ©ation dâ€™un shader, mais avant cela, il est important de savoir si votre implÃ©mentation supporte les shaders GLSL.</p><p>Comment Ã§a ?</p><a href=#les-extensions-des-shaders><h2 id=les-extensions-des-shaders><span class=hanchor arialabel=Anchor># </span>Les extensions des shaders</h2></a><p>Si vous possÃ©dez une ancienne carte graphique, vous risquez de ne pas pouvoir utiliser les shaders ou alors leur utilisation conduirait Ã  une erreur indÃ©terminÃ©e (erreur de segmentation la plupart du temps :-Â° ), il est donc important de tester si lâ€™extension correspondante aux shaders GLSL est disponible.</p><p>Câ€™est quoi les extensions ?</p><p>Je vous invite Ã  lire
<a href=http://www.siteduzero.com/tuto-3-17911-1-opengl-les-extensions.html rel=noopener>mon tutoriel sur les extensions dâ€™OpenGL</a>. Il vous expliquera dans le dÃ©tail ce que sont les extensions, et comment on les utilise.</p><p>Bon OK, et câ€™est quoi le nom de lâ€™extension des shaders GLSL ?</p><p>Il y en a en fait 4 :D</p><p>Voici la liste des noms des extensions nÃ©cessaires Ã  lâ€™utilisation de shaders GLSL dans un programme OpenGL :</p><ul><li><p><strong>GL_ARB_shading_language_100</strong> : support du langage GLSL;</p></li><li><p><strong>GL_ARB_shader_objects</strong> : support des objets de shader (cf plus bas);</p></li><li><p><strong>GL_ARB_vertex_shader</strong> : support des vertex shaders;</p></li><li><p><strong>GL_ARB_fragment_shader</strong> : support des pixel shaders.</p></li></ul><p>Globalement, on peut dire que les shaders GLSL sont supportÃ©s Ã  partir des GeForceFX chez nVidia, et Ã  partir du Radeon 9500 chez ATI.</p><a href=#crÃ©ation-dun-shader-1><h2 id=crÃ©ation-dun-shader-1><span class=hanchor arialabel=Anchor># </span>CrÃ©ation dâ€™un shader</h2></a><p>Vous vous souvenez de ce que je vous ai dit dans lâ€™introduction ? Le maniement des shaders ressemble Ã  celui des textures ;) Et câ€™est quoi une texture ? â€¦ (rÃ©flexion intenseâ€¦) un <strong>GLuint</strong> !</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span></code></pre></td></tr></table></div></div><p>Bon, et bien voilÃ , Ã§a câ€™est faitâ€¦ :-Â°</p><p>Hep hep hep, une minute ! Jâ€™ai rien compris moiâ€¦</p><p>Eh bien un shader est un objet qui ne se manie quâ€™Ã  partir de son identifiant, tout comme les textures. Cependant, les shaders ne se manipulent pas avec les habituelles fonctions glGen*, glIs*, glBind* et compagnie, il va donc falloir que je vous fasse dÃ©couvrir dans un premier temps la fonction qui va venir remplacer glGen*, autrement dit : la fonction qui va crÃ©er un shader et nous renvoyer son identifiant. Il sâ€™agit de la fonction glCreateShader, dont voici le prototype :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint glCreateShader(GLenum type);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>type</strong></em> : attend une constante qui peut Ãªtre GL_VERTEX_SHADER ou GL_FRAGMENT_SHADER. Chacune de ces constantes reprÃ©sente respectivement un shader de sommet et un shader de pixel. Souvenez-vous lors de lâ€™introduction je vous avait dit quâ€™il existait deux types de shader, et bien câ€™est ici que vous allez spÃ©cifier ce type ;)</li></ul><p>Cette fonction renvoie lâ€™identifiant de lâ€™objet de shader crÃ©Ã©.</p><p>Allez, un exemple complet :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span><span class=line><span class=cl>shader = glCreateShader(GL_VERTEX_SHADER);
</span></span></code></pre></td></tr></table></div></div><p>Et voilÃ , nous avons Ã  prÃ©sent un shader de sommet prÃªt Ã  Ãªtre utilisÃ© :)</p><p>Et quand on ne voudra plus lâ€™utiliser ?</p><p>Alors il faudra le supprimer. Voici le prototype de la fonction qui permet de supprimer un shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glDeleteShader(GLuint shader);
</span></span></code></pre></td></tr></table></div></div><p>Nous lâ€™utiliserons comme ceci au sein de notre programme :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* creation */
</span></span><span class=line><span class=cl>shader = glCreateShader(GL_VERTEX_SHADER);
</span></span><span class=line><span class=cl>if(shader == 0)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    /* erreur de creation :( */
</span></span><span class=line><span class=cl>    return;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* utilisation ... */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* suppression */
</span></span><span class=line><span class=cl>glDeleteShader(shader);
</span></span><span class=line><span class=cl>shader = 0;
</span></span></code></pre></td></tr></table></div></div><p>Notez lâ€™ajout de la derniÃ¨re ligne de code, ainsi que de la vÃ©rification de la valeur de lâ€™identifiant. Tout comme tout autre identifiant dâ€™objet OpenGL, 0 nâ€™est pas un identifiant de shader valide. Bien que cela soit rare, il nâ€™est pas impossible quâ€™Ã  priori OpenGL vous renvoie 0, il est donc conseillÃ© de tester la valeur de retour de glCreateShader, mais ce nâ€™est pas obligatoire comme avec malloc.</p><p>Pour finir, je vais vous prÃ©senter une fonction dont la syntaxe devrait vous Ãªtre familiÃ¨re : glIsShader. A lâ€™instar des autres fonctions glIs* dâ€™OpenGL, cette fonction permet de savoir si lâ€™identifiant quâ€™elle reÃ§oit en paramÃ¨tre est un identifiant de shader valide. Voici le prototype de cette fonction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLboolean glIsShader(GLuint shader);
</span></span></code></pre></td></tr></table></div></div><p>Bien, nous avons rÃ©ussi Ã  crÃ©er un shaderâ€¦ mais quelles sont les fonctions permettant de le manipuler afin de lâ€™utiliser Ã  notre guise ? Eh bien suivez-moi, câ€™est par lÃ  :)</p><hr><a href=#envoi-dun-code-source-Ã -un-shader><h2 id=envoi-dun-code-source-Ã -un-shader><span class=hanchor arialabel=Anchor># </span>Envoi dâ€™un code source Ã  un shader</h2></a><p>Nous voici parvenus Ã  la seconde Ã©tape de la crÃ©ation dâ€™un shader fonctionnel.</p><p>Nous allons voir ici comment charger notre code source afin de le donner Ã  manger Ã  OpenGL.</p><p>Comment Ã§a ?</p><p>Je vous lâ€™ai dÃ©jÃ  dit lors de lâ€™introduction, les shaders sont compilÃ©s lors de lâ€™exÃ©cution de votre application, il va donc falloir charger leur code source dynamiquement, Ã  partir dâ€™un fichier par exemple ;)</p><p>Pourquoi un shader doit se compiler Ã  lâ€™exÃ©cution ? Ã‡a doit Ãªtre lent non ?</p><p>Ce nâ€™est pas lent du tout rassurez-vous ;) Sans Ãªtre affirmatif, je pense que les principales raisons Ã  cela sont :</p><ul><li><p>plus simple Ã  gÃ©rer, sâ€™il fallait procÃ©der Ã  la compilation sÃ©parÃ©e des shaders on ne sâ€™en sortirait plus;</p></li><li><p>je pense quâ€™une compilation Ã  lâ€™exÃ©cution permet Ã  OpenGL dâ€™optimiser le shader en fonction du matÃ©riel de la machine qui exÃ©cute le programme OpenGL.</p></li></ul><a href=#charger-un-code-source-Ã -partir-dun-fichier><h2 id=charger-un-code-source-Ã -partir-dun-fichier><span class=hanchor arialabel=Anchor># </span>Charger un code source Ã  partir dâ€™un fichier</h2></a><p>VoilÃ  une Ã©tape des plus enfantines, pour peu que vous sachiez utiliser les fichiers dans le langage que vous utilisez pour faire vos programmes OpenGL.</p><p>Je vais ici vous prÃ©senter un exemple de code en langage C (langage qui est et sera dâ€™ailleurs utilisÃ© pour tous les exemples). Le but est donc dâ€™obtenir un code source, et quâ€™est-ce quâ€™un code source ? Une chaÃ®ne de caractÃ¨res ! Bingo ;) Voyons voirâ€¦ :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char* LoadSource(const char *filename);
</span></span></code></pre></td></tr></table></div></div><p>Ceci pourrait Ãªtre un bon prototype pour une fonction ayant pour but de charger le code source de nos shaders :) Câ€™est une fonction simple et gÃ©nÃ©rique, je lâ€™adopte ! Il faut Ã  prÃ©sent la programmer, rien de trÃ¨s sorcier :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char* LoadSource(const char *filename)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    char *src = NULL;   /* code source de notre shader */
</span></span><span class=line><span class=cl>    FILE *fp = NULL;    /* fichier */
</span></span><span class=line><span class=cl>    long size;          /* taille du fichier */
</span></span><span class=line><span class=cl>    long i;             /* compteur */
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on ouvre le fichier */
</span></span><span class=line><span class=cl>    fp = fopen(filename, &#34;r&#34;);
</span></span><span class=line><span class=cl>    /* on verifie si l&#39;ouverture a echoue */
</span></span><span class=line><span class=cl>    if(fp == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible d&#39;ouvrir le fichier &#39;%s&#39;\n&#34;, filename);
</span></span><span class=line><span class=cl>        return NULL;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on recupere la longueur du fichier */
</span></span><span class=line><span class=cl>    fseek(fp, 0, SEEK_END);
</span></span><span class=line><span class=cl>    size = ftell(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on se replace au debut du fichier */
</span></span><span class=line><span class=cl>    rewind(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on alloue de la memoire pour y placer notre code source */
</span></span><span class=line><span class=cl>    src = malloc(size+1); /* +1 pour le caractere de fin de chaine &#39;\0&#39; */
</span></span><span class=line><span class=cl>    if(src == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fclose(fp);
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;erreur d&#39;allocation de memoire!\n&#34;);
</span></span><span class=line><span class=cl>        return NULL;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* lecture du fichier */
</span></span><span class=line><span class=cl>    for(i=0; i&lt;size; i++)
</span></span><span class=line><span class=cl>        src[i] = fgetc(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on place le dernier caractere a &#39;\0&#39; */
</span></span><span class=line><span class=cl>    src[size] = &#39;\0&#39;;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    fclose(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    return src;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ceci Ã©tant fait, nous devons voir Ã  prÃ©sent comment envoyer notre code source Ã  notre objet <em>shader</em>. Effectivement, OpenGL nous propose de spÃ©cifier le code source de notre shader via un <strong>char</strong>*. Ã‡a tombe bien, nous lâ€™avons celui-ci :p</p><p>Voici la fonction qui permet dâ€™envoyer le code source dâ€™un shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glShaderSource(GLuint shader, GLsizei nombre, const GLchar **sources, const GLint *longueur);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>shader</strong></em> : câ€™est lâ€™identifiant de notre shader, afin que la fonction adresse notre code source Ã  ce shader et pas un autre.</p></li><li><p><em><strong>nombre</strong></em> : câ€™est le nombre de chaÃ®nes contenues dans <em>sources</em>.</p></li><li><p><em><strong>sources</strong></em> : câ€™est notre code source, dÃ©composÃ© en plusieurs chaÃ®nes.</p></li><li><p><em><strong>longueur</strong></em> : un paramÃ¨tre bizarre autant que compliquÃ© :-Â° nous le laisserons Ã  NULL, câ€™est tout Ã  fait autorisÃ© ;)</p></li></ul><p>HÃ© mais cette fonction attend plusieurs chaÃ®nes, mais nous on en a quâ€™une seule !</p><p>Ce fut Ã©galement la rÃ©action que jâ€™ai eu lorsque jâ€™ai vu le prototype de la fonction pour la premiÃ¨re fois :-Â° Jâ€™ai vite compris que Ã§a nâ€™avait aucune importance, nous avons une seule chaÃ®ne, donc nous allons positionner <em>nombre</em> Ã  1 et nous enverrons lâ€™adresse de notre pointeur sur notre code source.</p><p>Un exemple ? Ok :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char *src = LoadSource(...);
</span></span><span class=line><span class=cl>glShaderSource(shader, 1, &amp;src, NULL);
</span></span></code></pre></td></tr></table></div></div><p>VoilÃ , notre shader est Ã  prÃ©sent prÃªt Ã  Ãªtre compilÃ© :)</p><p>Câ€™est quoi lâ€™intÃ©rÃªt dâ€™envoyer un code source Ã  OpenGL si ce nâ€™est pas pour quâ€™il le compile ? Pourquoi ne lâ€™a-t-il pas dÃ©jÃ  compilÃ© ?</p><p>Vous restez ainsi maÃ®tre de votre application et câ€™est rÃ©ellement vous qui choisissez quand il doit se passer telle ou telle chose.</p><p>Notez quâ€™il nâ€™est pas possible de procÃ©der Ã  plusieurs appels de la fonction <em>glShaderSource()</em> afin â€œdâ€™entasserâ€ les codes sources, seul le dernier code envoyÃ© sera pris en compte !</p><p>Bien, passons Ã  prÃ©sent Ã  la compilation. Elle a droit Ã  toute une sous-partie et ce nâ€™est pas pour rien, comme nous allons le voir :p</p><hr><a href=#compilation-dun-shader><h2 id=compilation-dun-shader><span class=hanchor arialabel=Anchor># </span>Compilation dâ€™un shader</h2></a><p>Vous avez sans doute lâ€™habitude de compiler vos programmes en C ou dans un autre langage, et en gÃ©nÃ©ral la procÃ©dure se dÃ©roule ainsi :</p><ul><li><p>vous enregistrez votre code source dans un fichier;</p></li><li><p>vous demandez la compilation de ce code source;</p></li><li><p>vous tombez sur une erreur de compilation :-Â°</p></li></ul><p>Câ€™est la derniÃ¨re Ã©tape la plus intÃ©ressante :D En effet, imaginez que vous ayez fait une faute dans lâ€™Ã©criture du code de votre shader, OpenGL va alors refuser la compilation et gÃ©nÃ©rera une erreur accompagnÃ©e dâ€™un message, vous indiquant oÃ¹ vous vous Ãªtes plantÃ©s :-Â° Il est trÃ¨s important de rÃ©cupÃ©rer les messages dâ€™erreur de compilation des shaders, vous ferez probablement des erreurs parfois en programmant vos shaders, ou bien des fautes de frappe. RÃ©cupÃ©rer une erreur de compilation câ€™est aussi et surtout rÃ©cupÃ©rer une ligne de code, câ€™est grÃ¢ce Ã  elle que vous pourrez localiser votre erreur.</p><p>Nous allons dans un premier temps voir comment compiler un shader, puis nous verrons comment vÃ©rifier le succÃ¨s de cette compilation en rÃ©cupÃ©rant un code dâ€™erreur, en lâ€™analysant, et en agissant en fonction de celui-ci.</p><a href=#compiler-un-shader><h2 id=compiler-un-shader><span class=hanchor arialabel=Anchor># </span>Compiler un shader</h2></a><p>Pour compiler un shader GLSL, rien de compliquÃ©, il existe une fonction dÃ©diÃ©e Ã  cela. La fonction permettant de compiler un shader est glCompileShader, tout simplement. Voici son prototype :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glCompileShader(GLuint shader);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>shader</strong></em> : câ€™est lâ€™identifiant de notre shader Ã  compiler.</li></ul><p>Voici un exemple de code complet, reprenant les exemples prÃ©cÃ©dents (le contenu de la fonction <em>LoadSource()</em> a Ã©tÃ© enlevÃ© afin dâ€™allÃ©ger le code) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span><span class=line><span class=cl>    char *src = NULL;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* creation d&#39;un shader de sommet */
</span></span><span class=line><span class=cl>    shader = glCreateShader(GL_VERTEX_SHADER);
</span></span><span class=line><span class=cl>    if(shader == 0)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible de creer le shader\n&#34;);
</span></span><span class=line><span class=cl>        return -1;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* chargement du code source */
</span></span><span class=line><span class=cl>    src = LoadSource(&#34;test.vert&#34;);
</span></span><span class=line><span class=cl>    if(src == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        /* theoriquement, la fonction LoadSource a deja affiche un message
</span></span><span class=line><span class=cl>           d&#39;erreur, nous nous contenterons de supprimer notre shader
</span></span><span class=line><span class=cl>           et de retourner 0 */
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        glDeleteShader(shader);
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* assignation du code source */
</span></span><span class=line><span class=cl>    glShaderSource(shader, 1, (const GLchar**)&amp;src, NULL);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* compilation du shader */
</span></span><span class=line><span class=cl>    glCompileShader(shader);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* liberation de la memoire du code source */
</span></span><span class=line><span class=cl>    free(src);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* verification du succes de la compilation ... */
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* utilisation ... */
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* suppression */
</span></span><span class=line><span class=cl>    glDeleteShader(shader);
</span></span></code></pre></td></tr></table></div></div><p>Ne pas oublier de libÃ©rer le pointeur src aprÃ¨s la compilation, mÃªme si celle-ci a Ã©chouÃ©, le code source ne nous sera de toute faÃ§on dâ€™aucune utilitÃ©.</p><a href=#vÃ©rifier-le-succÃ¨s-dune-compilation><h2 id=vÃ©rifier-le-succÃ¨s-dune-compilation><span class=hanchor arialabel=Anchor># </span>VÃ©rifier le succÃ¨s dâ€™une compilation</h2></a><p>Comme pour toute compilation, des erreurs sont possibles et leur nature doit Ãªtre connue. Pour cela, il nous faut savoir si il y a eu une erreur, et sâ€™il y en a une, on rÃ©cupÃ¨re le message quâ€™elle contient et on affiche ce dernier Ã  lâ€™Ã©cran.</p><p>Il existe une fonction pour rÃ©cupÃ©rer lâ€™Ã©tat de la compilation. Plus globalement, il sâ€™agit dâ€™une fonction permettant de rÃ©cupÃ©rer un entier relatif Ã  une information spÃ©cifique dâ€™un shader.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetShaderiv(GLuint shader, GLenum type, GLint *result);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>shader</strong></em> : nous placerons ici lâ€™identifiant de notre shader.</p></li><li><p><em><strong>type</strong></em> : il sâ€™agit du type dâ€™Ã©tat demandÃ©. Nous recherchons lâ€™Ã©tat de la compilation du shader, nous placerons donc ici la constante GL_COMPILE_STATUS.</p></li><li><p><em><strong>result</strong></em> : il sâ€™agit dâ€™un pointeur sur un entier dans lequel OpenGL Ã©crira la valeur de lâ€™Ã©tat demandÃ©.</p></li></ul><p>Cette fonction va donc placer dans <em>result</em> la valeur de lâ€™Ã©tat demandÃ©, en lâ€™occurrence, lâ€™Ã©tat de la compilation du shader. Nous allons procÃ©der ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint compile_status = GL_TRUE;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* verification du succes de la compilation */
</span></span><span class=line><span class=cl>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compile_status);
</span></span><span class=line><span class=cl>if(compile_status != GL_TRUE)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    /* erreur a la compilation
</span></span><span class=line><span class=cl>       recuperation du log d&#39;erreur */
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Si <em>compile_status</em> est diffÃ©rent de la constante GL_TRUE, une erreur est survenue et il nous faut donc rÃ©cupÃ©rer le message quâ€™elle contient. Attention, cette procÃ©dure nâ€™est Ã  effectuer que si la compilation a Ã©chouÃ©, sinon elle est inutile et ne ferait que ralentir lâ€™application. Câ€™est pour cela que nous allons Ã  prÃ©sent remplir de quelques lignes de code le bloc de ce <strong>if</strong>.</p><a href=#rÃ©cupÃ©rer-les-messages-derreur-de-la-compilation><h2 id=rÃ©cupÃ©rer-les-messages-derreur-de-la-compilation><span class=hanchor arialabel=Anchor># </span>RÃ©cupÃ©rer les messages dâ€™erreur de la compilation</h2></a><p>Bien, supposons quâ€™une erreur soit intervenue, nous nous trouvons Ã  prÃ©sent dans le bloc du <strong>if</strong> du code prÃ©cÃ©dent, et il nous faut agir.</p><p>Le message dâ€™erreur se trouve sous la forme dâ€™une chaÃ®ne de caractÃ¨res, mais attention, OpenGL nâ€™allouera aucune mÃ©moire pour nous, il va donc falloir lui demander quelle est la taille du message dâ€™erreur, allouer une chaÃ®ne de cette taille puis demander Ã  OpenGL dâ€™Ã©crire le message dâ€™erreur dans notre mÃ©moire fraÃ®chement allouÃ©e.</p><p>Nous allons reprendre notre fonction glGetShaderiv, mais cette fois-ci en lui envoyant comme second paramÃ¨tre (<em>type</em>) la constante GL_INFO_LOG_LENGTH, afin dâ€™obtenir la longueur du message dâ€™erreur :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint logsize;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logsize);
</span></span></code></pre></td></tr></table></div></div><p>A prÃ©sent, il nous faut allouer un espace mÃ©moire de la taille de <em>logsize</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char *log = NULL;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>log = malloc(logsize+1); /* +1 pour le caractere de fin de chaine &#39;\0&#39; */
</span></span><span class=line><span class=cl>if(log == NULL)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    fprintf(stderr, &#34;erreur d&#39;allocation memoire !\n&#34;);
</span></span><span class=line><span class=cl>    return -1; /* ou autre code approprie */
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Et pour finir, nous allons rÃ©cupÃ©rer le message dâ€™erreur en envoyant notre pointeur <em>log</em> Ã  une fonction dâ€™OpenGL appelÃ©e glGetShaderInfoLog. Voici le prototype de cette fonction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetShaderInfoLog(GLuint shader, GLsizei max_size, Glsizei *longueur, char *info_log);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>shader</strong></em> : câ€™est lâ€™identifiant de notre shader.</p></li><li><p><em><strong>max_size</strong></em> : câ€™est le nombre maximal de bytes quâ€™OpenGL Ã©crira dans notre mÃ©moire. OpenGL ne dÃ©passera pas cette valeur.</p></li><li><p><em><strong>longueur</strong></em> : câ€™est la longueur de notre chaÃ®ne. Câ€™est un paramÃ¨tre un peu bizarre je vous lâ€™accorde, nous placerons ici lâ€™adresse de notre variable <em>logsize</em>.</p></li><li><p><em><strong>info_log</strong></em> : câ€™est lâ€™adresse mÃ©moire dans laquelle OpenGL Ã©crira le message dâ€™erreur.</p></li></ul><p>Il ne faudra Ã©videmment pas oublier de libÃ©rer notre mÃ©moire <em>log</em> aprÃ¨s avoir affichÃ© son contenu.</p><p>Voyons Ã  prÃ©sent si vous le voulez bien, un exemple de code complet :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint LoadShader(GLenum type, const char *filename)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    GLuint shader = 0;
</span></span><span class=line><span class=cl>    GLsizei logsize = 0;
</span></span><span class=line><span class=cl>    GLint compile_status = GL_TRUE;
</span></span><span class=line><span class=cl>    char *log = NULL;
</span></span><span class=line><span class=cl>    char *src = NULL;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* creation d&#39;un shader de sommet */
</span></span><span class=line><span class=cl>    shader = glCreateShader(type);
</span></span><span class=line><span class=cl>    if(shader == 0)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible de creer le shader\n&#34;);
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* chargement du code source */
</span></span><span class=line><span class=cl>    src = LoadSource(filename);
</span></span><span class=line><span class=cl>    if(src == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        /* theoriquement, la fonction LoadSource a deja affiche un message
</span></span><span class=line><span class=cl>           d&#39;erreur, nous nous contenterons de supprimer notre shader
</span></span><span class=line><span class=cl>           et de retourner 0 */
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        glDeleteShader(shader);
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* assignation du code source */
</span></span><span class=line><span class=cl>    glShaderSource(shader, 1, (const GLchar**)&amp;src, NULL);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* compilation du shader */
</span></span><span class=line><span class=cl>    glCompileShader(shader);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* liberation de la memoire du code source */
</span></span><span class=line><span class=cl>    free(src);
</span></span><span class=line><span class=cl>    src = NULL;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* verification du succes de la compilation */
</span></span><span class=line><span class=cl>    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compile_status);
</span></span><span class=line><span class=cl>    if(compile_status != GL_TRUE)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        /* erreur a la compilation recuperation du log d&#39;erreur */
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        /* on recupere la taille du message d&#39;erreur */
</span></span><span class=line><span class=cl>        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logsize);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        /* on alloue un espace memoire dans lequel OpenGL ecrira le message */
</span></span><span class=line><span class=cl>        log = malloc(logsize + 1);
</span></span><span class=line><span class=cl>        if(log == NULL)
</span></span><span class=line><span class=cl>        {
</span></span><span class=line><span class=cl>            fprintf(stderr, &#34;impossible d&#39;allouer de la memoire !\n&#34;);
</span></span><span class=line><span class=cl>            return 0;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        /* initialisation du contenu */
</span></span><span class=line><span class=cl>        memset(log, &#39;\0&#39;, logsize + 1);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        glGetShaderInfoLog(shader, logsize, &amp;logsize, log);
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible de compiler le shader &#39;%s&#39; :\n%s&#34;,
</span></span><span class=line><span class=cl>                filename, log);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        /* ne pas oublier de liberer la memoire et notre shader */
</span></span><span class=line><span class=cl>        free(log);
</span></span><span class=line><span class=cl>        glDeleteShader(shader);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    return shader;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Et voilÃ , nous avons une fonction opÃ©rationnelle capable de charger un shader Ã  partir dâ€™un fichier :) La fonction renvoie 0 en cas dâ€™erreur, ou bien lâ€™identifiant du shader crÃ©Ã© si elle a rÃ©ussi.</p><hr><a href=#crÃ©ation-et-utilisation-dun-program><h2 id=crÃ©ation-et-utilisation-dun-program><span class=hanchor arialabel=Anchor># </span>CrÃ©ation et utilisation dâ€™un program</h2></a><p>â€œprogramâ€ ? Câ€™est quoi ce nouveau mot ?</p><p>Câ€™est comme cela que lâ€™on appelle les program de shader en OpenGL. Un peu flou ? :D Nous venons de voir comment crÃ©er un shader, mais ce shader nâ€™est hÃ©las pas exÃ©cutable, la seule chose qui soit exÃ©cutable est un program.</p><p>Un program recueille un ou deux shaders, et il est exÃ©cutable par la carte graphique.</p><a href=#crÃ©er-un-objet-de-program><h2 id=crÃ©er-un-objet-de-program><span class=hanchor arialabel=Anchor># </span>CrÃ©er un objet de program</h2></a><p>Et oui, nous revoilÃ  Ã  nouveau avec des objets OpenGL, eux aussi diffÃ©rents de tous ceux que vous aurez pu manipuler jusquâ€™Ã  maintenant.</p><p>Rassurez-vous toutefois, leur fonctionnement est trÃ¨s simple :) La base des objets OpenGL est dâ€™ailleurs reprise, un objet de program est un GLuint (entier non signÃ©) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint program;
</span></span></code></pre></td></tr></table></div></div><p>La crÃ©ation dâ€™un program est simple, il suffit dâ€™appeler la fonction <em>glCreateProgram()</em> qui ne prend aucun paramÃ¨tre, et retourne simplement lâ€™identifiant du program crÃ©Ã© :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>program = glCreateProgram();
</span></span></code></pre></td></tr></table></div></div><p>Jusque lÃ , pas de difficultÃ© majeure :-Â°</p><p>Idem pour la suppression dâ€™un program, cela se fait en toute simplicitÃ© avec la fonction <em>glDeleteProgram()</em>. Un exemple ? :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glDeleteProgram(program);
</span></span></code></pre></td></tr></table></div></div><p>Pour lâ€™instant, notre program ne fait rien, il va donc falloir lui donner des shaders Ã  exÃ©cuter.</p><a href=#association-dun-ou-plusieurs-shaders-Ã -un-program><h2 id=association-dun-ou-plusieurs-shaders-Ã -un-program><span class=hanchor arialabel=Anchor># </span>Association dâ€™un ou plusieurs shaders Ã  un program</h2></a><p>Oui, vous avez bien lu.</p><p>Comme je lâ€™ai dÃ©jÃ  dit, un program est un recueil de un ou deux shaders. On peut y mettre soit un vertex shader, soit un pixel shader, soit les deux.</p><p>Pour clarifier vos idÃ©es dÃ¨s Ã  prÃ©sent, je vous ai prÃ©parÃ© un petit schÃ©ma :) Voici la procÃ©dure Ã  suivre pour crÃ©er un program exÃ©cutable :</p><ol><li><p>crÃ©er un vertex shader, nous allons lâ€™appeler <em>VS</em>;</p></li><li><p>crÃ©er un pixel shader, nous allons lâ€™appeler <em>PS</em>;</p></li><li><p>crÃ©er un program, nous lâ€™appellerons <em>Program</em>;</p></li><li><p>incorporer (je fais de la cuisine lÃ  :-Â° ) le vertex et le pixel shader dans le program;</p></li><li><p>rendre le program exÃ©cutable en le liant (nous verrons plus bas en quoi cela consiste);</p></li><li><p>le program Ã©tant liÃ©, nous pouvons supprimer nos shaders VS et PS si nous en avons plus besoin;</p></li><li><p>utiliser le program Ã  notre guise :)</p></li><li><p>dÃ©truire les shaders (si ce nâ€™est pas dÃ©jÃ  fait) et le program.</p></li></ol><p>Et voici le schÃ©ma correspondant :) :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_640_f2c7faf9a7d448d09.gif width=auto alt="Image utilisateur"></p><p>Ici, trois notions qui vous sont encore inconnues ont Ã©tÃ© introduites, il sâ€™agit de â€œattachâ€, â€œconstructionâ€ et â€œutilisationâ€. Nous allons sans plus tarder nous intÃ©resser Ã  â€œattachâ€.</p><p>Bon, nous voulons donc associer un ou plusieurs shaders Ã  un program. Il existe pour cela une fonction trÃ¨s simple, <em>glAttachShader()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glAttachShader(GLuint program, GLuint shader);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>program</strong></em> : il sâ€™agit lÃ  du program qui recevra le shader.</p></li><li><p><em><strong>shader</strong></em> : câ€™est le shader Ã  associer Ã  <em>program</em>.</p></li></ul><p>Son utilisation est tellement simple quâ€™on en pleurerait :â€™( Je vous Ã©pargne lâ€™exemple de code pour cette fonction, je pense que Ã§a serait inutile.</p><p>A lâ€™inverse de <em>glAttachShader()</em>, il existe une fonction qui a lâ€™effet contraire. Supposez que vous vouliez mettre Ã  jour un shader, il faudra dâ€™abord que vous le dÃ©tachiez du program auquel il a Ã©tÃ© attachÃ© via <em>glAttachShader()</em>, utilisez pour cela <em>glDetachShader()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glDetachShader(GLuint program, GLuint shader);
</span></span></code></pre></td></tr></table></div></div><p>Je pense quâ€™elle se passe de commentaire ;)</p><p>Bien, nous savons Ã  prÃ©sent comment crÃ©er un program exÃ©cutable, comment lui assigner des shaders, mais nous ne savons toujours pas comment lâ€™utiliser. Toutefois avant de pouvoir utiliser un program, il est important de le rendre opÃ©rationnel en le liant.</p><a href=#liage-dun-program-de-shader><h2 id=liage-dun-program-de-shader><span class=hanchor arialabel=Anchor># </span>Liage dâ€™un program de shader</h2></a><p>Le liage (ou linking) dâ€™un program peut se comparer Ã  la compilation des shaders car il se dÃ©compose Ã©galement en deux Ã©tapes :</p><ul><li><p>le liage en lui mÃªme;</p></li><li><p>la vÃ©rification du succÃ¨s de ce liage.</p></li></ul><p>Oui mais quâ€™est-ce que le liage dâ€™un program ? Et bien en fait lorsquâ€™on lie un program de shader on demande Ã  OpenGL de lier le vertex shader avec le pixel shader. Cette liaison peut Ã©chouer dans la mesure oÃ¹ les deux shaders peuvent Ãªtre incompatibles entre eux.</p><p>Nous verrons dans une autre partie de ce tutoriel en quoi consiste rÃ©ellement le linking et ce quâ€™il apporte.</p><p>Bien, passons Ã  prÃ©sent au vif du sujet : nous voulons lier un program de shaders. Pour ce faire, il existe une simple fonction appelÃ©e <em>glLinkProgram()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glLinkProgram(GLuint program);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>program</strong></em> : câ€™est le program que lâ€™on souhaite lier.</li></ul><p>Comme je lâ€™ai dit plus haut, lâ€™Ã©tape suivante consiste Ã  vÃ©rifier que le liage a bien fonctionnÃ©. La mÃ©thode employÃ©e est trÃ¨s similaire Ã  celle des shaders :</p><ul><li><p>on vÃ©rifie si une erreur est prÃ©sente;</p></li><li><p>sâ€™il y en a une, on rÃ©cupÃ¨re la taille de la chaÃ®ne contenant le message dâ€™erreur;</p></li><li><p>on alloue un espace mÃ©moire de cette taille;</p></li><li><p>on indique lâ€™adresse de cette mÃ©moire Ã  OpenGL pour quâ€™il puisse y Ã©crire le message dâ€™erreur.</p></li></ul><p>Voici la fonction permettant (entre autres) de savoir si une erreur a Ã©tÃ© levÃ©e :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetProgramiv(GLuint program, GLenum type, GLint *result);
</span></span></code></pre></td></tr></table></div></div><p>Son fonctionnement est identique Ã  glGetShaderiv pour les shaders, je vais donc passer les descriptions minutieuses. Tout ce que vous devez savoir ici, câ€™est la constante Ã  passer Ã  <em>type</em> pour obtenir ce que lâ€™on cherche. Nous cherchons lâ€™Ã©tat du prÃ©cÃ©dent liage du program, pour cela nous allons passer la constante GL_LINK_STATUS. La vÃ©rification de la valeur de <em>result</em> fonctionne de la mÃªme faÃ§on que pour les shaders, si elle est diffÃ©rente de GL_TRUE, alors une erreur a Ã©tÃ© levÃ©e.</p><p>Etape suivante, nous voulons rÃ©cupÃ©rer la longueur du message dâ€™erreur, nous allons utiliser pour cela glGetProgramiv avec comme paramÃ¨tre <em>type</em> la constante GL_INFO_LOG_LENGTH (comme pour les shaders).</p><p>Enfin, pour rÃ©cupÃ©rer le message dâ€™erreur, nous avons Ã  notre disposition la fonction glGetProgramInfoLog :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetProgramInfoLog(GLuint program, GLsizei max_size, GLsizei *longueur, char *log);
</span></span></code></pre></td></tr></table></div></div><p>Son fonctionnement est lui aussi identique Ã  la fonction glGetShaderInfoLog pour les shaders.</p><p>Un exemple de code complet sera disponible Ã  la fin du chapitre.</p><a href=#utiliser-un-program-de-shader><h2 id=utiliser-un-program-de-shader><span class=hanchor arialabel=Anchor># </span>Utiliser un program de shader</h2></a><p>Ah ! Nous voici arrivÃ©s Ã  la partie la plus intÃ©ressante :)</p><p>RÃ©sumons une fois de plus si vous le voulez bien :</p><ul><li><p>nous savons crÃ©er un shader;</p></li><li><p>nous savons crÃ©er un program exÃ©cutable;</p></li><li><p>nous savons attribuer Ã  ce program des shaders Ã  exÃ©cuter;</p></li><li><p>nous ne savons pas comment rendre ce program actif :-Â°</p></li></ul><p>Utiliser un program, câ€™est le rendre actif pour tous les prochains rendus jusquâ€™Ã  ce que lâ€™on demande explicitement lâ€™arrÃªt de lâ€™utilisation dâ€™un quelconque program de shader, ou jusquâ€™Ã  ce que lâ€™on active un autre program de shader.</p><p>Comme toujours, je vais reprendre mon exemple sur la similitude avec les textures. Vous savez certainement comment on rend une texture active ?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBindTexture(GL_TEXTURE_2D, tex_id);
</span></span></code></pre></td></tr></table></div></div><p>Ce code rend la texture <em>tex_id</em> active pour tous les prochains rendus jusquâ€™Ã  ce quâ€™un appel de glBindTexture avec un identifiant de 0 soit effectuÃ© :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* desactive la precedente texture active */
</span></span><span class=line><span class=cl>glBindTexture(GL_TEXTURE_2D, 0);
</span></span></code></pre></td></tr></table></div></div><p>Vous noterez que pour les textures, lâ€™emploi de glDisable(GL_TEXTURE_2D) est prÃ©fÃ©rable, mais pour utiliser un program de shader, aucun Ã©tat OpenGL nâ€™est Ã  activer.</p><p>Bien, il est temps de vous prÃ©senter la fonction qui permet de rendre un program actif pour le rendu :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUseProgram(GLuint program);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>program</strong></em> : il sâ€™agit lÃ  de lâ€™identifiant du program que lâ€™on souhaite activer, si cet identifiant est de 0, OpenGL dÃ©sactivera lâ€™utilisation des programs de shaders.</li></ul><p>Allez, un exemple pour le fun :-Â° :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* super rendus avec des effets de la mort qui tue */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* desactive l&#39;utilisation des shaders, OpenGL retourne en mode normal (passe par le FFP) */
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span></code></pre></td></tr></table></div></div><p>Tout comme les textures, vous pouvez charger plusieurs shaders en dÃ©but de programme et ensuite les utiliser simultanÃ©ment, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glUseProgram(prog1);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* rendus utilisant le program prog1 */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(prog2);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* rendus utilisant le program prog2 */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(prog3);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* rendus utilisant le program prog3 */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* fin des rendus utilisant les shaders */
</span></span></code></pre></td></tr></table></div></div><p>Attention toutefois, comme avec les textures, il est impossible dâ€™utiliser deux programs Ã  la fois. Ici, le second appel Ã  glUseProgram dÃ©fini prog2 comme Ã©tant actif <strong>Ã  la place</strong> de prog1.</p><hr><a href=#un-exemple-complet><h1 id=un-exemple-complet><span class=hanchor arialabel=Anchor># </span>Un exemple complet</h1></a><p>VoilÃ , je crois que nous avons abordÃ© toutes les facettes de la gestion des shaders GLSL du cÃ´tÃ© de lâ€™API :) Bien sÃ»r, il reste encore quelques dÃ©tails, mais je vous les ferai connaÃ®tre plus tard, pour lâ€™instant ils ne feraient que vous embrouiller croyez-moi ;)</p><p>Afin que vous vous fassiez une meilleure idÃ©e de la faÃ§on dont tout ce bazar sâ€™assemble, je vous ai prÃ©parÃ© un programme complet chargeant un simple vertex shader qui a pour effet de transformer lâ€™image affichÃ©e en couleurs nÃ©gatives. Pour activer le shader, vous devez appuyer sur une touche du clavier.</p><p><a href=http://yno.goldzoneweb.info/sdz/ch2.zip rel=noopener>TÃ©lÃ©charger lâ€™exemple de code et le Makefile Unix</a></p><p>Jâ€™utilise
<a href=http://glew.sourceforge.net/ rel=noopener>Glew</a> pour charger les extensions dâ€™OpenGL, vous devez le possÃ©der si vous voulez pouvoir compiler/recompiler le code source. Lâ€™exÃ©cutable fourni utilise la glibc2.4</p><p>Que les utilisateurs de MacOS et Windows mâ€™excusent, je nâ€™utilise pas ces OS et par consÃ©quent je nâ€™ai pas pu vous mijoter quelque chose, il va falloir que vous vous dÃ©brouilliez pour compiler les sources :euh: Toutefois je vous recommande fortement de tÃ©lÃ©charger ces sources pour les Ã©tudier afin de bien comprendre comment fonctionne le chargement et lâ€™utilisation des shaders. Nâ€™hÃ©sitez pas Ã  relire les parties du chapitre que vous nâ€™avez pas comprises, avec lâ€™exemple de code sous les yeux afin de bien faire la relation entre ce que jâ€™explique et la mise en pratique ;)</p><p>Un peu Ã  lâ€™instar de Kayl avec son sdlglutils, je vous propose de tÃ©lÃ©charger cet ensemble de deux fichiers qui proposent quelques fonctions bien pratiques pour charger un shader simplement sans trop se fatiguer :</p><p><a href=http://yno.goldzoneweb.info/sdz/loadprogram.zip rel=noopener>TÃ©lÃ©charger loadprogram.zip</a></p><p>Ce sont en rÃ©alitÃ© les fonctions que nous avons construites ensembles, avec quelques petits ajouts toutefois ;) DorÃ©navant jâ€™utiliserai ces fonctions pour le chargement des shaders afin dâ€™allÃ©ger les exemples de code.</p><p>Ces deux exemples de code sont distribuÃ©s sous licence GPL ;)</p><p>Ouf, nous voici enfin arrivÃ©s au terme de ce long chapitre ! :)</p><p>Vous savez Ã  prÃ©sent comment utiliser les shaders dans vos programmes OpenGL, les activer, les dÃ©sactiver, etcâ€¦ Mais (parce quâ€™il y a un mais :-Â° ), vous ne savez pas programmer un shader.</p><p>Et dâ€™ailleurs, Ã§a vous dirait de savoir les programmer, ces fameux shaders ? Oui ? Pas de problÃ¨me, câ€™est par ici :)</p><hr><a href=#les-bases-du-langage><h2 id=les-bases-du-langage><span class=hanchor arialabel=Anchor># </span>Les bases du langage</h2></a><p>Nous y voilÃ  enfin, nous allons ici commencer Ã  apprendre le langage GLSL qui est un langage de programmation de shaders conÃ§u pour OpenGL.</p><p>Nous Ã©tudierons dâ€™abord les bases du langage :</p><ul><li><p>les variables et leur types ;</p></li><li><p>la surcharge des opÃ©rateurs ;</p></li><li><p>le cast (trÃ¨s important et trÃ¨s employÃ© en GLSL).</p></li></ul><p>Nous programmerons ensuite de simples vertex et pixel shaders, afin de voir comment ils fonctionnent :) Vous verrez quâ€™ils utilisent tout deux des variables dâ€™entrÃ©e et des variables de sortie, qui nous permettent de recevoir et de renvoyer des donnÃ©es. Les donnÃ©es reÃ§ues seront traitÃ©es par les instructions contenues dans le code source du shader, pour obtenir un rÃ©sultat qui sera ensuite renvoyÃ©. Ces rÃ©sultats reprÃ©sentent gÃ©nÃ©ralement des informations de <strong>position Ã  lâ€™Ã©cran</strong> pour les vertex shaders, et de <strong>couleur</strong> pour les pixel shaders.</p><a href=#une-forte-ressemblance-avec-le-c><h2 id=une-forte-ressemblance-avec-le-c><span class=hanchor arialabel=Anchor># </span>Une forte ressemblance avec le C</h2></a><p>Le langage GLSL a beaucoup de points communs avec le langage C. Syntaxiquement, les deux langages sont quasiment identiques.</p><a href=#les-variables><h2 id=les-variables><span class=hanchor arialabel=Anchor># </span>Les variables</h2></a><p>Tout comme en C, il est possible de crÃ©er des variables en GLSL. Il existe une multitude de types de variables, chacun ayant une utilitÃ© bien prÃ©cise. Par exemple, si vous souhaitez crÃ©er une variable capable de stocker des nombres flottants, faites ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ variable;
</span></span></code></pre></td></tr></table></div></div><p>Et oui, comme en C :) Notez Ã©galement la prÃ©sence dâ€™un point-virgule, qui se place aux mÃªmes endroits quâ€™en C. La crÃ©ation de deux variables Ã  la fois est Ã©galement autorisÃ©e, avec lâ€™ajout dâ€™une virgule entre les deux noms de variable :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ a,Â b;
</span></span></code></pre></td></tr></table></div></div><p>Les variables prÃ©fixÃ©es <strong>gl_</strong> sont rÃ©servÃ©es au langage lui-mÃªme, il est donc interdit de crÃ©er une variable dont le nom commence par gl_ !</p><p>Il est possible de crÃ©er des variables des types suivants :</p><ul><li><p><strong>int</strong> : entier ;</p></li><li><p><strong>float</strong> : flottant ;</p></li><li><p><strong>bool</strong> : boolÃ©en, peut valoir <strong>true</strong> ou <strong>false</strong> ;</p></li><li><p><strong>vec2</strong> : vecteur Ã  2 composantes flottantes ;</p></li><li><p><strong>vec3</strong> : vecteur Ã  3 composantes flottantes ;</p></li><li><p><strong>vec4</strong> : vecteur Ã  4 composantes flottantes ;</p></li><li><p><strong>mat2</strong> : matrice 2 * 2 de flottants ;</p></li><li><p><strong>mat3</strong> : matrice 3 * 3 de flottants ;</p></li><li><p><strong>mat4</strong> : matrice 4 * 4 de flottants ;</p></li><li><p><strong>ivec2</strong> : vecteur Ã  2 composantes entiÃ¨res ;</p></li><li><p><strong>ivec3</strong> : vecteur Ã  3 composantes entiÃ¨res ;</p></li><li><p><strong>ivec4</strong> : vecteur Ã  4 composantes entiÃ¨res ;</p></li><li><p><strong>bvec2</strong> : vecteur Ã  2 composantes boolÃ©ennes ;</p></li><li><p><strong>bvec3</strong> : vecteur Ã  3 composantes boolÃ©ennes ;</p></li><li><p><strong>bvec4</strong> : vecteur Ã  4 composantes boolÃ©ennes.</p></li></ul><p>Soudainement, les ressemblances avec le C sâ€™arrÃªtent :-Â° Effectivement, le GLSL possÃ¨de beaucoup de types de variablesâ€¦ qui ne sont finalement plus des variables mais des ensembles de variables. Nous pouvons toutefois les comparer Ã  des structures, et nous allons voir pourquoi. Lorsque vous crÃ©ez un vecteur Ã  3 composantes par exemple (<strong>vec3</strong>), GLSL vous permet dâ€™accÃ©der Ã  une seule de ses composante de cette faÃ§on :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â direction;
</span></span><span class=line><span class=cl>direction.xÂ =Â 0.2;
</span></span></code></pre></td></tr></table></div></div><p>La seconde instruction place la valeur 0.2 dans la composante X du vecteur <em>direction</em> grÃ¢ce Ã  lâ€™opÃ©rateur dâ€™affectation =, qui fonctionne de la mÃªme faÃ§on quâ€™en Câ€¦ ou presque.</p><a href=#les-opÃ©rateurs><h2 id=les-opÃ©rateurs><span class=hanchor arialabel=Anchor># </span>Les opÃ©rateurs</h2></a><p>Il est bien sÃ»r possible de multiplier une variable par une autre, ou bien encore de soustraire une valeur Ã  une variable. Les opÃ©rateurs en GLSL sâ€™utilisent comme en C, voici un exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ var1Â =Â 0.2,Â var2Â =Â 3.0;
</span></span><span class=line><span class=cl>floatÂ resultatÂ =Â (var1Â -Â 0.1)Â *Â var2;
</span></span></code></pre></td></tr></table></div></div><p>Ici, <em>resultat</em> vaudra (0.2 - 0.1) * 3.0 soit 0.3.</p><p>Et si je vous apprenais quâ€™on peut multiplier un vecteur par un vecteur, vous me rÃ©pondriez quoi ?</p><a href=#la-surcharge-des-opÃ©rateurs><h3 id=la-surcharge-des-opÃ©rateurs><span class=hanchor arialabel=Anchor># </span>La surcharge des opÃ©rateurs</h3></a><p>Premier point commun avec le langage C++ : les opÃ©rateurs en GLSL sont surchargÃ©s.</p><p>Euh, et Ã§a veut dire quoi ?</p><p>Je ne vais pas vous faire une description avancÃ©e de ce quâ€™est la surcharge des opÃ©rateurs, mais pour vous expliquer en deux mots, Ã§a veut dire quâ€™on peut additionner, soustraire, multiplier et diviser tous les types de variable par tous les types de variable !</p><p>Jâ€™y comprend rien o_O</p><p>Vous connaissez probablement la multiplication matricielle ? Et bien effectuer ce genre de multiplication en GLSL est un jeu dâ€™enfant :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mat4Â aÂ =Â ...,Â bÂ =Â ...;
</span></span><span class=line><span class=cl>mat4Â resultatÂ =Â aÂ *Â b;
</span></span></code></pre></td></tr></table></div></div><p><em>resultat</em> vaut maintenant le rÃ©sultat de la multiplication matricielle de <em>a</em> par <em>b</em>. Et Ã§a marche aussi pour les vecteurs ! :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec4Â positionÂ =Â ...;
</span></span><span class=line><span class=cl>mat4Â mÂ =Â ...;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>vec4Â resultatÂ =Â mÂ *Â position;
</span></span></code></pre></td></tr></table></div></div><p><em>resultat</em> vaut Ã  prÃ©sent la position que reprÃ©sente le vecteur <em>position</em> transformÃ© par la matrice <em>m</em>.</p><p>Notez quâ€™ici lâ€™ordre de la multiplication est important ! Câ€™est dâ€™abord la matrice, puis le vecteur. Si cela vous semble flou, nâ€™hÃ©sitez pas Ã  aller lire
<a href=http://www.siteduzero.com/tuto-3-23978-1-les-matrices.html rel=noopener>le tutoriel de Kayl sur les matrices</a>.</p><p>Allez, encore un exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â vecteurÂ =Â ...;
</span></span><span class=line><span class=cl>vecteurÂ *=Â 2.0;
</span></span></code></pre></td></tr></table></div></div><p>La seconde ligne de ce code a pour effet de multiplier chaque composante du vecteur <em>vecteur</em> par 2.</p><a href=#les-limites-de-la-surcharge><h3 id=les-limites-de-la-surcharge><span class=hanchor arialabel=Anchor># </span>Les limites de la surcharge</h3></a><p>HÃ© oui malheureusement cette surcharge a des limites, on ne peut pas rÃ©ellement tout faire comme je lâ€™ai dit avant, il existe des exceptions. Ces exceptions sont toutefois logiques et nâ€™ont rien de mystÃ©rieux comme nous allons le voir. Par exemple, il est impossible de multiplier une matrice 3*3 par une matrice 4*4, si vous vous y risquez, OpenGL lÃ¨vera une erreur lors de la compilation de votre shader. Autre cas typique : les vecteurs, il est impossible dâ€™effectuer une quelconque opÃ©ration entre deux vecteurs de type diffÃ©rents. Enfin, il est Ã©galement impossible de multiplier un vecteur Ã  2 composantes (<strong>vec2</strong>) par une matrice autre quâ€™une 2*2 (<strong>mat2</strong>), et il en va de mÃªme pour tous les autres types, <strong>vec3</strong> avec <strong>mat3</strong> et <strong>vec4</strong> avec <strong>mat4</strong>.</p><p>Maintenant que je vous ai exposÃ© pleins dâ€™inconvÃ©nients dÃ»s Ã  la surcharge, je vais vous proposer des une solution :)</p><a href=#le-cast><h2 id=le-cast><span class=hanchor arialabel=Anchor># </span>Le cast</h2></a><p>Tout comme en C, il est possible de forcer la conversion dâ€™un type vers un autre. Ici, la syntaxe est diffÃ©rente que celle du C oÃ¹ lâ€™on fait comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float flottant = (float)entier;
</span></span></code></pre></td></tr></table></div></div><p>En GLSL, le cast dâ€™une variable se fait ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ flottantÂ =Â float(entier);
</span></span></code></pre></td></tr></table></div></div><p>La conversion explicite de int vers float ou de float vers int nâ€™est pas obligatoire, en revanche, si vous souhaitez convertir un <strong>vec3</strong> en <strong>vec2</strong>, lÃ  il va falloir le demander explicitement.</p><p>Comment on peut convertir un vecteur Ã  trois dimensions en un vecteur Ã  deux dimensions ?</p><p>Je ne vais rien vous cacher, et une conversion de ce type amÃ¨ne forcÃ©ment Ã  une perte de donnÃ©e(s), nous allons uniquement conserver dans le vecteur Ã  2 dimensions deux composantes du vecteur Ã  3 dimensions. Mais avec le cast, câ€™est vous qui allez choisir quelles donnÃ©es vous souhaiterez supprimer et quelles donnÃ©es vous souhaiterez garder. (par donnÃ©e je sous-entend <em>composante</em> dâ€™un vecteur)</p><p>Ã‰tant donnÃ© quâ€™il existe un trop grand nombre de conversions possible (chaque type peut Ãªtre converti en chaque type), je ne vais pas vous faire une dÃ©monstration pour chacune dâ€™entre elles, je vais juste vous fournir la technique Ã  utiliser, elle est logique et fonctionne de la mÃªme faÃ§on (ou presque) pour tous les types de conversion.</p><p>Nous allons prendre lâ€™exemple de la conversion dâ€™un <strong>vec3</strong> vers un <strong>vec2</strong>, puis nous prendrons ensuite lâ€™exemple inverse, Ã  savoir <strong>vec2</strong> -> <strong>vec3</strong>.</p><p>Pour convertir un vec3 en vec2, une mÃ©thode simple existe :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â vÂ =Â ...;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>vec2Â v2Â =Â vec2(v);
</span></span></code></pre></td></tr></table></div></div><p>Ce code est simple et pourrait se traduire de la faÃ§on suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â vÂ =Â ...;
</span></span><span class=line><span class=cl>vec2Â v2;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>v2.xÂ =Â v.x;
</span></span><span class=line><span class=cl>v2.yÂ =Â v.y;
</span></span></code></pre></td></tr></table></div></div><p>En rÃ©alitÃ©, le cast du premier code prend les <em>n</em> premiÃ¨res composantes de la variable Ã  caster et les places dans la variable finale, oÃ¹ <em>n</em> reprÃ©sente le nombre maximal de variables stockables dans le type de la variable finale, dans notre exemple, <em>n</em> vaut 2.</p><p>Vous pouvez Ã©galement prendre dâ€™autres composantes de <em>v</em> pour les placer dans <em>v2</em> sans avoir Ã  spÃ©cifier manuellement les composantes de <em>v</em> qui recevrons la valeur. Lâ€™instruction suivante place les composantes de <em>v</em> demandÃ©es et les places respectivement dans <em>v2.x</em> et <em>v2.y</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â v2Â =Â vec2(v.z,Â v.x);
</span></span></code></pre></td></tr></table></div></div><p>Voyons Ã  prÃ©sent comment convertir un <strong>vec2</strong> en <strong>vec3</strong>, nous verrons cette voici quâ€™Ã  lâ€™inverse dâ€™une conversion <strong>vec3</strong> -> <strong>vec2</strong>, il y a un manque de donnÃ©es. Ã€ priori, on pourrait se dire quâ€™une conversion comme ceci est correct :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â v2Â =Â ...;
</span></span><span class=line><span class=cl>vec3Â v3Â =Â vec3(v2);
</span></span></code></pre></td></tr></table></div></div><p>Maisâ€¦</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>impossibleÂ deÂ compilerÂ leÂ shaderÂ &#39;test.vert&#39;Â :
</span></span><span class=line><span class=cl>(5)Â :Â errorÂ C1033:Â castÂ notÂ allowed
</span></span><span class=line><span class=cl>(5)Â :Â errorÂ C1056:Â invalidÂ initialization
</span></span></code></pre></td></tr></table></div></div><p>En effet, câ€™est une instruction non valide, refusÃ©e par OpenGL Ã  la compilation du shader.</p><p>Ce que vous avez sous les yeux est le rÃ©sultat dâ€™une compilation dâ€™un shader ayant Ã©chouÃ©e, câ€™est le message dâ€™erreur que nous a retournÃ© OpenGL. La premiÃ¨re phrase est de moi, je lâ€™ai placÃ©e dans le code source C du programme. Les deux autres lignes contiennent un message mais avant cela, entre parenthÃ¨ses, la ligne de code de notre shader qui a Ã©tÃ© refusÃ©e (5). Câ€™est trÃ¨s important, retenez cela ;)</p><p>Afin de pouvoir effectuer un cast sans encombre, il va falloir donner Ã  notre shader ce quâ€™il attend : la composante manquante. (en lâ€™occurrence il sâ€™agit de la composante z) Il nous faut donc la spÃ©cifier explicitement, comme dans lâ€™exemple qui suit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â v2Â =Â ...;
</span></span><span class=line><span class=cl>vec3Â v3Â =Â vec3(v2,Â 0.0);
</span></span></code></pre></td></tr></table></div></div><p>Ce code est Ã©quivalent Ã  :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â v2Â =Â ...;
</span></span><span class=line><span class=cl>vec3Â v3;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>v3.xÂ =Â v2.x;
</span></span><span class=line><span class=cl>v3.yÂ =Â v2.y;
</span></span><span class=line><span class=cl>v3.zÂ =Â 0.0;
</span></span></code></pre></td></tr></table></div></div><p>Si vous le souhaitez, vous pouvez aussi faire ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â v2Â =Â ...;
</span></span><span class=line><span class=cl>vec3Â v3Â =Â vec3(0.0,Â v2);
</span></span></code></pre></td></tr></table></div></div><p>Mais ce code nâ€™aura pas le mÃªme effet que le prÃ©cÃ©dent, voici ce que lâ€™on obtient en lâ€™appelant :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â v2Â =Â ...;
</span></span><span class=line><span class=cl>vec3Â v3;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>v3.xÂ =Â 0.0;
</span></span><span class=line><span class=cl>v3.yÂ =Â v2.x;
</span></span><span class=line><span class=cl>v3.zÂ =Â v2.y;
</span></span></code></pre></td></tr></table></div></div><a href=#initialiser-le-contenu-dun-vecteur><h3 id=initialiser-le-contenu-dun-vecteur><span class=hanchor arialabel=Anchor># </span>Initialiser le contenu dâ€™un vecteur</h3></a><p>Maintenant que vous savez comment fonctionne lâ€™opÃ©rateur de cast, vous devriez comprendre facilement ce que fait ce bout de code :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â vÂ =Â vec3(0.0,Â 1.0,Â 0.5);
</span></span></code></pre></td></tr></table></div></div><p>Allez cherchez un peu :-Â°</p><p>â€¦</p><p>Alors vous trouvez ? :D</p><p>â€¦</p><p>Bon, je sens que vous avez fait bouillonner votre cerveau, câ€™est lâ€™heure de votre rÃ©compense :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â v;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>v.xÂ =Â 0.0;
</span></span><span class=line><span class=cl>v.yÂ =Â 1.0;
</span></span><span class=line><span class=cl>v.zÂ =Â 0.5;
</span></span></code></pre></td></tr></table></div></div><p>Et voilÃ  lâ€™travail :)</p><p>Il est Ã©galement possible dâ€™initialiser toutes les composantes dâ€™un vecteur dâ€™un seul coup :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â vÂ =Â vec3(0.0);
</span></span></code></pre></td></tr></table></div></div><p>Ce code place toutes les composantes du vecteur <em>v</em> Ã  0.</p><a href=#et-les-matrices-><h3 id=et-les-matrices-><span class=hanchor arialabel=Anchor># </span>Et les matricesâ€¦ ?</h3></a><p>Vous savez quoi ? On peut mettre des vecteurs dans des matrices :D Si si je vous assure :) Ainsi, ce code est tout Ã  fait correct :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec4Â a,Â b,Â c,Â d;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>aÂ =Â vec4(1.0,Â 0.0,Â 0.0,Â 0.0);
</span></span><span class=line><span class=cl>bÂ =Â vec4(0.0,Â 1.0,Â 0.0,Â 0.0);
</span></span><span class=line><span class=cl>cÂ =Â vec4(0.0,Â 0.0,Â 1.0,Â 0.0);
</span></span><span class=line><span class=cl>dÂ =Â vec4(0.0,Â 0.0,Â 0.0,Â 1.0);
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>mat4Â mÂ =Â mat4(a,Â b,Â c,Â d);
</span></span></code></pre></td></tr></table></div></div><p>Ce code a pour effet de charger dans <em>m</em> la matrice dâ€™identitÃ©. Bien Ã©videmment, il est inutilement lourd Ã  cause de la crÃ©ation de 4 vecteurs, il nâ€™est lÃ  quâ€™Ã  titre indicatif ;)</p><p>Il est important de noter ici que chaque vecteur reprÃ©sente une ligne de la matrice, câ€™est-Ã -dire que le premier vecteur ira se loger de <em>m</em>1,1 Ã  <em>m</em>1,4</p><p>Tout comme pour les vecteurs, il est possible dâ€™initialiser une matrice ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mat3Â mÂ =Â mat3(1.0);
</span></span></code></pre></td></tr></table></div></div><p>Toutefois il y a une diffÃ©rence ici avec les vecteurs. Lâ€™initialisation dâ€™une matrice comme nous lâ€™avons fait place toutes les composantes de <strong>la diagonale</strong> de la matrice Ã  1, et toutes les autres Ã  0. Avec 1, la matrice chargÃ©e est celle dâ€™identitÃ©, avec une autre valeur, la matrice est une matrice de mise Ã  lâ€™Ã©chelle de la valeur envoyÃ©e.</p><a href=#les-commentaires><h2 id=les-commentaires><span class=hanchor arialabel=Anchor># </span>Les commentaires</h2></a><p>Tout comme en C, il est possible dâ€™intÃ©grer des commentaires en GLSL. Ils ont la mÃªme forme ainsi que le mÃªme comportement :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/*Â commentaireÂ sur
</span></span><span class=line><span class=cl>Â Â Â plusieursÂ lignesÂ */
</span></span></code></pre></td></tr></table></div></div><p>Le GLSL accepte Ã©galement les commentaires commenÃ§ant par // comme en C99 :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//Â ceciÂ estÂ unÂ commentaireÂ surÂ uneÂ seuleÂ ligne
</span></span></code></pre></td></tr></table></div></div><a href=#les-tableaux><h2 id=les-tableaux><span class=hanchor arialabel=Anchor># </span>Les tableaux</h2></a><p>Encore une similitude avec le C : les tableaux. Ils se dÃ©finissent et sâ€™utilisent comme en C. Il est interdit de fournir une variable comme taille de tableau lors de sa dÃ©claration, seules les constantes sont acceptÃ©es :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ tab[3]Â =Â {0.0,Â 0.5,Â 1.0};
</span></span></code></pre></td></tr></table></div></div><p>En revanche lâ€™accÃ¨s aux valeurs contenues dans un tableau est des plus simples, cette fois-ci les variables sont bien sÃ»r acceptÃ©es :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>intÂ caseÂ =Â 2;
</span></span><span class=line><span class=cl>floatÂ valÂ =Â tab[case];Â //Â valÂ =Â 1
</span></span></code></pre></td></tr></table></div></div><p>Les tableaux en GLSL commencent Ã©galement Ã  0 : tab[0]</p><p>Vous souvenez-vous de la maniÃ¨re dont on accÃ¨de Ã  une composante dâ€™un vecteur ? Nous faisions comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â vÂ =Â vec2(1.0,Â 0.0);
</span></span><span class=line><span class=cl>floatÂ vxÂ =Â v.x;
</span></span></code></pre></td></tr></table></div></div><p>Et bien sachez quâ€™il est possible de considÃ©rer un vecteur comme un tableau ! Ainsi, ce code est strictement identique :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â vÂ =Â vec2(1.0,Â 0.0);
</span></span><span class=line><span class=cl>floatÂ vxÂ =Â v[0];
</span></span></code></pre></td></tr></table></div></div><p>Notez que lâ€™on prÃ©fÃ¨rera la premiÃ¨re mÃ©thode car elle est beaucoup plus lÃ©gÃ¨re et beaucoup plus lisible ;) .</p><p>Et pour les matrices ? Il existe aussi un tour de passe-passe ?</p><a href=#les-tableaux-Ã -deux-dimensions><h3 id=les-tableaux-Ã -deux-dimensions><span class=hanchor arialabel=Anchor># </span>Les tableaux Ã  deux dimensions</h3></a><p>Rien quâ€™Ã  la vue de ce titre, jâ€™imagine que vous prÃ©voyez dÃ©jÃ  ce que je vais vous dire :D Allons-y franchement : les matrices sont des tableaux Ã  deux dimensions !</p><p>Si vous connaÃ®ssez les tableaux Ã  deux dimensions en C, alors vous ne devriez pas avoir de problÃ¨mes. Allez, un exemple de code vaudra sÃ»rement mieux quâ€™un long discours :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mat4Â mÂ =Â mat4(
</span></span><span class=line><span class=cl>Â Â Â Â 1.0,Â 0.0,Â 0.0,Â 0.0,
</span></span><span class=line><span class=cl>Â Â Â Â 0.0,Â 1.0,Â 0.0,Â 0.0,
</span></span><span class=line><span class=cl>Â Â Â Â 0.0,Â 5.0,Â 1.0,Â 0.0,
</span></span><span class=line><span class=cl>Â Â Â Â 0.0,Â 0.0,Â 0.0,Â 1.0);
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>floatÂ varÂ =Â m[2][1];
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>//Â ici,Â varÂ =Â 5.0
</span></span></code></pre></td></tr></table></div></div><p>Dans <em>m[i][j]</em> on a :</p><ul><li><p><em><strong>i</strong></em> : la ligne (position en hauteur)</p></li><li><p><em><strong>j</strong></em> : la colonne (position en largeur)</p></li></ul><p>Et voilÃ , rien de trÃ¨s compliquÃ©, encore faut-il le savoir ;) .</p><p>Et comment on crÃ©e un tableau Ã  deux dimensions ?</p><p>Comme en C :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ tab[3][3]Â =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â {0.0,Â 0.0,Â 0.0},
</span></span><span class=line><span class=cl>Â Â Â Â {0.0,Â 0.0,Â 2.0},
</span></span><span class=line><span class=cl>Â Â Â Â {0.0,Â 0.0,Â 0.0}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>floatÂ varÂ =Â tab[1][2];
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>//Â varÂ =Â 2.0
</span></span></code></pre></td></tr></table></div></div><p>Notez quâ€™il est impÃ©ratif de dÃ©finir la taille dâ€™un tableau lors de sa dÃ©claration en GLSL, contrairement au langage C qui est capable de dÃ©duire tout seul de la taille dâ€™un tableau rien que par son contenu. Cette rÃ¨gle sâ€™applique aussi bien aux tableaux 1D que 2D.</p><hr><a href=#un-vertex-shader><h1 id=un-vertex-shader><span class=hanchor arialabel=Anchor># </span>Un vertex shader</h1></a><p>Maintenant que vous avez acquis les bases du langage, Ã§a vous dirait de programmer votre premier vertex shader ? Oui ? Pas de problÃ¨me, allons-y :p</p><a href=#un-vertex-shader--Ã§a-fait-quoi-><h2 id=un-vertex-shader--Ã§a-fait-quoi-><span class=hanchor arialabel=Anchor># </span>Un vertex shader : Ã§a fait quoi ?</h2></a><p>Un shader est donc un code source qui, une fois compilÃ©, est exÃ©cutable par la carte graphique. Quand vous Ã©crivez ce code source en OpenGL :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glColor3f(1.0, 0.0, 0.0); glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glColor3f(0.0, 1.0, 0.0); glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glColor3f(0.0, 0.0, 1.0); glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span></code></pre></td></tr></table></div></div><p>vous envoyez exactement 3 sommets (ou vertices, nom au choix) Ã  la carte graphique. Avant dâ€™Ãªtre affichÃ©s Ã  lâ€™Ã©cran ils sont tout dâ€™abord traitÃ©s; ils subissent de nombreuses transformations, puis les donnÃ©es sont interpolÃ©es afin de donner naissance Ã  un triangle plein.</p><p>Et quâ€™est-ce quâ€™il fait le vertex shader lÃ  dedans ?</p><p>Le vertex shader effectue entre autres la premiÃ¨re opÃ©ration : il fait subir des transformations (matricielles) aux sommets. Il vous permet en fait de toucher Ã  toutes les composantes (coordonnÃ©es de texture, normale, couleur, etcâ€¦) dâ€™un sommet et de les modifier Ã  votre guise :) Nous allons voir quâ€™il y a des rÃ¨gles pour le codage dâ€™un vertex shader, mais passÃ© celles-ci vous Ãªtes libres de faire tout ce dont vous avez envie.</p><p>Avec lâ€™exemple ci-dessus, le vertex shader sera invoquÃ© exactement 3 fois, ce qui est trÃ¨s peu. Le nombre dâ€™appel au vertex shader dÃ©pend donc du nombre de sommet que comporte votre scÃ¨ne, plus elle en comporte, et plus il y aura dâ€™appels au vertex shader, et donc plus le traitement sera lourd et consommateur de ressources.</p><p><strong>Il est important de savoir :</strong> quâ€™un vertex shader activÃ© sera actif sur tous les futurs sommets qui seront envoyÃ©s Ã  la carte graphique, jusquâ€™Ã  ce que les shaders de sommet soient dÃ©sactivÃ©s. Quand vous activez un vertex shader, il vient remplacer une partie du FFP, donc tous les sommets envoyÃ©s aprÃ¨s lâ€™activation du shader seront traitÃ©s par le vertex shader que vous avez activÃ©.</p><p>Ã‡a a lâ€™air dâ€™Ãªtre un vrai chantierâ€¦</p><p>Câ€™est une rÃ©flexion normale :-Â° Vous vous apercevrez vite que Ã§a nâ€™a rien de sorcier et que le langage a Ã©tÃ© bien pensÃ©, ce nâ€™est pas si difficile que Ã§a en a lâ€™air rassurez-vous, et puis, je suis lÃ  pour vous guider :D</p><a href=#quelques-rÃ¨gles-de-programmation><h2 id=quelques-rÃ¨gles-de-programmation><span class=hanchor arialabel=Anchor># </span>Quelques rÃ¨gles de programmation</h2></a><p>Tout comme en C, la programmation dâ€™un shader ne se fait pas Ã  â€œlâ€™arracheâ€, il y a des rÃ¨gles Ã  respecter.</p><a href=#la-fonction-main><h3 id=la-fonction-main><span class=hanchor arialabel=Anchor># </span>La fonction main</h3></a><p>En GLSL une fonction principale appelÃ©e <em>main()</em> est nÃ©cessaire. Cette derniÃ¨re se diffÃ©rencie des habituelles formes du <em>main()</em> du langage C par sa valeur de retour et ses arguments : la fonction main en GLSL ne renvoie rien et ne prend aucun paramÃ¨tre.</p><p>Nous lâ€™invoquerons comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â notreÂ codeÂ ici
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Comme en C, la fonction main reprÃ©sente la premiÃ¨re fonction qui sera exÃ©cutÃ©e.</p><p>Contrairement au C, les codes sources GLSL ne rÃ©clament pas de retour chariot en fin de fichier.</p><p>Câ€™est quoi un retour chariot ?</p><p>Câ€™est un retour Ã  la ligne (entrÃ©e) tout Ã  la fin du fichier.</p><p>Enfin, une derniÃ¨re chose Ã  retenir : un vertex shader doit <strong>toujours</strong> placer une valeur dans la variable de sortie gl_Position.</p><p>Hein ? Câ€™est quoi ce truc ?</p><a href=#les-variables-dentrÃ©esortie><h2 id=les-variables-dentrÃ©esortie><span class=hanchor arialabel=Anchor># </span>Les variables dâ€™entrÃ©e/sortie</h2></a><p>Il est ici important de se rappeler ce quâ€™est en gros un vertex shader : son objectif est dâ€™agir sur le traitement de chaque vertex quâ€™on lui enverra. Nous allons Ã  prÃ©sent voir quel est le rÃ´le prÃ©cis dâ€™un vertex shader, et ce quâ€™il permet de faire.</p><a href=#les-variables-dentrÃ©e><h3 id=les-variables-dentrÃ©e><span class=hanchor arialabel=Anchor># </span>Les variables dâ€™entrÃ©e</h3></a><p>Les variables dâ€™entrÃ©e sont gÃ©nÃ©ralement destinÃ©es Ã  Ãªtre lues puis traitÃ©es. Lorsque vous programmerez un vertex shader (et uniquement un vertex shader), OpenGL aura crÃ©Ã© pour vous quelques variables utiles, dont voici justement la liste :</p><table><thead><tr><th>Nom de la variable GLSL</th><th>Type</th><th>Fonction OpenGL appropriÃ©e</th><th>Description</th></tr></thead><tbody><tr><td>gl_Vertex</td><td><strong>vec4</strong></td><td><em>glVertex</em>()*</td><td>Position du sommet</td></tr><tr><td>gl_Color</td><td><strong>vec4</strong></td><td><em>glColor</em>()*</td><td>Couleur du sommet</td></tr><tr><td>gl_Normal</td><td><strong>vec3</strong></td><td><em>glNormal</em>()*</td><td>Normale du sommet.</td></tr><tr><td>gl_MultiTexCoord<em>n</em></td><td><strong>vec4</strong></td><td><em>glMultiTexCoord</em>()* ou <em>glTexCoord</em>()*</td><td>CoordonnÃ©es de lâ€™unitÃ© de texture <em>n</em></td></tr><tr><td>gl_SecondaryColor</td><td><strong>vec4</strong></td><td><em>glSecondaryColor</em>()*</td><td>Couleur secondaire du sommet</td></tr><tr><td>gl_FogCoord</td><td><strong>float</strong></td><td><em>glFogCoord</em>()*</td><td>CoordonnÃ©es de brouillard</td></tr></tbody></table><p>Jâ€™espÃ¨re quâ€™Ã  la vue de cette liste vous y voyez dÃ©jÃ  plus clair sur la tÃ¢che que remplie un vertex shader. Mais je pense que vous y verrez dâ€™autant plus clair lorsque vous aurez vu la liste des variables de sortie ;)</p><a href=#les-variables-de-sortie><h3 id=les-variables-de-sortie><span class=hanchor arialabel=Anchor># </span>Les variables de sortie</h3></a><p>AprÃ¨s avoir traitÃ© les variables dâ€™entrÃ©es Ã  notre guise, nous pourrons Ã©crire dans les variables de sortie. Les variables de sortie dâ€™un vertex shader (uniquement) reprÃ©sentent la position finale du sommet (position Ã©cran, ou presque) sa couleur finale, etcâ€¦ Voici la liste des variables de sortie disponibles :</p><table><thead><tr><th>Nom de la variable GLSL</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_Position</td><td><strong>vec4</strong></td><td>Position en coordonnÃ©es Ã©cran du sommet</td></tr><tr><td>gl_FrontColor</td><td><strong>vec4</strong></td><td>Couleur du cÃ´tÃ© â€œavantâ€ de la face Ã  laquelle<br>est rattachÃ© le sommet</td></tr><tr><td>gl_BackColor</td><td><strong>vec4</strong></td><td>Couleur du cÃ´tÃ© â€œarriÃ¨reâ€ de la face Ã  laquelle<br>est rattachÃ© le sommet</td></tr><tr><td>gl_FrontSecondaryColor</td><td><strong>vec4</strong></td><td>Couleur secondaire du cÃ´tÃ© â€œavantâ€ de la face<br>Ã  laquelle est rattachÃ© le sommet</td></tr><tr><td>gl_BackSecondaryColor</td><td><strong>vec4</strong></td><td>Couleur secondaire du cÃ´tÃ© â€œarriÃ¨reâ€ de la face<br>Ã  laquelle est rattachÃ© le sommet</td></tr><tr><td>gl_TexCoord[n]</td><td>tableau de <strong>vec4</strong></td><td>CoordonnÃ©es de lâ€™unitÃ© de texture <em>n</em></td></tr><tr><td>gl_FogFragCoord</td><td><strong>float</strong></td><td>CoordonnÃ©e de fog</td></tr><tr><td>gl_PointSize</td><td><strong>float</strong></td><td>Taille du point du sommet</td></tr><tr><td>gl_ClipVertex</td><td><strong>vec4</strong></td><td>Vecteur utilisÃ© pour les plans de clipping</td></tr></tbody></table><p>On y voit tout de suite plus clair nâ€™est-ce pas ? :D Vous pouvez dÃ©jÃ  vous faire une petite idÃ©e de la fonction dâ€™un vertex shader Ã  la vue de ces deux tableaux.</p><p>Vous vous souvenez de la rÃ¨gle de base pour un vertex shader ? Câ€™est que la variable gl_Positiondoit Ãªtre affectÃ©e Ã  une valeur Ã  la fin du vertex shader, sinon le vertex shader est invalide. Nous pouvons donc construire un vertex shader de base, tout simple, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ce vertex shader est tout Ã  fait correct, mais sa fonctionnalitÃ© laisse Ã  dÃ©sirer :-Â° Je vous propose tout de mÃªme de lâ€™Ã©tudier, afin de mettre les choses au clair pour la gestion des vertex shaders.</p><p>Si vous appliquez ce vertex shader Ã  vos rendus, les donnÃ©es envoyÃ©es Ã  la fonction <em>glVertex</em>()* seront les coordonnÃ©es <strong>Ã©cran</strong> de vos sommets, mÃªme si vous utilisez une transformation quelconque (<em>glTranslate</em>()* et compagnie) <strong>elle ne sera pas appliquÃ©e au sommet</strong> ! Idem pour la matrice de projection, elle nâ€™affectera pas la position que vous aurez envoyÃ© Ã  la fonction <em>glVertex</em>()*.</p><p>Câ€™est un peu dÃ©bile non ?</p><p>Non ! Câ€™est ce qui fait la flexibilitÃ© des shaders, câ€™est vous qui dÃ©cidez exactement comment vos sommets seront rendus, vous Ãªtes le maÃ®tre absolu de votre machine :)</p><p>Et alors comment on fait pour que notre vertex soit au bon endroit en subissant les transformations de nos matrices modelview et de projection ?</p><a href=#les-matrices-quelques-variables-dentrÃ©e-supplÃ©mentaires><h2 id=les-matrices-quelques-variables-dentrÃ©e-supplÃ©mentaires><span class=hanchor arialabel=Anchor># </span>Les matrices, quelques variables dâ€™entrÃ©e supplÃ©mentaires</h2></a><p>Si vous avez Ã  peu prÃ¨s compris ce que sont les variables dâ€™entrÃ©e, vous devriez sauter au plafond Ã  la vue de ce titre :D</p><p>Ah bon ? Moi Ã§a ne fait que mâ€™embrouiller encore plusâ€¦ Quâ€™est-ce quâ€™elles peuvent nous faire ces matrices ?</p><p>Chers ZÃ©r0s, vous devriez savoir comment fonctionne le rendu dâ€™un sommet et quelles sont les transformations qui lui sont appliquÃ©es, sinon câ€™est que vous nâ€™Ãªtes pas totalement prÃªts Ã  lire ce tutoriel. Bien sÃ»r je pourrais vous faire gober des principes tout cuits, mais Ã§a ne serait pas trÃ¨s pÃ©dagogique en plus du fait que vous risqueriez dâ€™Ãªtre un peu bloquÃ© par la suite. Sur ce, je vous renvoie sur
<a href="http://jeux.developpez.com/faq/3d/?page=definitions#DEFINITIONS_3d_to_2d" rel=noopener>cet excellent lien</a> qui vous expliquera comment on passe des coordonnÃ©es 3D aux coordonnÃ©es Ã©cran.</p><a href=#vous-avez-dit-variable-dentrÃ©e-><h3 id=vous-avez-dit-variable-dentrÃ©e-><span class=hanchor arialabel=Anchor># </span>Vous avez dit â€œvariable dâ€™entrÃ©eâ€ ?</h3></a><p>Parfaitement :) Ces variables ne sont rien dâ€™autre que des matrices, et Ã´ combien utiles. Je vous propose de voir sans plus tarder la listes des matrices disponibles au sein dâ€™un vertex shader uniquement :</p><table><thead><tr><th>Nom de la variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_ModelViewMatrix</td><td><strong>mat4</strong></td><td>Câ€™est la matrice de modÃ©lisation/visualisation,<br>celle que lâ€™on manipule avec GL_MODELVIEW en C</td></tr><tr><td>gl_ModelViewMatrixInverse</td><td><strong>mat4</strong></td><td>Câ€™est lâ€™inverse de la matrice gl_ModelViewMatrix</td></tr><tr><td>gl_ModelViewMatrixTranspose</td><td><strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_ModelViewMatrix</td></tr><tr><td>gl_ModelViewMatrixInverseTranspose</td><td><strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_ModelViewMatrixInverse</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_ProjectionMatrix</td><td><strong>mat4</strong></td><td>Câ€™est la matrice de projection GL_PROJECTION, maniable<br>entre autres avec gluPerspective() dans le code C</td></tr><tr><td>gl_ProjectionMatrixInverse</td><td><strong>mat4</strong></td><td>Câ€™est lâ€™inverse de la matrice gl_ProjectionMatrix</td></tr><tr><td>gl_ProjectionMatrixTranspose</td><td><strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_ProjectionMatrix</td></tr><tr><td>gl_ProjectionMatrixInverseTranspose</td><td><strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_ProjectionMatrixInverse</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_ModelViewProjectionMatrix</td><td><strong>mat4</strong></td><td>Câ€™est la matrice gl_ModelViewMatrix multipliÃ©e<br>par la matrice gl_ProjectionMatrix</td></tr><tr><td>gl_ModelViewProjectionMatrixInverse</td><td><strong>mat4</strong></td><td>Câ€™est lâ€™inverse de la matrice gl_ModelViewProjectionMatrix</td></tr><tr><td>gl_ModelViewProjectionMatrixTranspose</td><td><strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_ModelViewProjectionMatrix</td></tr><tr><td>gl_ModelViewProjectionMatrixInverseTranspose</td><td><strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_ModelViewProjectionMatrixInverse</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_TextureMatrix[n]</td><td>tableau de <strong>mat4</strong></td><td>Câ€™est la matrice de lâ€™unitÃ© de texturage <em>n</em>,<br>maniable en C avec GL_TEXTURE</td></tr><tr><td>gl_TextureMatrixInverse[n]</td><td>tableau de <strong>mat4</strong></td><td>Câ€™est lâ€™inverse de la matrice gl_TextureMatrix[n]</td></tr><tr><td>gl_TextureMatrixTranspose[n]</td><td>tableau de <strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_TextureMatrix[n]</td></tr><tr><td>gl_TextureMatrixInverseTranspose[n]</td><td>tableau de <strong>mat4</strong></td><td>Câ€™est la transposÃ©e de la matrice gl_TextureMatrixInverse[n]</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_NormalMatrix</td><td><strong>mat3</strong></td><td>Câ€™est la transposÃ©e inverse de la partie 3*3 de la matrice gl_ModelViewMatrix<br>(matrice gÃ©nÃ©ralement appliquÃ©e Ã  la variable gl_Normal<br>pour les transformations de normales)</td></tr></tbody></table><p>Pffiouuu, Ã§a fait du monde hein ? :D Allez, que diriez-vous dâ€™un petitâ€¦</p><a href=#exercice><h3 id=exercice><span class=hanchor arialabel=Anchor># </span>Exercice</h3></a><p>Fini dâ€™rire ! :diable:</p><p>Bien, voici le vertex shader que nous avons prÃ©cÃ©demment Ã©crit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Jâ€™aimerai que vous le modifiez afin que la position finale du sommet (gl_Position) soit affectÃ©e par la matrice de modÃ©lisation <strong>et</strong> la matrice de projection, comme Ã§a notre sommet aura la bonne position Ã  lâ€™Ã©cran si par exemple nous avons configurÃ© une projection 3D :) Un indice ? Rappelez-vous la premiÃ¨re partie du tutoriel, Ã  lâ€™endroit oÃ¹ je parle des opÃ©rateurs, et plus prÃ©cisÃ©ment de leur surcharge ;)</p><p>Allez-y !</p><p>â€¦</p><a href=#correction><h3 id=correction><span class=hanchor arialabel=Anchor># </span>Correction</h3></a><p>Voici la rÃ©ponse :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_ModelViewProjectionMatrixÂ *Â gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Allez, avouez que câ€™Ã©tait pas trop difficile :-Â°</p><p>VoilÃ , vous savez Ã  prÃ©sent thÃ©oriquement comment faire un vertex shader, Ã©videmment celui-ci est extrÃªmement simple et nâ€™a que peu dâ€™intÃ©rÃªt, mais vous pouvez dÃ©jÃ  essayer de vous amuser Ã  modifier les variables de sortie pour voir le rÃ©sultat que cela donnera et aussi pour vous familiariser avec le langage GLSL ;)</p><hr><a href=#un-pixel-shader><h2 id=un-pixel-shader><span class=hanchor arialabel=Anchor># </span>Un pixel shader</h2></a><p>Nous avons vu en gros quel Ã©tait la tÃ¢che dâ€™un vertex shader, son rÃ´le au sein du rendu 3D. Que diriez-vous de savoir ce que fait un pixel shader Ã  prÃ©sent ? Vous vous demandez probablement Ã  quoi ils peuvent bien servir, mais croyez-moi : ils servent Ã©normÃ©ment ;)</p><a href=#traiter-le-rendu-dun-pixel-><h2 id=traiter-le-rendu-dun-pixel-><span class=hanchor arialabel=Anchor># </span>Traiter le rendu dâ€™un pixel ?</h2></a><p>Un pixel shader agit au niveau du rendu du pixel Ã  lâ€™Ã©cran. Câ€™est petit, trÃ¨s petit, et pourtant chaque pixel est traitÃ© indÃ©pendamment et nÃ©cessite des calculs, parfois nombreux, pour obtenir sa couleur exacte Ã  lâ€™Ã©cran.</p><p>Le code source dâ€™un pixel shader peut Ãªtre plus ou moins gros, mais une chose est sÃ»re : plus il est consÃ©quent et demande beaucoup de calculs et plus les performances chutent vite. Effectivement, alors que les vertex shaders agissent au niveau de chaque sommet, si vous nâ€™affichez quâ€™un triangle, le code de votre vertex shader ne sera exÃ©cutÃ© quâ€™une seule fois. Les pixel shaders quant Ã  eux sont exÃ©cutÃ©s autant de fois quâ€™il y a de pixels dans ce triangle Ã  lâ€™Ã©cran ! Si votre triangle rempli tout lâ€™Ã©cran et que votre fenÃªtre de rendu fait 1024*768 pixels, alors votre pixel shader sera appelÃ© 1024 * 768 = 786432 fois ! Câ€™est beaucoup, trÃ¨s beaucoup ! :D</p><a href=#une-limite-en-puissance-assez-restreinte-><h3 id=une-limite-en-puissance-assez-restreinte-><span class=hanchor arialabel=Anchor># </span>Une limite en puissance assez restreinte ?</h3></a><p>Et pourtant non ! Il est aujourdâ€™hui possible de programmer des pixels shaders trÃ¨s complexes sur des rÃ©solutions dâ€™Ã©cran de 1600*1024 sans que le frame rate en soit trÃ¨s affectÃ©. Prenez un exemple simple : les jeux vidÃ©o. Les jeux vidÃ©o rÃ©cents utilisent Ã©normÃ©ment les shaders, vertex et pixel. Les joueurs sâ€™achÃ¨tent des Ã©crans toujours plus larges et arrivent tout de mÃªme Ã  jouer Ã  des jeux gourmands tels que F.E.A.R ou SplinterCell DA en haute rÃ©solution et sans lags (saccades).</p><a href=#pourquoi-><h3 id=pourquoi-><span class=hanchor arialabel=Anchor># </span>Pourquoi ?</h3></a><p>Pourquoi, avec des rÃ©solutions Ã©normes, des shaders complexes et des scÃ¨nes rendues en plusieurs passes les jeux ne mettent pas Ã  genoux les PC modernes ? (bien que certains se plaignent de jouer Ã  40 FPS :-Â° ) Comment est-il possible de traiter plusieurs millions, et parfois mÃªme milliard(s), dâ€™appels Ã  un pixel shader par seconde ? La rÃ©ponse est relativement simple : les pixels shaders sont des shaders, et par consÃ©quent ils sont traitÃ©s par la <strong>carte graphique</strong>.</p><p>Ouah je suis super impressionnÃ©â€¦ En plus je le savais dÃ©jÃ .</p><p>Croyez-moi, il y a de quoi Ãªtre impressionnÃ©, si vous demandiez Ã  votre processeur de modifier une image pixel par pixel (vous comprendrez mieux cela lorsque nous parlerons des textures, plus loin dans le tutoriel), cela prendrait un temps Ã©norme. Un exemple simple : les logiciels de dessin 2D (The GIMP, Photoshop, â€¦) sont trÃ¨s lourds et parfois aussi trÃ¨s lents Ã  rendre un effet sur vos images, essayez pour voir de regarder quelle est la consommation CPU rien que quand vous dessinez un trait avec un effet de flou ;)</p><p>Les cartes graphiques sont <strong>conÃ§ues pour</strong> traiter des pixels, enfin tout du moins les cartes graphiques un minimum rÃ©centes. Si vous avez une GeForce 6 ou supÃ©rieur, ou une Radeon 9800pro ou supÃ©rieur, vous pouvez Ãªtres sÃ»rs que les shaders de sommet tout comme de pixel sont parfaitement supportÃ©s ;)</p><a href=#bon-quest-ce-quon-attend-pour-programmer-Ã§a-><h2 id=bon-quest-ce-quon-attend-pour-programmer-Ã§a-><span class=hanchor arialabel=Anchor># </span>Bon, quâ€™est-ce quâ€™on attend pour programmer Ã§a ?</h2></a><p>Que vous soyez psychologiquement prÃªts :D</p><a href=#le-code-source-de-base><h3 id=le-code-source-de-base><span class=hanchor arialabel=Anchor># </span>Le code source de base</h3></a><p>Tout comme le vertex shader, le pixel shader requiert une fonction main. En revanche contrairement aux vertex shaders, les pixel shaders GLSL nâ€™exigent aucun code source de base au sein de la fonction main, ce qui veut dire quâ€™un pixel shader Ã©crit comme suit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â rien
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>est tout Ã  fait acceptable et compilera sans broncher. Par contre, son effet est plus que maigre : il ne fait <strong>rien</strong>. Et ici, rien signifie rien de rien, autrement dit, rien ne sâ€™affichera Ã  lâ€™Ã©cran.</p><p>Avant de pouvoir faire afficher quelque chose Ã  notre pixel shader, il est important de connaÃ®tre ses variables dâ€™entrÃ©e ainsi que celles de sortie, car il en possÃ¨de, tout comme les vertex shaders.</p><a href=#les-variables-dentrÃ©e-1><h3 id=les-variables-dentrÃ©e-1><span class=hanchor arialabel=Anchor># </span>Les variables dâ€™entrÃ©e</h3></a><p>Comme pour les variables dâ€™entrÃ©e de nos vertex shaders, un joli tableau fera lâ€™affaire. Il nâ€™est bien sÃ»r pas important que vous le reteniez par coeur pour lâ€™instant, mais au moins, le jour oÃ¹ vous voudrez une info, vous nâ€™aurez quâ€™Ã  venir ici ;) :</p><table><thead><tr><th>Nom de la variable GLSL</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_Color</td><td><strong>vec4</strong></td><td>Couleur du pixel</td></tr><tr><td>gl_FragCoord</td><td><strong>vec2</strong></td><td>CoordonnÃ©es Ã©cran du pixel</td></tr><tr><td>gl_SecondaryColor</td><td><strong>bool</strong></td><td>Couleur secondaire</td></tr><tr><td>gl_TexCoord[n]</td><td>tableau de <strong>vec4</strong></td><td>CoordonnÃ©es de lâ€™unitÃ© de texturage <em>n</em></td></tr><tr><td>gl_FogFragCoord</td><td><strong>float</strong></td><td>CoordonnÃ©e de fog</td></tr></tbody></table><p>Comme vous le voyez, certaines variables correspondent Ã  des variables de sortie du vertex shader. Cela prouve bien que les vertex et les pixel shaders GLSL sont trÃ¨s liÃ©s entre eux.</p><p>Nous avons maintenant une couleur rÃ©cupÃ©rable dans la variable gl_Color, chouette, on va pouvoir attribuer une couleur Ã  notre pixel. Maisâ€¦ il nous manque quelque choseâ€¦ Comment dire Ã  GLSL quâ€™on souhaite voir notre pixel avec la couleur contenue dans gl_Color ? HÃ© bien lâ€™expÃ©rience des vertex shaders devrait vous le dire, il nous faut une variable de sortie Ã  laquelle attribuer cette couleur :) .</p><a href=#les-variables-de-sortie-1><h3 id=les-variables-de-sortie-1><span class=hanchor arialabel=Anchor># </span>Les variables de sortie</h3></a><p>Câ€™est bon, câ€™est fini les gros tableaux de la mort ?</p><p>Et non, pourtant avec un simple pixel shader on peut se demander ce quâ€™il peut bien faire Ã  part affecter la couleur finale du pixel. Pourtant, il existe deux autres variables de sortie que celle qui permet de renvoyer la couleur du pixel :</p><table><thead><tr><th>Nom de la variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_FragColor</td><td><strong>vec4</strong></td><td>Couleur finale du pixel</td></tr><tr><td>gl_FragDepth</td><td><strong>float</strong></td><td>Profondeur du pixel dans le depth buffer</td></tr><tr><td>gl_FragData[n]</td><td>tableau de <strong>vec4</strong></td><td>En rapport avec <em>glDrawBuffers()</em></td></tr></tbody></table><p>Il nâ€™existe malheureusement encore aucune variable permettant de modifier la position finale du pixel Ã  lâ€™Ã©cran.</p><p>Lâ€™intÃ©rÃªt gÃ©nÃ©ral des pixel shaders est plutÃ´t mince non ?</p><p>Pas du tout ! Bon Ã©videmment pour lâ€™instant il est normal que vous soyez sceptiques, mais vous dÃ©couvrirez au fur et Ã  mesure lâ€™utilitÃ© des pixel shaders, et Ã  la fin vous verrez ; on ne sâ€™en passe plus ;)</p><a href=#programmer-un-simple-pixel-shader><h3 id=programmer-un-simple-pixel-shader><span class=hanchor arialabel=Anchor># </span>Programmer un simple pixel shader</h3></a><p>Vous vous souvenez de la faÃ§on dont on sâ€™y prend, dans les vertex shaders, pour affecter la variable de sortie gl_Position afin que notre vertex soit positionnÃ© au bon endroit ? Et bien le principe est le mÃªme dans les pixel shaders lorsquâ€™on veut affecter la couleur du pixel sortant par la couleur dâ€™entrÃ©e de base. Contrairement au vertex shader oÃ¹ il faut appliquer des transformations matricielle pour obtenir la position finale, ici rien de particulier nâ€™est Ã  faire, il suffit de transmettre directement la couleur, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_FragColorÂ =Â gl_Color;Â //Â c&#39;estÂ aussiÂ simpleÂ queÂ cela
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ce pixel shader nâ€™est pas trÃ¨s Ã©voluÃ© et nâ€™a pour effet que dâ€™affecter Ã  la couleur finale du pixel la couleur interpolÃ©e des trois sommets formant le triangle auquel appartient ce pixel. (phrase compliquÃ©e je vous lâ€™accorde :-Â° ) Il nâ€™y a aucun traitement des textures ou autres attributs du vertex, seules les donnÃ©es de couleur (<em>glColor</em>()*) sont traitÃ©es.</p><p><strong>Attention</strong> : Comme je lâ€™ai dÃ©jÃ  dit, le vertex shader est trÃ¨s liÃ© au pixel shader, ainsi donc, si vous nâ€™affectez pas la variable de sortie gl_FrontColor de votre vertex shader, la variable dâ€™entrÃ©e gl_Color du pixel shader ne contiendra aucune valeur ! La valeur par dÃ©faut des variables est 0 gÃ©nÃ©ralement, vous aurez donc un Ã©cran noir si vous ne faites pas un vertex shader conÃ§u comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_FrontColorÂ =Â gl_Color;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_ModelViewProjectionMatrixÂ *Â gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Et voilÃ , câ€™est dÃ©jÃ  enfin la fin de ce chapitre, peut-Ãªtre un peu rebutant, mais trÃ¨s important ;) .</p><p>Maintenant la comprÃ©hension de la suite du tutoriel vous sera plus aisÃ©e, et nous pourrons donc avancer plus vite dans lâ€™apprentissage du langage, et câ€™est tant mieux, parce que le GLSL câ€™est bien joli, mais notre but de base câ€™est dâ€™apprendre des techniques de rendu pour rÃ©aliser de chouettes effets graphiques :)</p><p><em>Les tableaux Ã©numÃ©ratifs de variables de ce chapitre sont inspirÃ©s du livre
<a href=http://www.amazon.fr/Open-GL-2-0-Guide-officiel/dp/2744020869 rel=noopener>OpenGL 2.0 Guide Officiel</a>, mais certains sont Ã©galement disponibles dans les
<a href=http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf rel=noopener>spÃ©cifications du langage</a>.</em></p><hr><a href=#notions-supplÃ©mentaires><h1 id=notions-supplÃ©mentaires><span class=hanchor arialabel=Anchor># </span>Notions supplÃ©mentaires</h1></a><p>Au terme de ce chapitre, vous serez fin prÃªts pour apprendre toutes les fonctionnalitÃ©s avancÃ©es que propose le GLSL, et cela vous permettra de trouver une rÃ©elle utilitÃ© aux shaders.</p><p>Nous allons tout dâ€™abord passer en revue toutes les notions du langage GLSL qui sont communes Ã  celles du C, puis dans un second temps je vais vous montrer les quelques diffÃ©rences entre les deux langages, afin de mettre les choses au clair. Ensuite, nous apprendrons Ã  crÃ©er des fonctions, mais surtout Ã  les surcharger. Vous ne connaissez peut-Ãªtre pas la notion de surcharge des fonctions, il est donc important que vous lâ€™appreniez, vous verrez que cela ressemble Ã  la surcharge des opÃ©rateurs. Puis je finirai par vous prÃ©senter quelques fonctions natives du langage GLSL bien pratiques, qui sont trÃ¨s souvent utilisÃ©es.</p><a href=#notions-communes-et-incompatibilitÃ©s-avec-le-c><h2 id=notions-communes-et-incompatibilitÃ©s-avec-le-c><span class=hanchor arialabel=Anchor># </span>Notions communes et incompatibilitÃ©s avec le C</h2></a><p>Bien, commenÃ§ons. Je voudrais tout dâ€™abord vous prÃ©senter tout ce qui existe dans le langage GLSL qui se rapporte au C, afin de gagner du temps.</p><p>Le GLSL nâ€™est pas un langage aussi rigoureux que le C, je le considÃ©rerais plutÃ´t comme un langage â€œjouetâ€, il suffit dâ€™enchaÃ®ner quelques instructions dans un <code>main()</code> et le tour est jouÃ©. Ã€ partir du moment oÃ¹ votre shader fonctionne correctement, il y a peu de chances que vous ayez Ã  le rÃ©viser pour une raison autre que sa performance.</p><a href=#notions-communes><h2 id=notions-communes><span class=hanchor arialabel=Anchor># </span>Notions communes</h2></a><p>Je vous propose de commencer par les instructions de contrÃ´le.</p><a href=#les-instructions-ifelse><h3 id=les-instructions-ifelse><span class=hanchor arialabel=Anchor># </span>Les instructions ifâ€¦else</h3></a><p>En C, il est possible de crÃ©er une condition de la faÃ§on suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if(condition)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    instructions;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    autres instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Eh bien sachez que ce code fonctionne aussi en GLSL. Par exemple, ceci est tout Ã  fait correct :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>intÂ a,Â b;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>if(aÂ ==Â b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â instructions;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â autresÂ instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Lâ€™omission des accolades est Ã©galement autorisÃ©e si les instructions se rÃ©sument Ã  une seule instruction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>intÂ a,Â b;
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>if(aÂ ==Â b)
</span></span><span class=line><span class=cl>Â Â Â Â instruction;
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>Â Â Â Â autreÂ instruction;
</span></span></code></pre></td></tr></table></div></div><p>Les opÃ©rateurs de comparaison sont les mÃªmes quâ€™en C.</p><a href=#instructions-break-et-continue><h3 id=instructions-break-et-continue><span class=hanchor arialabel=Anchor># </span>Instructions break et continue</h3></a><p>Idem quâ€™en C lÃ  encore, les instructions <strong>break</strong> et <strong>continue</strong> existent et ont le mÃªme effet quâ€™en langage C ; Ã  savoir :</p><ul><li><p><strong>break</strong> : sortir de la boucle dâ€™instructions courante ;</p></li><li><p><strong>continue</strong> : poursuivre le dÃ©roulement de la boucle dâ€™instructions Ã  partir du â€œhautâ€ du bloc.</p></li></ul><a href=#la-boucle-dowhile><h3 id=la-boucle-dowhile><span class=hanchor arialabel=Anchor># </span>La boucle doâ€¦while</h3></a><p>Comme en C, le mot clÃ© <strong>do</strong> est suivi dâ€™un bloc dâ€™instructions, puis dâ€™une condition entre parenthÃ¨ses aprÃ¨s un <strong>while</strong>, comme dans lâ€™exemple ci-dessous :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>do
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â instructions;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>while(condition);
</span></span></code></pre></td></tr></table></div></div><p>Ce code veut dire :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>exÃ©cuter
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â toutÂ ceci
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>tantÂ queÂ (condition)Â estÂ vraie
</span></span></code></pre></td></tr></table></div></div><p>Ne pas oublier le point-virgule Ã  la fin du while. Les accolades peuvent lÃ  aussi Ãªtres omisent si il nâ€™y a quâ€™une seule instruction dans le bloc.</p><a href=#la-boucle-while><h3 id=la-boucle-while><span class=hanchor arialabel=Anchor># </span>La boucle while</h3></a><p>Sâ€™utilise de la mÃªme faÃ§on quâ€™en C, et a le mÃªme effet, Ã  savoir ; exÃ©cuter un bloc dâ€™instructions en boucle tant que la condition contenue entre les parenthÃ¨ses suivants le mot clÃ© <strong>while</strong> est vraie, avec une vÃ©rification de celle-ci avant le premier lancement de la boucle (contrairement Ã  doâ€¦while).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>while(condition)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Comme dâ€™habitude, les accolades peuvent Ãªtres enlevÃ©es si il nâ€™y a quâ€™une instruction Ã  exÃ©cuter.</p><a href=#la-boucle-for><h3 id=la-boucle-for><span class=hanchor arialabel=Anchor># </span>La boucle for</h3></a><p>Celle-ci permet, comme en C, dâ€™intÃ©grer facilement un compteur Ã  une boucle. Voici un pseudo-code pour prÃ©senter lâ€™instruction <strong>for</strong> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for(Â instructions1Â ;Â conditionsÂ ;Â instructions2Â )
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â autresÂ instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Son effet est le mÃªme quâ€™en C :</p><ol><li><p>exÃ©cuter <em>instructions1</em> ;</p></li><li><p>tant que <em>conditions</em> est vrai, exÃ©cuter :</p><ol><li><p><em>autre instructions</em> ;</p></li><li><p><em>instructions2</em>.</p></li></ol></li></ol><a href=#les-structures><h3 id=les-structures><span class=hanchor arialabel=Anchor># </span>Les structures</h3></a><p>Les structures sont Ã©galement possibles en GLSL. Elles se dÃ©finissent bien sÃ»r de la mÃªme faÃ§on, en utilisant le mot clÃ© <strong>struct</strong> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>structÂ MaStructure
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â intÂ a,Â b;
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>Vous pouvez bien sÃ»r crÃ©er toutes sortes de variables dans votre structure (des vecteurs, des matrices, etcâ€¦). Une structure se crÃ©e et sâ€™utilise ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MaStructureÂ str;Â //Â declaration
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>str.aÂ =Â 0;Â //Â accesÂ auxÂ variables
</span></span><span class=line><span class=cl>str.bÂ =Â str.a;
</span></span></code></pre></td></tr></table></div></div><p>Vous noterez quâ€™il nâ€™est pas nÃ©cessaire de prÃ©fixer la dÃ©claration des variables de type structure avec le mot clÃ© <code>struct</code>. Eh oui, le mot clÃ© <strong>typedef</strong> nâ€™existe pas en GLSL, plus besoin de vous embÃªter avec.</p><a href=#le-prÃ©processeur><h3 id=le-prÃ©processeur><span class=hanchor arialabel=Anchor># </span>Le prÃ©processeur</h3></a><p>Il fonctionne comme en langage C : toutes les commandes de prÃ©processeur doivent Ãªtre prÃ©fixÃ©es par Â« # Â». Parmi ces commandes, on retrouvera entre autre le fameux <strong>"#define"</strong>, qui permet de dÃ©finir des macros, <strong>"#undef"</strong> qui les â€œdÃ©-dÃ©finiâ€, mais aussi les instructions <strong>"#if"</strong>, <strong>"#ifdef"</strong>, <strong>"#ifndef"</strong>, <strong>"#else"</strong>, <strong>"#elif"</strong> et <strong>"#endif"</strong>, qui ont toutes le mÃªme effet quâ€™en C.</p><p>Par exemple, vous pourriez changer lâ€™intÃ©gritÃ© de votre shader juste avec une macro, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#ifdefÂ SUPERSHADER
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>//Â codeÂ sourceÂ duÂ superÂ shader
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>#else
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>//Â codeÂ sourceÂ d&#39;unÂ shaderÂ unÂ peuÂ moinsÂ bien
</span></span><span class=line><span class=cl>Â 
</span></span><span class=line><span class=cl>#endif
</span></span></code></pre></td></tr></table></div></div><p>Ainsi, si SUPERSHADER est dÃ©finie, seules les instructions contenues entre <strong>"#ifdef"</strong> et <strong>"#else"</strong> seront compilÃ©es, sinon Ã§a sera celles qui sont entre <strong>"#else"</strong> et <strong>"#endif"</strong>.</p><a href=#incompatibilitÃ©s-et-diffÃ©rences><h2 id=incompatibilitÃ©s-et-diffÃ©rences><span class=hanchor arialabel=Anchor># </span>IncompatibilitÃ©s et diffÃ©rences</h2></a><a href=#les-dÃ©clarations-de-variables><h3 id=les-dÃ©clarations-de-variables><span class=hanchor arialabel=Anchor># </span>Les dÃ©clarations de variables</h3></a><p>Contrairement au C89 qui exige que les variables soient dÃ©finies au dÃ©but de votre code, le GLSL autorise quant Ã  lui la crÃ©ation de variables nâ€™importe oÃ¹ dans votre shader (autorisÃ© Ã©galement en C99). Avec cette libertÃ© de crÃ©ation de variables, il est possible de crÃ©er une variable dans une instruction for, comme ceci par exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for(intÂ iÂ =Â 0;Â iÂ &lt;Â 5;Â i++)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#les-pointeurs-et-linstruction-switch><h3 id=les-pointeurs-et-linstruction-switch><span class=hanchor arialabel=Anchor># </span>Les pointeurs et lâ€™instruction switch</h3></a><p>Les pointeurs de mÃªme que lâ€™instruction switch nâ€™existent pas en GLSL.</p><hr><a href=#crÃ©er-et-surcharger-des-fonctions><h2 id=crÃ©er-et-surcharger-des-fonctions><span class=hanchor arialabel=Anchor># </span>CrÃ©er et surcharger des fonctions</h2></a><a href=#dÃ©clarer-une-simple-fonction><h2 id=dÃ©clarer-une-simple-fonction><span class=hanchor arialabel=Anchor># </span>DÃ©clarer une simple fonction</h2></a><p>Tout est quasiment identique au C, mais je prÃ©fÃ¨re tout de mÃªme mettre les choses au clair. Comme en C, une fonction possÃ¨de :</p><ul><li><p>une valeur de retour dâ€™un certain type ;</p></li><li><p>un nom ;</p></li><li><p>des paramÃ¨tres ;</p></li><li><p>un contenu, entre accolades {}.</p></li></ul><p>La dÃ©claration dâ€™une fonction se fait comme en C, on commence par mettre son type de retour, son nom, puis ses paramÃ¨tres entre parenthÃ¨ses. Pour finir, on ouvre une accolade puis on place le contenu de notre fonction Ã  lâ€™intÃ©rieur :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ my_func(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â //Â contenu
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Vous voyez ici lâ€™emploi du type <strong>void</strong>, qui signifie comme en C : vide. Donc notre fonction ne retourne rien et ne prend aucun paramÃ¨tre. De mÃªme quâ€™en C, la notion de prototype existe. DÃ©clarez vos prototypes tout en haut du code source, ainsi vous nâ€™aurez aucun problÃ¨me :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ my_func(void);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>floatÂ my_func(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Notez que dâ€™une faÃ§on gÃ©nÃ©rale, si votre fonction nâ€™a pas Ã©tÃ© dÃ©clarÃ©e, vous ne pourrez pas lâ€™utiliser. Ainsi, soit vous dÃ©clarez son prototype tout en haut de votre code et vous vous Ã©pargnez tout problÃ¨me, soit vous triez vos fonctions de faÃ§on sÃ©lective afin que les dÃ©pendances soient satisfaites.</p><a href=#paramÃ¨tres-et-valeur-de-retour><h3 id=paramÃ¨tres-et-valeur-de-retour><span class=hanchor arialabel=Anchor># </span>ParamÃ¨tres et valeur de retour</h3></a><p>Nous pouvons Ã©galement Ã©crire une fonction qui prend un ou plusieurs paramÃ¨tres, et renvoie une variable. Pour renvoyer une variable, vous devez mettre son type avant le nom de la fonction. Vous pouvez renvoyer nâ€™importe quel type de variable en GLSL :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â my_func(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â vec3Â result;
</span></span><span class=line><span class=cl>Â Â Â Â 
</span></span><span class=line><span class=cl>Â Â Â Â ...Â //Â calculsÂ horriblementÂ complexes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ result;Â //Â onÂ renvoieÂ leÂ resultat
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Notez ici le mot clÃ© <strong>return</strong>, il existe Ã©galement en GLSL et a le mÃªme effet quâ€™en C : renvoyer une valeur de retour en terminant lâ€™exÃ©cution de la fonction.</p><p>Pour donner un paramÃ¨tre Ã  une fonction, il suffit de rajouter son type suivi du nom de la variable qui contiendra la valeur du paramÃ¨tre, entre les parenthÃ¨ses qui suivent le nom de la fonction, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â my_func(vec3Â v)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â vec3Â result;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â resultÂ =Â vÂ *Â 2;Â //Â calculsÂ horriblementÂ complexes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ result;Â //Â onÂ renvoieÂ leÂ resultat
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Comme en C, on accÃ¨de Ã  un paramÃ¨tre en Ã©crivant son nom. Ici, la super fonction que jâ€™ai Ã©crit relÃ¨ve rÃ©ellement du gÃ©nie : elle renvoie un vecteur qui est celui envoyÃ© en paramÃ¨tre multipliÃ© par 2.</p><a href=#la-surcharge-des-fonctions><h2 id=la-surcharge-des-fonctions><span class=hanchor arialabel=Anchor># </span>La surcharge des fonctions</h2></a><a href=#notion-de-surcharge><h3 id=notion-de-surcharge><span class=hanchor arialabel=Anchor># </span>Notion de surcharge</h3></a><p>Nous avons dÃ©jÃ  vu la surcharge des opÃ©rateurs dans le prÃ©cÃ©dent chapitre. La notion de surcharge existe Ã©galement pour les fonctions. Surcharger une fonction signifie, en gros, quâ€™on va attribuer un seul nom de fonction Ã  plusieurs fonctions.</p><p>Par exemple, supposez que vous vouliez Ã©crire une fonction qui renvoie le
<a href=http://www.siteduzero.com/tuto-3-18391-1-les-vecteurs.html#ss_part_3 rel=noopener>produit scalaire</a> de deux vecteurs. En C, vous auriez Ã©crit une fonction pour chaque type de vecteur : une pour les vecteurs Ã  2 dimensions et une autre pour les vecteurs en 3 dimensions, et elles auraient chacune un nom diffÃ©rent. Pas trÃ¨s pratique Ã  utiliser.</p><p>Pour remÃ©dier Ã  cela, la surcharge permet de ne crÃ©er quâ€™un seul nom de fonction pour deux fonctions diffÃ©rentes. Ainsi, vous pourrez appeler votre fonction de produit scalaire indiffÃ©remment avec des vecteurs 2D ou 3D :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2Â a,Â b;
</span></span><span class=line><span class=cl>vec3Â x,Â y;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>floatÂ resultat1Â =Â produitScalaire(a,Â b);
</span></span><span class=line><span class=cl>floatÂ resultat2Â =Â produitScalaire(x,Â y);
</span></span></code></pre></td></tr></table></div></div><p>Cela Ã©vite de crÃ©er 36 noms de fonctions juste parce que le nombre et/ou le type de leur(s) paramÃ¨tre(s) change. Nous pouvons aussi imaginer une fonction qui pourrait travailler aussi bien sur des entiers (<strong>int</strong>) que sur des flottants (<strong>float</strong>), dans ce cas la surcharge serait Ã©galement utile.</p><a href=#surcharger-une-fonction><h3 id=surcharger-une-fonction><span class=hanchor arialabel=Anchor># </span>Surcharger une fonction</h3></a><p>Nous allons prendre lâ€™exemple du produit scalaire, qui est un trÃ¨s bon exemple. Voici une fonction qui calcule le produit scalaire de deux vecteurs 3D :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ produitScalaire(vec3Â a,Â vec3Â b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â floatÂ resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ calculÂ leÂ produitÂ scalaireÂ (3D)
</span></span><span class=line><span class=cl>Â Â Â Â resultatÂ =Â (a.xÂ *Â b.x)Â +Â (a.yÂ *Â b.y)Â +Â (a.zÂ *Â b.z);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ retourneÂ leÂ resultat
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ resultat;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Notez que les parenthÃ¨ses dans le calcul du produit scalaire sont facultatives dans la mesure oÃ¹ * a la prioritÃ© sur +, elles ne sont prÃ©sentes que pour une meilleure lisibilitÃ©.</p><p>Maintenant, nous voudrions que cette fonction marche aussi pour les vecteurs Ã  2 dimensions. En fait, il nâ€™y a pas de secret : il faut re-Ã©crire la fonction en entier. Ce quâ€™accepte le GLSL, contrairement au C, câ€™est dâ€™avoir plusieurs fonctions du mÃªme nom, qui ne se diffÃ©rencient que par leurs paramÃ¨tres et/ou leur type respectif.</p><p>Ainsi, pour surcharger notre fonction produitScalaire(), il nous suffit de rajouter une version de notre fonction qui calculera le produit scalaire de deux vecteurs 2D, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ produitScalaire(vec2Â a,Â vec2Â b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â floatÂ resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ calculÂ leÂ produitÂ scalaireÂ (2D)
</span></span><span class=line><span class=cl>Â Â Â Â resultatÂ =Â (a.xÂ *Â b.x)Â +Â (a.yÂ *Â b.y);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ retourneÂ leÂ resultat
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ resultat;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>On nâ€™oubliera pas de rajouter un prototype en haut de notre code pour chaque version de notre fonction.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ produitScalaire(vec3,Â vec3);
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec2,Â vec2);
</span></span></code></pre></td></tr></table></div></div><a href=#exemple-complet><h3 id=exemple-complet><span class=hanchor arialabel=Anchor># </span>Exemple complet</h3></a><p>Je vous propose un petit vertex shader tout simple pour illustrer tout ce que nous venons de voir, afin que vous sachiez comment emballer tout Ã§a dans un joli code tout propre tout fini :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//Â prototypesÂ deÂ nosÂ fonctions
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec4,Â vec4);
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec3,Â vec3);
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec2,Â vec2);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â //Â ilÂ estÂ aussiÂ possibleÂ d&#39;accederÂ auxÂ composantesÂ d&#39;unÂ vecteurÂ enÂ utilisant
</span></span><span class=line><span class=cl>Â Â Â Â //Â lesÂ nomsÂ r,Â gÂ ouÂ b,Â pourÂ red,Â greenÂ etÂ blueÂ respectivement
</span></span><span class=line><span class=cl>Â Â Â Â 
</span></span><span class=line><span class=cl>Â Â Â Â //Â calculsÂ auÂ hasard,Â pourÂ donnerÂ unÂ effetÂ rigolo
</span></span><span class=line><span class=cl>Â Â Â Â gl_FrontColor.bÂ =Â produitScalaire(gl_Color,Â gl_Vertex);
</span></span><span class=line><span class=cl>Â Â Â Â gl_FrontColor.gÂ =Â produitScalaire(gl_Color,Â gl_VertexÂ *Â 2.0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_Vertex;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Â versionÂ 4D
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec4Â a,Â vec4Â b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â floatÂ resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ calculÂ leÂ produitÂ scalaireÂ (3D)
</span></span><span class=line><span class=cl>Â Â Â Â resultatÂ =Â (a.xÂ *Â b.x)Â +Â (a.yÂ *Â b.y)Â +Â (a.zÂ *Â b.z);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ retourneÂ leÂ resultat
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ resultat;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Â versionÂ 3D
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec3Â a,Â vec3Â b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â floatÂ resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ calculÂ leÂ produitÂ scalaireÂ (3D)
</span></span><span class=line><span class=cl>Â Â Â Â resultatÂ =Â (a.xÂ *Â b.x)Â +Â (a.yÂ *Â b.y)Â +Â (a.zÂ *Â b.z);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ retourneÂ leÂ resultat
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ resultat;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Â versionÂ 2D
</span></span><span class=line><span class=cl>floatÂ produitScalaire(vec2Â a,Â vec2Â b)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â floatÂ resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ calculÂ leÂ produitÂ scalaireÂ (2D)
</span></span><span class=line><span class=cl>Â Â Â Â resultatÂ =Â (a.xÂ *Â b.x)Â +Â (a.yÂ *Â b.y);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â //Â onÂ retourneÂ leÂ resultat
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ resultat;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Je vous avoue cependant que ce vertex shader ne fait rien de gÃ©nial, il ne sert quâ€™Ã  vous montrer lâ€™implÃ©mentation complÃ¨te dâ€™une fonction en GLSL.</p><hr><a href=#quelques-fonctions-natives-du-glsl><h1 id=quelques-fonctions-natives-du-glsl><span class=hanchor arialabel=Anchor># </span>Quelques fonctions natives du GLSL</h1></a><p>Le langage GLSL offre par dÃ©faut de nombreuses fonctions. Parmi ces fonctions, on retrouve beaucoup de fonctions mathÃ©matiques qui permettent de calculer Ã  peu prÃ¨s tout et nâ€™importe quoi, mais on retrouve aussi des fonctions indispensables effectuant des tÃ¢ches bien prÃ©cises propres aux shaders.</p><p>Tout dâ€™abord, vous devez savoir que la plupart des fonctions du GLSL sont surchargÃ©es, ce qui facilite leur utilisation, qui devient alors intuitive et un vrai jeu dâ€™enfant. Pour faire simple, je vous prÃ©viens dâ€™avance : toutes les fonctions que je vais vous prÃ©senter sont surchargÃ©es, donc utilisez-les Ã  volontÃ© et dans toutes les circonstances. De plus, lâ€™usage des fonctions prÃ©dÃ©finies du GLSL est <strong>fortement recommandÃ©</strong> dans la mesure oÃ¹ la plupart de celles-ci sont directement implantÃ©es dans les cartes graphique, ce qui vous permet de tirer parti de toute la puissance de vos cartes et ainsi gagner en performance.</p><a href=#fonctions-de-manipulation-de-vecteurs><h2 id=fonctions-de-manipulation-de-vecteurs><span class=hanchor arialabel=Anchor># </span>Fonctions de manipulation de vecteurs</h2></a><p>Pour comprendre la plupart des fonctions que nous allons Ã©tudier ici, je vous recommande la lecture du
<a href=http://www.siteduzero.com/tuto-3-18391-1-les-vecteurs.html rel=noopener>chapitre annexe sur les vecteurs</a>.</p><a href=#normalisation-de-vecteurs><h3 id=normalisation-de-vecteurs><span class=hanchor arialabel=Anchor># </span>Normalisation de vecteurs</h3></a><p>Le langage GLSL offre une fonction permettant de normaliser un vecteur. Cette fonction sâ€™appelle <em>normalize()</em>. Elle prend un paramÃ¨tre (un vecteur) et renvoie ce mÃªme vecteur, mais normalisÃ©. Voici un code pour illustrer la normalisation dâ€™un vecteur <em>v</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â vÂ =Â vec3(0.2,Â 0.4,Â 0.6);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vÂ =Â normalize(v);
</span></span></code></pre></td></tr></table></div></div><a href=#produit-scalaire><h3 id=produit-scalaire><span class=hanchor arialabel=Anchor># </span>Produit scalaire</h3></a><p>Pour calculer le produit scalaire de deux vecteurs en GLSL, rien de plus simple : appelez la fonction <em>dot()</em>. Cette fonction prend deux paramÃ¨tres. Ces paramÃ¨tres sont les deux vecteurs dont on veut connaÃ®tre le produit scalaire. <em>dot()</em> renvoie un flottant qui nâ€™est autre que le rÃ©sultat du produit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â v1Â =Â ...,Â v2Â =Â ...;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>floatÂ resÂ =Â dot(v1,Â v2);
</span></span></code></pre></td></tr></table></div></div><a href=#produit-vectoriel><h3 id=produit-vectoriel><span class=hanchor arialabel=Anchor># </span>Produit vectoriel</h3></a><p>LÃ  encore, une fonction existe, il sâ€™agit de <em>cross()</em>. Elle prend deux vecteurs en paramÃ¨tres, et renvoie un vecteur qui est le rÃ©sultat du produit vectoriel de ses deux paramÃ¨tres :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â v1Â =Â ...,Â v2Â =Â ...;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>vec3Â resÂ =Â cross(v1,Â v2);
</span></span></code></pre></td></tr></table></div></div><a href=#longueur-dun-vecteur><h3 id=longueur-dun-vecteur><span class=hanchor arialabel=Anchor># </span>Longueur dâ€™un vecteur</h3></a><p>Pour connaÃ®tre la longueur dâ€™un vecteur simplement, utilisez la fonction <em>length()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ longueurÂ =Â length(Â vec3(2.0,Â 0.8,Â 1.6)Â );
</span></span></code></pre></td></tr></table></div></div><a href=#distance-entre-deux-vecteurs><h3 id=distance-entre-deux-vecteurs><span class=hanchor arialabel=Anchor># </span>Distance entre deux vecteurs</h3></a><p>Bien que cette solution soit envisageable :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â a,Â b;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>floatÂ dÂ =Â length(Â aÂ -Â bÂ );
</span></span></code></pre></td></tr></table></div></div><p>Il en existe une plus explicite : utiliser la fonction <em>distance()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â a,Â b;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>floatÂ dÂ =Â distance(Â a,Â bÂ );
</span></span></code></pre></td></tr></table></div></div><p>Et voilÃ , Ã§a sera tout pour les fonctions de manipulation de vecteurs :)</p><p>En ce qui concerne les additions/soustractions de vecteurs, rappelez-vous le prÃ©cÃ©dent chapitre : les opÃ©rateurs en GLSL sont surchargÃ©s, par consÃ©quent, vous nâ€™aurez quâ€™Ã  placer lâ€™opÃ©rateur de votre choix entre deux vecteurs, ou entre un vecteur et une valeur.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3Â v1Â =Â ...,Â v2Â =Â ...;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vec3Â addÂ =Â v1Â +Â v2;Â Â //Â addÂ =Â leÂ resultatÂ deÂ l&#39;additionÂ desÂ vecteursÂ v1Â etÂ v2
</span></span><span class=line><span class=cl>vec3Â mulÂ =Â v1Â *Â 2.0;Â //Â chaqueÂ composanteÂ deÂ mulÂ =Â chaqueÂ composanteÂ deÂ v1Â *Â 2
</span></span></code></pre></td></tr></table></div></div><a href=#la-fonction-ftransform><h2 id=la-fonction-ftransform><span class=hanchor arialabel=Anchor># </span>La fonction <em>ftransform()</em></h2></a><p>Voici une fonction qui est souvent utilisÃ©e par les programmeurs pourâ€¦ se faciliter la vie. Notez bien quâ€™elle nâ€™est utilisable quâ€™au sein dâ€™un vertex shader. Souvenez-vous lorsque vous avez crÃ©Ã© votre premier vertex shader lors du prÃ©cÃ©dent chapitre. Vous aviez attribuÃ© Ã  la variable de sortie <em>gl_Position</em> le rÃ©sultat de la multiplication de la position du sommet par les matrices modelview et projection combinÃ©es. Voici quel Ã©tait le code final du vertex shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â gl_ModelViewProjectionMatrixÂ *Â gl_Vertex;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ce code est plutÃ´t lourd et long Ã  coder. Il est cependant remplaÃ§able par celui-ci, qui a lâ€™avantage dâ€™Ãªtre beaucoup plus lÃ©ger :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>Â Â Â Â gl_PositionÂ =Â ftransform();
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Vous me demanderez sans doute quel est lâ€™intÃ©rÃªt de la premiÃ¨re mÃ©thode, ce Ã  quoi je vous rÃ©pondrai : quel est lâ€™intÃ©rÃªt de la seconde vous voulez dire ? En fait la fonction <em>ftransform()</em> a pour effet de vous rendre la position finale du sommet comme si il avait Ã©tÃ© traitÃ© par le FFP.</p><a href=#encore-quelques-fonctions><h2 id=encore-quelques-fonctions><span class=hanchor arialabel=Anchor># </span>Encore quelques fonctions</h2></a><p>Je vous montre encore quelques fonctions, et aprÃ¨s câ€™est bon, je vous aurai montrÃ© le principal (fonctions les plus utilisÃ©es).</p><p>Nous allons voir trois fonctions trÃ¨s simples, mais trÃ¨s pratiques :</p><ul><li><p><em>min()</em> ;</p></li><li><p><em>max()</em> ;</p></li><li><p><em>clamp()</em>.</p></li></ul><a href=#min><h3 id=min><span class=hanchor arialabel=Anchor># </span>min()</h3></a><p>Cette fonction renvoie la plus petite valeur entre deux valeurs fournises :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>floatÂ aÂ =Â 0.2,Â bÂ =Â 0.5;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>floatÂ resÂ =Â min(a,Â b);
</span></span></code></pre></td></tr></table></div></div><p>Ici, <em>res</em> = <strong>0.2</strong></p><p>Notez que cette fonction peut Ãªtre remplacÃ©e par lâ€™instruction suivante (comme en C) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(aÂ &lt;Â b)Â ?Â aÂ :Â b;
</span></span></code></pre></td></tr></table></div></div><p>Tout comme de nombreuses fonctions, <em>min()</em> est surchargÃ©e, vous pouvez donc lui envoyer des vecteurs, elle vous renverra le plus court.</p><a href=#max><h3 id=max><span class=hanchor arialabel=Anchor># </span>max()</h3></a><p>Exactement lâ€™inverse de <em>min()</em>, <em>max()</em> vous renvoie son plus grand paramÃ¨tre :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>intÂ resÂ =Â max(2,Â 4);Â //Â resÂ =Â 4
</span></span></code></pre></td></tr></table></div></div><p>Elle est bien Ã©videmment elle aussi surchargÃ©e.</p><a href=#clamp><h3 id=clamp><span class=hanchor arialabel=Anchor># </span>clamp()</h3></a><p>La fonction <em>clamp()</em> est un mÃ©lange des deux fonctions vues ci-dessus, elle prend trois paramÃ¨tres :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>TÂ clamp(TÂ var,Â TÂ minimum,Â TÂ maximum);
</span></span></code></pre></td></tr></table></div></div><p>Lâ€™emploi de â€˜Tâ€™ reprÃ©sente juste un type quelconque.</p><p>et renvoie ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>min(max(var,Â minimum),Â maximum);
</span></span></code></pre></td></tr></table></div></div><p>Euh, jâ€™ai rien compris, câ€™est normal ?</p><p>Oui, rassurez-vous :D</p><p>En fait, la fonction <em>clamp()</em> vous renvoie une valeur qui se situe forcÃ©ment entre <em>minimum</em> et <em>maximum</em>. <em>clamp()</em> renvoie <em>var</em> si sa valeur est situÃ©e entre <em>minimum</em> et <em>maximum</em>, sinon elle renvoie la valeur la plus proche de <em>var</em> (<em>minimum</em> ou <em>maximum</em>).</p><p>Nous pouvons programmer <em>clamp()</em> comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if(minimumÂ &gt;Â var)
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ minimum;
</span></span><span class=line><span class=cl>elseÂ if(upÂ &lt;Â var)
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ maximum;
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>Â Â Â Â returnÂ var;
</span></span></code></pre></td></tr></table></div></div><a href=#spÃ©cifications-du-glsl><h2 id=spÃ©cifications-du-glsl><span class=hanchor arialabel=Anchor># </span>SpÃ©cifications du GLSL</h2></a><p>La version du langage Ã©tudiÃ© dans ce tutoriel possÃ¨de
<a href=http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf rel=noopener>des spÃ©cifications</a> que vous trouverez sur le site dâ€™OpenGL. Ceci est la documentation de rÃ©fÃ©rence et votre meilleur guide dans lâ€™avenir pour lâ€™apprentissage du GLSL.</p><p>Je reconnais que ce chapitre avait un aspect â€œbourrage de crÃ¢neâ€, mais il vous sera sÃ»rement plus utile que vous ne le pensez. En effet, mine de rien nous avons appris beaucoup de choses trÃ¨s pratiques :</p><ul><li><p>les instructions de contrÃ´le, et les incompatibilitÃ©s avec le C ;</p></li><li><p>les fonctions et la surcharge des fonctions ;</p></li><li><p>quelques fonctions du GLSL, que nous utiliserons frÃ©quemment.</p></li></ul><p>Maintenant que vous connaissez le langage GLSL, vous devriez Ãªtre aptes Ã  comprendre un code source quelconque, sauf bien sÃ»r si celui-ci comporte des fonctions du GLSL qui vous sont inconnues.</p><hr><a href=#communiquer-avec-lapplication--attributs-et--uniforms-><h1 id=communiquer-avec-lapplication--attributs-et--uniforms-><span class=hanchor arialabel=Anchor># </span>Communiquer avec lâ€™application : attributs et Â« uniforms Â»</h1></a><p>Bienvenue dans la seconde partie de ce tutoriel consacrÃ© aux shaders en GLSL ! :)</p><p>Nous allons la commencer sans plus tarder en abordant deux faÃ§ons de <strong>transmettre</strong> des informations au shader, Ã  partir de lâ€™application. Ces deux faÃ§ons sont relativement simples Ã  mettre en Å“uvre, et puisquâ€™elles font intervenir toutes les deux des exemples en langage C (langage utilisÃ© pour notre application), jâ€™ai dÃ©cidÃ© de les fusionner dans un seul chapitre.</p><ul><li><p>Nous allons tout dâ€™abord Ã©tudier les variables de type <strong>uniform</strong>. Ce type de variable du GLSL vous permettra de recevoir des variables provenant de lâ€™application. Vous pourrez ainsi changer dynamiquement la valeur dâ€™une variable au sein du shader, lorsque votre application sera en cours.</p></li><li><p>Nous apprendrons ensuite Ã  utiliser les <strong>attributs</strong> de sommet. Ce sont en fait des informations qui sont diffÃ©rentes pour chaque sommet, un peu comme la couleur ou la position ;) Cela nous permettra de rajouter des donnÃ©es Ã  nos sommets.</p></li></ul><a href=#les-variables-de-type-uniform><h2 id=les-variables-de-type-uniform><span class=hanchor arialabel=Anchor># </span>Les variables de type uniform</h2></a><a href=#principe><h2 id=principe><span class=hanchor arialabel=Anchor># </span>Principe</h2></a><p>Lâ€™idÃ©e est simple : envoyer une variable de lâ€™application au shader. En rÃ©alitÃ© ce nâ€™est pas un vÃ©ritable envoi, mais plutÃ´t une copie de valeur. Nous allons pour cela crÃ©er une variable dans notre shader, en lui assignant un type particulier, puis, Ã  partir de notre application, localiser cette variable dans notre shader pour y demander la copie dâ€™une valeur.</p><p>Vous pouvez bien sÃ»r transmettre diffÃ©rents types de variables, comme des entiers, des flottants, des boolÃ©ens, des vecteurs et mÃªme des matrices.</p><a href=#le-type--uniform-><h1 id=le-type--uniform-><span class=hanchor arialabel=Anchor># </span>Le type Â« uniform Â»</h1></a><p>Dans un shader, pour crÃ©er des variables capables de recevoir leur valeur Ã  partir de lâ€™application appelante, il faut les rendre <strong>globales</strong> et leur assigner le prÃ©fixe <strong>uniform</strong>.</p><p>Rendre une variable globale ? o_O</p><p>Cela veut dire, comme en C, rendre une variable accessible par tout le programme. CrÃ©er une variable globale en GLSL revient Ã  faire ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>intÂ variable;Â //Â &#39;variable&#39;Â estÂ globale
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>voidÂ main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Â Â Â Â ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>Et le type Â« uniform Â» dans tout Ã§a ?</p><p>Il vient se placer devant le type de la variable, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniformÂ intÂ variable;
</span></span></code></pre></td></tr></table></div></div><p>DÃ©clarer une variable avec <strong>uniform</strong> revient Ã  dire : â€œje veux que la valeur de cette variable soit indiquÃ©e par mon applicationâ€. Et voilÃ , câ€™est tout ce quâ€™on aura Ã  faire dans notre shader pour indiquer Ã  OpenGL les variables dont la valeur proviendra de lâ€™application :)</p><a href=#implÃ©mentation-cÃ´tÃ©-api><h2 id=implÃ©mentation-cÃ´tÃ©-api><span class=hanchor arialabel=Anchor># </span>ImplÃ©mentation cÃ´tÃ© API</h2></a><a href=#une-affaire-didentifiants><h3 id=une-affaire-didentifiants><span class=hanchor arialabel=Anchor># </span>Une affaire dâ€™identifiants</h3></a><p>Dites donc, on dirait quâ€™ils aiment bien les identifiants chez OpenGL :D Avant de pouvoir transmettre une valeur Ã  une variable de notre shader, il est important de prÃ©ciser Ã  OpenGL quelle variable recevra la valeur.</p><p>Ben, câ€™est celle quâ€™on a crÃ©Ã©e avant avec uniform non ?</p><p>Eh bien non, pas forcÃ©ment, car il est possible de crÃ©er plusieurs variables uniform dans un mÃªme shader. Si par exemple vous en crÃ©ez deux, comment OpenGL saura Ã  quelle variable il doit transmettre la valeur ? Il est donc important de rÃ©cupÃ©rer lâ€™ID de notre variable avant de lui envoyer une valeur.</p><a href=#rÃ©cupÃ©rer-un-id><h3 id=rÃ©cupÃ©rer-un-id><span class=hanchor arialabel=Anchor># </span>RÃ©cupÃ©rer un ID</h3></a><p>Il nâ€™existe pas 36 faÃ§ons de localiser une variable dans un shader (et nâ€™importe oÃ¹ dâ€™ailleursâ€¦), il va falloir donner Ã  OpenGL le nom de notre variable, pour quâ€™il nous retourne son identifiant, nous nous servirons ensuite de celui-ci pour envoyer une valeur Ã  notre variable.</p><p>Voici la fonction OpenGL permettant de rÃ©cupÃ©rer lâ€™ID dâ€™une variable dans un shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint glGetUniformLocation(GLuint program, const char *nom);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>program</strong></em> : câ€™est lâ€™identifiant du program tout entier dans lequel on voudra rechercher la variable.</p></li><li><p><em><strong>nom</strong></em> : le nom de la variable dont on veut rÃ©cupÃ©rer lâ€™identifiant.</p></li></ul><p>Attention : si vous crÃ©ez une variable uniform qui a le mÃªme nom dans le vertex et le pixel shader, les deux variables seront affectÃ©es par la valeur que vous spÃ©cifierez.</p><p>La valeur retournÃ©e par cette fonction est lâ€™identifiant de votre variable de shader nommÃ©e <em>â€œnomâ€</em>, si la fonction nâ€™a pas trouvÃ© votre variable, ou quâ€™elle a Ã©chouÃ© pour une raison x ou y, elle renvoie -1.</p><p>Dans quelle mesure cette fonction peut â€œÃ©chouerâ€ ?</p><p>Si votre program nâ€™a pas Ã©tÃ© liÃ© par exemple, rappelez-vous dans le second chapitre de la fonction <em>glLinkProgram()</em>.</p><a href=#assigner-une-valeur><h3 id=assigner-une-valeur><span class=hanchor arialabel=Anchor># </span>Assigner une valeur</h3></a><p>Nous voici enfin parvenus Ã  lâ€™Ã©tape finale : lâ€™envoi dâ€™une valeur Ã  la variable de notre shader :)</p><p>Pour cela, nous avons besoin de 3 choses :</p><ol><li><p>lâ€™identifiant de notre variable, rÃ©cupÃ©rÃ© avec <em>glGetUniformLocation()</em> ;</p></li><li><p>une valeur Ã  attribuer Ã  cette variable ;</p></li><li><p>et surtout, que notre program ait Ã©tÃ© dÃ©fini comme actif pour le rendu, câ€™est-Ã -dire activÃ© via <em>glUseProgram()</em> !</p></li></ol><p>La derniÃ¨re condition est trÃ¨s importante, si votre program nâ€™a pas Ã©tÃ© activÃ©, une erreur OpenGL de type GL_INVALID_OPERATION sera levÃ©e.</p><p>Les erreurs OpenGL sont rÃ©cupÃ©rables via la fonction <em>glGetError()</em>, et peuvent Ãªtre transformÃ©es en chaÃ®nes de caractÃ¨res avec <em>gluErrorString()</em> comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const char *err = gluErrorString(glGetError());
</span></span></code></pre></td></tr></table></div></div><p>Allez, il est temps que je vous prÃ©sente la fonction permettant dâ€™envoyer une valeur Ã  une variable de notre shader :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUniform*(GLint id, TYPE val);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>id</strong></em> : câ€™est lâ€™ID de notre variable, rÃ©cupÃ©rÃ© via <em>glGetUniformLocation()</em>.</p></li><li><p><em><strong>val</strong></em> : la valeur que lâ€™on souhaite envoyer Ã  notre variable.</p></li></ul><p>Cette fonction agit directement sur le program actif, dâ€™oÃ¹ la nÃ©cessitÃ© de lâ€™avoir activÃ© au prÃ©alable avec <em>glUseProgram()</em>.</p><p>Lorsque <em>glUniform</em>()* est appelÃ©e, la variable dÃ©signÃ©e par lâ€™identifiant prend alors la valeur demandÃ©e, et garde cette valeur jusquâ€™Ã  ce que le program soit Ã  nouveau liÃ© ou supprimÃ©. Par consÃ©quent, si vous souhaitez envoyer une valeur constante (un paramÃ¨tre de dÃ©marrage par exemple), nâ€™invoquez <em>glUniform</em>()*quâ€™une seule fois.</p><a href=#les-diffÃ©rentes-formes-de-gluniform><h2 id=les-diffÃ©rentes-formes-de-gluniform><span class=hanchor arialabel=Anchor># </span>Les diffÃ©rentes formes de <em>glUniform</em>()*</h2></a><p>Comme vous lâ€™aurez remarquÃ©, jâ€™ai mis une petite Ã©toile Â« * Â» au nom de la fonction, câ€™est pour dire quâ€™elle a Ã©tÃ© dÃ©finie sous plusieurs formes, comme pour les fonctions <em>glVertex</em>()<em>, <em>glTexCoord</em>()</em>, etcâ€¦ Cela permet dâ€™envoyer diffÃ©rents types de variables, comme je lâ€™ai dit plus haut ; des vecteurs, des matrices, etcâ€¦</p><a href=#envoi-dune-simple-variable><h3 id=envoi-dune-simple-variable><span class=hanchor arialabel=Anchor># </span>Envoi dâ€™une simple variable</h3></a><p>La fonction <em>glUniform</em>()* a Ã©tÃ© dÃ©finie sous de nombreuses formes. Toutefois, le nombre de types de variable quâ€™elle supporte est toujours limitÃ© Ã  deux :</p><ul><li><p>les entiers (<strong>int</strong>) ;</p></li><li><p>les flottants (<strong>float</strong>).</p></li></ul><p>Du cÃ´tÃ© du GLSL, nous remarquons la prÃ©sence dâ€™un type supplÃ©mentaire : le type <strong>bool</strong>. Rassurez-vous cependant, vous pourrez affecter une variable <strong>bool</strong> en passant par la forme entiÃ¨re de <em>glUniform</em>()*.</p><p>Voici un premier exemple de code illustrant le simple envoi dâ€™une variable Ã  notre program nommÃ© <em>prog</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniformÂ intÂ var;Â //Â n&#39;oublionsÂ pasÂ deÂ declarerÂ &#39;var&#39;Â globale
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(prog, &#34;var&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(prog);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre variable (ici nous envoyons la valeur 2) */
</span></span><span class=line><span class=cl>glUniform1i(id, 2);
</span></span></code></pre></td></tr></table></div></div><p>Notez quâ€™il nâ€™est pas obligatoire de rÃ©cupÃ©rer lâ€™identifiant Ã  chaque fois que vous voudrez envoyer une valeur Ã  une variable de votre shader, lâ€™ID est invariable, sauf si vous liez Ã  nouveau votre program. Donc, dans la mesure oÃ¹ la recherche dâ€™un identifiant est plutÃ´t lourde (analyse dâ€™une chaÃ®ne de caractÃ¨res), on essayera si possible de stocker au prÃ©alable tous les identifiants dans des variables.</p><a href=#envoi-dun-simple-vecteur><h3 id=envoi-dun-simple-vecteur><span class=hanchor arialabel=Anchor># </span>Envoi dâ€™un simple vecteur</h3></a><p>Si vous voulez envoyer un vecteur Ã  3 dimensions (par exemple) Ã  votre shader, vous pouvez faire comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniformÂ vec3Â vecteur;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;vecteur&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre vecteur */
</span></span><span class=line><span class=cl>glUniform3f(id, 1.7, 5.2, 3.6);
</span></span></code></pre></td></tr></table></div></div><p>Cette mÃ©thode peut poser un petit problÃ¨me ; elle est plutÃ´t â€œlourdeâ€ et peut flexible, il faut spÃ©cifier chaque composante du vecteur une par une, et si lâ€™on souhaite subitement envoyer un vecteur Ã  deux dimensions Ã  la place, il faudra non seulement changer le nom de la fonction, mais aussi le nombre de ses paramÃ¨tres. Pour remÃ©dier Ã  ce problÃ¨me, vous pouvez utiliser la version vectorielle de <em>glUniform</em>()*.</p><a href=#Ã©tude-de-la-version-vectorielle-de-gluniform><h3 id=Ã©tude-de-la-version-vectorielle-de-gluniform><span class=hanchor arialabel=Anchor># </span>Ã‰tude de la version vectorielle de glUniform*()</h3></a><p>Afin dâ€™envoyer un groupe de donnÃ©es (comme un vecteur), la fonction <em>glUniform</em>v()* vous propose de lui spÃ©cifier un pointeur vers ces donnÃ©es. De plus, elle bÃ©nÃ©ficie dâ€™un nouveau paramÃ¨tre :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUniform*v(GLint id, GLsizei count, TYPE *val);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>id</strong></em> : â€¦</p></li><li><p><em><strong>count</strong></em> : nombre de groupes de donnÃ©es.</p></li><li><p><em><strong>val</strong></em> : â€¦</p></li></ul><p>Voyons tout dâ€™abord comment modifier le code prÃ©cÃ©dent pour spÃ©cifier la valeur de notre vecteur par le biais dâ€™un tableau :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniformÂ vec3Â vecteur;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* le vecteur que l&#39;on veut envoyer en parametre */
</span></span><span class=line><span class=cl>float vec[3] = {1.7, 5.2, 3.6};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;vecteur&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre vecteur */
</span></span><span class=line><span class=cl>glUniform3fv(id, 1, vec);
</span></span></code></pre></td></tr></table></div></div><p>Vous pouvez voir ici que jâ€™ai spÃ©cifiÃ© le paramÃ¨tre <em>count</em> de <em>glUniform</em>v()* Ã  la valeur 1. Cela veut dire que jâ€™ai souhaitÃ© envoyer <strong>un</strong> vecteur, un vecteur Ã  <strong>3</strong> composantes ( <em>glUniform<strong>3</strong>fv()</em> ). En effet, le chiffre contenu dans le nom de la fonction <em>glUniform</em>()* (qui peut varier de 1 Ã  4 inclus) nous informe du type de la variable GLSL (nombre de composantes du vecteur), et par consÃ©quent du nombre de donnÃ©es que la fonction <em>glUniform</em>()* va aller chercher dans notre pointeur.</p><p>Donc : faites bien attention aux dÃ©bordements mÃ©moire. Mais attendez, vous nâ€™avez pas encore tout vu. Eh bien oui ; quâ€™advient-il de notre paramÃ¨tre <em>count</em> ? Il ne faut pas lâ€™oublier.</p><p>Le paramÃ¨tre <em>count</em> vient complexifier la chose en vous permettant dâ€™envoyer des tableaux de vecteurs. Avec ce paramÃ¨tre, vous allez pouvoir spÃ©cifier le nombre de vecteurs que contient votre tableau. Prenons tout de suite un exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniformÂ vec3Â vecteurs[2];Â //Â tableauÂ deÂ deuxÂ vecteurs
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* les vecteurs que l&#39;on veut envoyer en parametre */
</span></span><span class=line><span class=cl>float vecs[2][3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    {0.8, 2.1, 1.3},
</span></span><span class=line><span class=cl>    {1.9, 3.2, 1.7}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;vecteurs&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie nos deux vecteurs */
</span></span><span class=line><span class=cl>glUniform3fv(id, 2, vecs);
</span></span></code></pre></td></tr></table></div></div><p>Comme vous le voyez, cÃ´tÃ© GLSL vous pouvez remarquer que jâ€™ai crÃ©Ã© un tableau de vecteurs, tout comme je lâ€™ai fait dans lâ€™exemple en C. Jâ€™ai Ã©galement placÃ© le paramÃ¨tre <em>count</em> Ã  la valeur <strong>2</strong> dans <em>glUniform</em>v()*, pour indiquer que je souhaite envoyer <strong>deux</strong> vecteurs.</p><p>**Prenez garde :***glUniform<em>v()</em> attend une suite de donnÃ©es, donc un tableau ou un tableau de tableaux, mais en aucun cas un pointeur de pointeurs ! La solution suivante est envisageable et produira le mÃªme effet :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float vec[2*3] = {0.8, 2.1, 1.3, 1.9, 3.2, 1.7};
</span></span></code></pre></td></tr></table></div></div><p>Au final, le nombre de variables qui seront lues dans votre tableau sera Ã©gal au chiffre du nom de la fonction <em>glUniform</em>v()* multipliÃ© par <em>count</em> (dans notre cas, 2*3).</p><p>Et si je veux envoyer un simple tableau, je fais comment ?</p><p>Invoquez <em>glUniform1</em>v()<em>, elle ira prendre exactement <em>count</em> donnÃ©es dans votre tableau et ira les loger dans votre shader dans un tableau de type <strong>bool</strong>, <strong>int</strong> ou <strong>float</strong>. Eh oui, un vecteur Ã  <strong>une</strong> composante ( <em>glUniform<strong>1</strong></em>v()</em> ) nâ€™est rien dâ€™autre quâ€™une simple variable ;)</p><a href=#et-les-matrices--1><h3 id=et-les-matrices--1><span class=hanchor arialabel=Anchor># </span>Et les matrices ?</h3></a><p>Ã€ partir du moment oÃ¹ vous avez compris le fonctionnement de la version vectorielle de glUniform*(), les matrices vous paraÃ®tront tout aussi simple ; en fait, le principe est identique, sauf quâ€™une matrice a plus de composantes quâ€™un vecteur ;)</p><p>Afin dâ€™envoyer une matrice Ã  votre shader, chose qui risque dâ€™arriver assez rarement dans la mesure oÃ¹ les matrices de projection, de texturage et de visualisation sont dÃ©jÃ  Ã  votre disposition en GLSL, la fonction <em>glUniform</em>()* prend une autreâ€¦ forme :p :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUniformMatrix*fv(GLint id, GLsizei count, GLboolean transpose, const float *val);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>id</strong></em> : â€¦</p></li><li><p><em><strong>count</strong></em> : â€¦</p></li><li><p><em><strong>val</strong></em> : les valeurs doivent Ãªtre contenues dans un pointeur sur des flottants de type <strong>float</strong> ;</p></li><li><p><em><strong>transpose</strong></em> : positionnÃ© Ã  GL_TRUE, les matrices envoyÃ©es seront transposÃ©es avant dâ€™arriver dans le shader.</p></li></ul><p>Comme vous le voyez, cette version laisse moins de libertÃ©s au programmeur, le forÃ§ant Ã  utiliser des matrices codÃ©es sur des flottants de type <strong>float</strong>. Toutefois, elle lui permet :</p><ul><li><p>de spÃ©cifier lâ€™ordre de sa matrice, via le paramÃ¨tre <em>transpose</em> ;</p></li><li><p>dâ€™indiquer la taille de sa matrice, via le nom de la fonction ( <em>glUniformMatrix<strong>2</strong>fv()</em> pour une matrice <strong>2*2</strong>, <em>glUniformMatrix<strong>3</strong>fv()</em> pour une matrice <strong>3*3</strong>, etcâ€¦ ).</p></li></ul><p>Pour plus dâ€™informations sur la transposÃ©e dâ€™une matrice, vous pouvez consulter
<a href="http://jeux.developpez.com/faq/matquat/?page=arithmetique#Q8" rel=noopener>la FAQ de Developpez.com sur les matrices</a>.</p><p>Voici un bref exemple pour illustrer une utilisation possible :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniformÂ mat3Â matrix;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* la matrice que l&#39;on veut envoyer en parametre */
</span></span><span class=line><span class=cl>float mat[3][3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    {1.2, 0.0, 0.0},
</span></span><span class=line><span class=cl>    {0.0, 2.5, 0.0},
</span></span><span class=line><span class=cl>    {0.0, 0.0, 1.0}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;matrix&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre matrice */
</span></span><span class=line><span class=cl>glUniformMatrix3fv(id, 1, 0, mat);
</span></span></code></pre></td></tr></table></div></div><p>Et voilÃ , vous savez tout sur les variables uniform des shaders :) Servez-vous en pour envoyer des informations supplÃ©mentaires, de couleur par exemple, ou bien des donnÃ©es envoyÃ©es par lâ€™utilisateur ; eh oui, aucun dialogue direct nâ€™est possible entre lâ€™utilisateur et le shader, servez-vous donc de votre application comme un tiers.</p><p>Un exemple complet est disponible en tÃ©lÃ©chargement Ã  la fin de ce chapitre.</p><hr><a href=#les-attributs-de-sommet><h2 id=les-attributs-de-sommet><span class=hanchor arialabel=Anchor># </span>Les attributs de sommet</h2></a><a href=#quest-ce-quun-attribut-><h2 id=quest-ce-quun-attribut-><span class=hanchor arialabel=Anchor># </span>Quâ€™est-ce quâ€™un attribut ?</h2></a><p>Comme indiquÃ© Ã  lâ€™introduction de ce chapitre, les <strong>attributs de sommet</strong> sont des donnÃ©es supplÃ©mentaires, diffÃ©rentes pour chaque sommet, Ã  lâ€™instar de la position, de la coordonnÃ©e de texture, etcâ€¦</p><p>Ainsi, les attributs de sommet ne sont accessibles que par les vertex shaders, lÃ  oÃ¹ les informations de sommets sont disponibles en lecture (et en lecture seulement).</p><p>Comment accÃ©der aux attributs de sommet dans le vertex shader ?</p><p>Les donnÃ©es de position du sommet par exemple, sont disponible par dÃ©faut dans une variable du GLSL : <em>gl_Vertex</em>. Pour les attributs de sommet, il va falloir crÃ©er cette variable, mais pas nâ€™importe comment.</p><a href=#le-type--attribute-><h1 id=le-type--attribute-><span class=hanchor arialabel=Anchor># </span>Le type Â« attribute Â»</h1></a><p>Ã€ lâ€™instar des variables uniform, que nous avons vue Ã  lâ€™instant, il va Ã  nouveau falloir attribuer un type diffÃ©rents Ã  nos attributs de sommet. Tout comme les uniform, les attributs doivent Ãªtre des variables globales, mais prÃ©fixÃ©es cette fois-ci avec le mot clÃ© <strong>attribute</strong> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>attributeÂ vec3Â donnee_supplementaire;
</span></span></code></pre></td></tr></table></div></div><p>Ici, jâ€™ai dÃ©cidÃ© de rajouter une variable de type <strong>vec3</strong>. En gros, ce bout de code peut se traduire : Â« <em>je rajoute une donnÃ©e Ã  mes sommets qui seront dessinÃ©s avec ce vertex shader</em> Â».</p><p>Supposons que nous voulions dessiner un triangle, nous allons donc spÃ©cifier trois sommets :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_780_d57889049e1e4cd6b.gif width=auto alt="Image utilisateur"></p><p>Chaque sommet possÃ¨de son lot de donnÃ©es en tout genre : position, normale, couleur, etcâ€¦ Eh bien imaginez que vous vouliez en rajouter ; vous pouvez !</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_780_449f98fe8e5040ef9.gif width=auto alt="Image utilisateur"></p><p>Câ€™est ce qui se passe lorsque vous crÃ©ez une variable avec le type <strong>attribute</strong> :)</p><a href=#cÃ´tÃ©-api><h2 id=cÃ´tÃ©-api><span class=hanchor arialabel=Anchor># </span>CÃ´tÃ© API</h2></a><p>Bien, voyons maintenant comment spÃ©cifier la valeur de ces donnÃ©es en plus que sont les attributs de sommet.</p><p>Globalement, le principe est le mÃªme que pour les variables uniform :</p><ul><li><p>on rÃ©cupÃ¨re lâ€™ID (plus couramment appelÃ© <strong>index</strong> dans le cas des attributs de sommet) de notre attribut ;</p></li><li><p>on sâ€™en sert pour localiser nos attributs et ainsi leur envoyer la valeur de notre choix.</p></li></ul><a href=#rÃ©cupÃ©rer-lindex><h3 id=rÃ©cupÃ©rer-lindex><span class=hanchor arialabel=Anchor># </span>RÃ©cupÃ©rer lâ€™index</h3></a><p>Bon, comme vous avez dÃ©jÃ  pris lâ€™habitude avec les uniforms, je vais aller un peu plus vite dans la pratique. Pour rÃ©cupÃ©rer lâ€™index dâ€™un attribut de sommet dans un shader GLSL, invoquez <em>glGetAttribLocation()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint glGetAttribLocation(GLuint program, const char *name);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>program</strong></em> : dÃ©signe le program dans lequel nous voulons rechercher lâ€™index.</p></li><li><p><em><strong>name</strong></em> : câ€™est le nom de lâ€™attribut dont on souhaite obtenir lâ€™index.</p></li></ul><p>Une fois que nous avons notre index, il nous suffira de le spÃ©cifier Ã  la fonction qui permet de dÃ©finir les valeurs des attributs de sommet, et ces valeurs Ã©tant diffÃ©rentes pour chaque sommet, il nous faudra appeler cette fonction pour chaque sommet que nous dÃ©finirons.</p><a href=#spÃ©cifier-la-valeur-dun-attribut><h3 id=spÃ©cifier-la-valeur-dun-attribut><span class=hanchor arialabel=Anchor># </span>SpÃ©cifier la valeur dâ€™un attribut</h3></a><p>Prenons un exemple ; supposons un triangle, crÃ©Ã© de la faÃ§on suivante avec OpenGL :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span></code></pre></td></tr></table></div></div><p>Avec ce code, nous demandons la crÃ©ation de trois sommets (pour former un triangle). Pour chaque sommet traitÃ©, le vertex shader actif sera invoquÃ© et sa variable <em>gl_Vertex</em> sera affectÃ©e aux valeurs que nous avons spÃ©cifiÃ©es Ã  la fonction <em>glVertex</em>()<em>. Il en va de mÃªme pour chaque variable dâ€™entrÃ©e du vertex shader (couleur, normale, â€¦), y compris son attribut. Ainsi, pour affecter un attribut dâ€™un sommet, il suffit de spÃ©cifier sa valeur pour chaque crÃ©ation de sommet avec la fonction <em>glVertexAttrib</em>()</em>, en spÃ©cifiant bien quel attribut nous souhaitons affecter via son index :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glVertexAttrib3f(index, 0.0, 0.0, 0.0); glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib3f(index, 0.0, 0.0, 0.0); glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib3f(index, 0.0, 0.0, 0.0); glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span></code></pre></td></tr></table></div></div><p>Et voici son prototype :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glVertexAttrib*(GLuint index, TYPE vals);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>index</strong></em> : il sâ€™agit lÃ  de placer lâ€™index que lâ€™on a rÃ©cupÃ©rÃ© avec <em>glGetAttribLocation()</em>.</p></li><li><p><em><strong>vals</strong></em> : ce sont les valeurs auquels on souhaite positionner notre attribut, le nombre de valeurs peut varier de 1 Ã  4 inclus.</p></li></ul><p>La fonction <em>glVertexAttrib</em>()* permet de spÃ©cifier la valeur de lâ€™attribut de chaque sommet, comme vous venez de le voir. Voici un exemple dâ€™utilisation des attributs de sommet :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>attributeÂ floatÂ numero_sommet;Â //Â representeraÂ leÂ numeroÂ duÂ sommet
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* on recupere l&#39;index de notre attribut de sommets */
</span></span><span class=line><span class=cl>int index = glGetAttribLocation(program, &#34;numero_sommet&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on active notre program */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glVertexAttrib1f(index, 0.0); glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib1f(index, 1.0); glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib1f(index, 2.0); glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on desactive les shaders */
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span></code></pre></td></tr></table></div></div><p>Vous noterez que la forme de <em>glVertexAttrib</em>()* utilisÃ©e doit correspondre au type de lâ€™attribut dans le shader, sinon vous risquez de vous retrouver avec une valeur dâ€™attribut erronÃ©e dans votre shader (en gros Ã§a fera comme si vous faisiez un cast GLSL : <em>Attrib = TypeDeAttrib(TypeDeLaFonction)</em> ).</p><p>Je vous conseille dâ€™aller faire un petit tour sur la page de manuel de <em><a href=http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttrib.xml rel=noopener>glVertexAttrib*()</a></em>, vous risquez dâ€™y trouver quelques informations complÃ©mentaires intÃ©ressantes ; cette fonction vous permet notamment de normaliser le vecteur que vous lui envoyez.</p><hr><a href=#les-tableaux-dattributs><h2 id=les-tableaux-dattributs><span class=hanchor arialabel=Anchor># </span>Les tableaux dâ€™attributs</h2></a><p>Si vous connaissez les
<a href=http://www.siteduzero.com/tuto-3-18395-1-les-vertex-arrays.html rel=noopener>vertex arrays</a>, et que vous Ãªtes un flemmard (quelquâ€™un de normal quoi), vous vous Ãªtes probablement demandÃ© : mais existe-t-il une alternative pour envoyer mes attributs de sommets par le biais de tableaux ? Eh bien la rÃ©ponse est oui :)</p><p>Cette section est bien sÃ»r facultative, elle ne vous aidera pas Ã  mieux comprendre le fonctionnement des attributs de sommet, elle est plutÃ´t rÃ©servÃ©e aux connaisseurs des vertex arrays.</p><a href=#activation-des-tableaux-dattributs><h2 id=activation-des-tableaux-dattributs><span class=hanchor arialabel=Anchor># </span>Activation des tableaux dâ€™attributs</h2></a><p>Ã€ lâ€™instar des vertex arrays simples, les tableaux dâ€™attributs ont besoin dâ€™une activation qui leur est propre. Chaque index dâ€™attribut doit Ãªtre activÃ© indÃ©pendamment, car chaque index reprÃ©sente un type de donnÃ©es diffÃ©rent.</p><p>Que quoi ? Hein ??</p><p>Oui, chaque index dâ€™attribut reprÃ©sente un type diffÃ©rent ; la diffÃ©rence quâ€™il y a entre lâ€™index 0 et lâ€™index 1 est la mÃªme quâ€™entre la position dâ€™un sommet et sa normale : ce ne sont pas les mÃªmes donnÃ©es, elles sont identifiÃ©es diffÃ©remment. Je vous conseille dâ€™aller jeter un oeil Ã 
<a href=http://www.siteduzero.com/tuto-3-18395-1-les-vertex-arrays.html#ss_part_1 rel=noopener>ma petite dÃ©finition de ce quâ€™est un sommet</a>, dans mon tutoriel sur les vertex arrays.</p><p>Bien, revenons-en au sujet initial : lâ€™activation. Ã‰tant donnÃ© que chaque type dâ€™attribut est identifiÃ© diffÃ©remment par OpenGL, il va falloir, comme pour chaque type de donnÃ©e dâ€™un sommet, lâ€™activer indÃ©pendamment des autres, et pour cela, il va nous falloir son <strong>index</strong>. Avec la fonction <em>glEnableClientState()</em>, câ€™Ã©tait facile, il nous suffisait de lui donner une constante au nom trivial et facile Ã  retenir, et hop, elle activait le type de vertex array demandÃ©.</p><p>La fonction <em>glEnableVertexAttribArray()</em> quant Ã  elle, demande lâ€™index de lâ€™attribut Ã  activer.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glEnableVertexAttribArray(GLuint index);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>index</strong></em> : câ€™est lâ€™index du type de lâ€™attribut que lâ€™on souhaite activer.</li></ul><p>Avec les shaders GLSL, lâ€™index dâ€™un attribut de sommet se rÃ©cupÃ¨re comme nous lâ€™avons vu plus haut : avec la fonction <em>glGetAttribLocation()</em>. AprÃ¨s vous Ãªtre muni de cet index, vous nâ€™aurez quâ€™Ã  le donner Ã  <em>glEnableVertexAttribArray()</em> pour que nous puissions exploiter les attributs de sommet demandÃ©s :)</p><a href=#envoi-dun-tableau><h2 id=envoi-dun-tableau><span class=hanchor arialabel=Anchor># </span>Envoi dâ€™un tableau</h2></a><p>Allez, je ne vais pas passer par 36 chemins ; ici je considÃ¨re que vous maÃ®trisez un minimum le concept des vertex arrays, je ne mâ€™Ã©talerai donc pas sur les dÃ©tails.</p><p>Afin de spÃ©cifier un tableau dâ€™attributs, utilisez la fonction <em>glVertexAttribPointer()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glVertexAttribPointer(GLuint index, int size, GLenum type, GLboolean norm, GLsizei stride, const void *data);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>size</strong></em>, <em><strong>type</strong></em>, <em><strong>stride</strong></em>, <em><strong>data</strong></em> : rÃ©fÃ©rez-vous Ã  mon tutoriel sur les vertex arrays, ces paramÃ¨tres ont la mÃªme incidence que ceux des autres fonctions <em>gl</em>Pointer()*.</p></li><li><p><em><strong>index</strong></em> : il sâ€™agit dâ€™indiquer ici le type de lâ€™attribut, câ€™est-Ã -dire son index rÃ©cupÃ©rÃ© Ã  lâ€™aide de <em>glGetAttribLocation()</em>.</p></li><li><p><em><strong>norm</strong></em> : positionnÃ© Ã  GL_TRUE, les vecteurs contenus dans votre tableau de donnÃ©es seront normalisÃ©s. Je vous conseille personnellement de laisser ce paramÃ¨tre Ã  0 (ou GL_FALSE), ainsi OpenGL ne touchera pas Ã  vos donnÃ©es.</p></li></ul><p>Comme vous le voyez, cette fonction demande Ã  ce quâ€™on lui fournisse le type dâ€™attribut que reprÃ©sentera le tableau quâ€™on lui envoie.</p><p>Comment Ã§a se fait ? Pourquoi elle a besoin de savoir Ã§a, alors quâ€™on a dÃ©jÃ  donnÃ© lâ€™index lorsquâ€™on a activÃ© les tableaux ?</p><p>Car vous pouvez avoir activÃ© plusieurs tableaux dâ€™attributs Ã  la fois (câ€™est possible sachez-le), il est donc important de spÃ©cifier explicitement quel est le type dâ€™attribut que vous lui envoyez.</p><p>Le reste du fonctionnement est le mÃªme que pour les vertex arrays (les tabeaux dâ€™attributs sont en fait des vertex arrays un peu diffÃ©rents sur certains points) : aprÃ¨s avoir appelÃ© cette fonction, le tableau sera envoyÃ© Ã  la carte graphique pour traitement lorsque vous appelerez une fonction de dessin comme <em>glDrawArrays()</em> ou <em>glDrawElements()</em>.</p><a href=#et-les-vbos-><h3 id=et-les-vbos-><span class=hanchor arialabel=Anchor># </span>Et les VBOs ?</h3></a><p>Ah ! Jâ€™allais les oublier ceux-lÃ . Les tableaux tâ€™attributs ayant un systÃ¨me de fonctionnement identique aux vertex arrays, vous pouvez Ã©galement hÃ©berger vos tableaux dans un VBO, puis utiliser lâ€™adresse 0 avec <em>glVertexAttribPointer()</em> pour spÃ©cifier lâ€™emplacement de votre VBO actif, et utiliser les donnÃ©es directement Ã  partir de la mÃ©moire de la carte graphique.</p><p>Â« VBO Â» ? Avons-nous Ã©tÃ© prÃ©sentÃ©s ?</p><p>Vous ne connaissez pas les VBOs ? Eh bien alors il est grand temps que vous fassiez leur connaissance ! Les VBOs sont un sujet assez vaste, câ€™est pourquoi je vous ai concoctÃ©
<a href=http://www.siteduzero.com/tuto-3-18397-1-les-vertex-buffer-objects.html rel=noopener>un petit tutoriel Ã  leur sujet</a>. Pour faire court ; les VBOs sont une sorte dâ€™amÃ©lioration du systÃ¨me des vertex arrays, ils servent Ã  augmenter considÃ©rablement leur performance (pour peu quâ€™ils soient bien utilisÃ©s) ;)</p><a href=#dÃ©sactivation-des-tableaux-dattributs><h2 id=dÃ©sactivation-des-tableaux-dattributs><span class=hanchor arialabel=Anchor># </span>DÃ©sactivation des tableaux dâ€™attributs</h2></a><p>Je vous lâ€™avais dit que les tableaux dâ€™attributs Ã©taient des vertex arrays :p Un peu diffÃ©rents toutefois, la fonction pour dÃ©sactiver les tableaux dâ€™attributs est la suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glDisableVertexAttribArray(GLuint index);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>index</strong></em> : encore une fois, il est nÃ©cessaire dâ€™indiquer quel type dâ€™attribut on souhaite dÃ©sactiver.</li></ul><a href=#exemple-dutilisation><h2 id=exemple-dutilisation><span class=hanchor arialabel=Anchor># </span>Exemple dâ€™utilisation</h2></a><p>Un petit exemple ne fera pas de mal je pense. Vous vous rappelez de lâ€™exemple qui prÃ©sentait une utilisation possible des attributs de sommet, en spÃ©cifiant les attributs un Ã  un ? Je vous en propose ici lâ€™adaptation qui utilise les tableaux dâ€™attributs :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>attributeÂ floatÂ numero_sommet;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* notre index d&#39;attribut */
</span></span><span class=line><span class=cl>int index;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* tableau des positions */
</span></span><span class=line><span class=cl>float pos[6] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    0.9, -0.9,
</span></span><span class=line><span class=cl>    -0.9, -0.9,
</span></span><span class=line><span class=cl>    0.0, 0.9
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>/* tableau t&#39;attributs */
</span></span><span class=line><span class=cl>float attribs[3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    0.0, 1.0, 2.0
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;index de notre attribut de sommets */
</span></span><span class=line><span class=cl>index = glGetAttribLocation(program, &#34;numero_sommet&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on active les tableaux */
</span></span><span class=line><span class=cl>glEnableClientState(GL_VERTEX_ARRAY);
</span></span><span class=line><span class=cl>glEnableVertexAttribArray(index);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on specifie nos donnees */
</span></span><span class=line><span class=cl>glVertexPointer(2, GL_FLOAT, 0, pos);
</span></span><span class=line><span class=cl>glVertexAttribPointer(index, 1, GL_FLOAT, 0, 0, attribs);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* dessin */
</span></span><span class=line><span class=cl>glDrawArrays(GL_TRIANGLES, 0, 3);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on desactive les tableaux */
</span></span><span class=line><span class=cl>glDisableVertexAttribArray(index);
</span></span><span class=line><span class=cl>glDisableClientState(GL_VERTEX_ARRAY);
</span></span></code></pre></td></tr></table></div></div><p>Ce chapitre touche Ã  sa fin ; nous y avons vu deux mÃ©thodes pour transmettre des informations Ã  nos shaders : lâ€™une oÃ¹ lâ€™on envoyait une â€œsimpleâ€ variable, allant de lâ€™entier Ã  la matrice 4Ã—4, et lâ€™autre oÃ¹ lâ€™on pouvait envoyer des donnÃ©es diffÃ©rentes Ã  chacun de nos sommets.</p><a href=#tÃ©lÃ©chargement><h2 id=tÃ©lÃ©chargement><span class=hanchor arialabel=Anchor># </span>TÃ©lÃ©chargement</h2></a><p>Comme promis, voici un programme exemple, afin que vous voyez comment on peut mÃ©langer efficacement tout ce quâ€™on vient de voir.</p><p><a href=http://yno.goldzoneweb.info/sdz/ch5.zip rel=noopener>TÃ©lÃ©charger lâ€™exemple de code et le makefile Linux.</a></p><p><a href=http://yno.goldzoneweb.info/sdz/ch5-2.zip rel=noopener>TÃ©lÃ©charger lâ€™exemple utilisant les vertex arrays.</a></p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_780_069218cc8e24432ca.gif width=auto alt="Image utilisateur"></p><p><em>Screenshot de lâ€™application exemple.</em></p><p>Comme dâ€™habitude, lâ€™exemple ne prÃ©sente rien dâ€™extraordinaire, toutefois ne vous inquiÃ©tez pas ; nous verrons dans la prochaine partie de ce tutoriel comment rÃ©aliser diffÃ©rents effets graphiques grÃ¢ce aux shaders, afin dâ€™embellir nos scÃ¨nes 3D :)</p><p>Le tuto nâ€™est pas fini, dâ€™autres chapitres/parties sont en cours de rÃ©daction ;)</p><hr><a href=#les-vecteurs><h2 id=les-vecteurs><span class=hanchor arialabel=Anchor># </span>Les vecteurs</h2></a><p>Cette annexe risque dâ€™Ãªtre votre plus grande alliÃ©e si vous voulez rÃ©ellement comprendre le fonctionnement de la plupart des effets que nous Ã©tudierons dans la partie 3. Nous allons ici Ã©tudier ce quâ€™est un vecteur, ce quâ€™est la <strong>normalisation</strong> dâ€™un vecteur, comment on fait le <strong>produit scalaire</strong> de deux vecteurs, comment on fait leur <strong>produit vectoriel</strong>, mais surtout, Ã  quoi tout cela peut servir. Je me doute que vous avez probablement dÃ©jÃ  appris ces concepts Ã  lâ€™Ã©cole, mais vous a-t-on dÃ©jÃ  donnÃ© une utilisation pratique de ces outils mathÃ©matiques forts pratiques que sont les vecteurs ? Non ? Et bien je vais vous en donner une :) Vous verrez, lorsquâ€™on a un objectif, lâ€™apprentissage dâ€™un concept est tout de suite plus simple.</p><a href=#les-vecteurs-notions-de-base><h2 id=les-vecteurs-notions-de-base><span class=hanchor arialabel=Anchor># </span>Les vecteurs, notions de base</h2></a><p>Il est avant-tout important de savoir additionner et soustraire deux vecteurs, ces opÃ©rations trÃ¨s simples sont la base des vecteurs mais on les utilise tout le temps, il est donc important de les maÃ®triser.</p><p>Attention prÃ©parez-vous, car ce chapitre va pleuvoir de schÃ©mas. Je me baserai sur une illustration 2D, mais les calculs que je ferai sont tout Ã  fait appliquables en 3D, et heuresement, car câ€™est notre objectif.</p><a href=#un-vecteur-cest-quoi-><h2 id=un-vecteur-cest-quoi-><span class=hanchor arialabel=Anchor># </span>Un vecteur, câ€™est quoi ?</h2></a><p>Cette section est bien sÃ»r rÃ©servÃ©e aux nÃ©ophytes, si vous savez dÃ©jÃ  ce quâ€™est un vecteur, passez tout de suite au gros titre suivant.</p><p>Vous pouvez comparer un vecteur avec une <strong>direction</strong>. Un vecteur marche aussi bien en 1D, quâ€™en 2D et quâ€™en 3D, les principes sont les mÃªmes.</p><p>Oui mais un vecteur, Ã§a ressemble Ã  quoi ?</p><p>Je vous propose de voir mon premier schÃ©ma, qui illustre un plan 2D et un vecteur dessinÃ© dans ce plan :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_f0a8f712d45045f19.gif width=auto alt="Image utilisateur"></p><p>Cette barre rouge au milieu est un vecteur, comme vous le voyez, elle reprÃ©sente une direction. Ce vecteur v sâ€™Ã©crit comme ceci :</p><p>v(1; 1)</p><p>Le premier chiffre reprÃ©sente la composante x, et le second la composante y. Pour les vecteurs 3D, il y a une 3eme composate : la composante z. Ici notre vecteur peut Ãªtre transformÃ© en vecteur 3D, il aura donc une composante z nulle :</p><p>v(1; 1; 0)</p><p>Puisquâ€™un vecteur reprÃ©sente une direction, on part du principe quâ€™un vecteur commence toujours au point (0; 0).</p><a href=#laddition-de-vecteurs><h2 id=laddition-de-vecteurs><span class=hanchor arialabel=Anchor># </span>Lâ€™addition de vecteurs</h2></a><p>Lâ€™addition de vecteurs sert Ã  obtenir une coordonnÃ©e finale dans lâ€™espace rÃ©sultante de plusieurs vecteurs. Comme lâ€™illustre le schÃ©ma ci-dessous, mes deux vecteurs additionnÃ©s donnent naissance Ã  un 3eme point qui est le rÃ©sultat de lâ€™addition des vecteurs a et b :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_45f0e10445954e96a.gif width=auto alt="Image utilisateur"></p><p>Vous pouvez toujours additionner un vecteur Ã  un autre, et ainsi vous ballader librement dans lâ€™espace, câ€™est un peu le principe qui est utilisÃ© pour les <strong>camÃ©ras</strong> dans les jeux vidÃ©os : la position de la camÃ©ra est reprÃ©sentÃ©e par un vecteur auquel on en additionne dâ€™autres afin de <strong>dÃ©placer</strong> la camÃ©ra.</p><p>Pour additionner deux vecteurs mathÃ©matiquement, on procÃ¨de Ã  lâ€™addition de chaque composante du vecteur a par la mÃªme composante chez le vecteur b :</p><p>a(1; 0) + b(0; 1) = v(1; 1)</p><p>Soit :</p><p>v.x = a.x + b.x v.y = a.y + b.y</p><p>Essayons dâ€™additionner plusieurs vecteurs entres eux. Nous allons additionner 3 vecteurs : a, b et c. Voici ces trois vecteurs :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_e41b112201d04ecca.gif width=auto alt="Image utilisateur"></p><p>Euh, comment on additionne tout Ã§a ?</p><p>Je vais vous reprÃ©senter tout ces vecteurs autrement. On peut schÃ©matiser lâ€™addition comme ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_185e9da2b6054550b.gif width=auto alt="Image utilisateur"></p><p>Ici, le vecteur rÃ©sultant, v, se calcule ainsi :</p><p>v.x = a.x + b.x + c.x v.y = a.y + b.y + c.y</p><p>Ce qui donne :</p><p>v.x = -2 + 2 + 1 v.y = 1 + 2 + -2</p><p>Nous obtenons donc le vecteur v(1; 1).</p><p>Notez que lâ€™ordre dâ€™addition nâ€™a pas dâ€™importance : 2+1 = 1+2 Voyez ci-dessous lâ€™illustration dâ€™un autre ordre dâ€™addition : on retombe exactement au mÃªme endroit quâ€™avant (1; 1) :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_710_fcbe277decaf4a0e9.gif width=auto alt="Image utilisateur"></p><a href=#laddition-de-vecteurs-pour-trouver-une-moyenne><h3 id=laddition-de-vecteurs-pour-trouver-une-moyenne><span class=hanchor arialabel=Anchor># </span>Lâ€™addition de vecteurs pour trouver une moyenne</h3></a><p>Lâ€™addition de vecteurs peut Ã©galement servir Ã  trouver un vecteur moyen entre plusieurs vecteurs, en fait câ€™est ce que nous avons fait jusquâ€™Ã  maintenant, mais Ã  prÃ©sent si nous considÃ©rons la position rÃ©sultante de lâ€™addition de plusieurs vecteurs comme une <strong>direction</strong> et non une position, nous obtenons en fait la direction moyenne de tous les vecteurs additionnÃ©s.</p><p>Reprenons notre premier schÃ©ma sur lâ€™addition des vecteurs :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_45f0e10445954e96a.gif width=auto alt="Image utilisateur"></p><p>Nous voyons ici que le vecteur rÃ©sultant est positionnÃ© exactement entre a et b. Il est souvent utile de connaÃ®tre une moyenne entre plusieurs directions, Ã  prÃ©sent vous savez comment faire, il suffit dâ€™additionner toutes ces directions entres elles.</p><a href=#la-soustraction-de-vecteurs><h2 id=la-soustraction-de-vecteurs><span class=hanchor arialabel=Anchor># </span>La soustraction de vecteurs</h2></a><p>La soustraction de vecteurs est utilisÃ©e pour connaÃ®tre le vecteur qui va dâ€™un point Ã  un autre. Supposez que vous ayez les coordonnÃ©es dans lâ€™espace de deux objets A et B, et que vous vouliez connaÃ®tre le vecteur qui va de A vers B, ou de B vers A, il va vous falloir utiliser la soustraction de vecteurs.</p><p>Ca me servira Ã  quoi de connaÃ®tre le vecteur qui va de A vers B ?</p><p>Imaginez par exemple que vous vouliez programmer une animation fluide qui dÃ©place lâ€™objet A vers lâ€™objet B, il vous faudra connaÃ®tre la direction dans laquelle dÃ©placer A, la soustraction de vecteurs est inÃ©vitable.</p><p>Voici un schÃ©ma de base pour illustrer ce que nous recherchons :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_9b1d25760d014eaf8.gif width=auto alt="Image utilisateur"></p><p>Nous allons calculer le vecteur v en soustrayant A Ã  B. Cela fonctionne exactement de la mÃªme faÃ§on que lâ€™addition, rien de plus simple :</p><p>v.x = B.x - A.x v.y = B.y - A.y</p><p>Ce qui revient Ã  effectuer le calcul suivant :</p><p>v.x = -2 - 3 v.y = 1 - 2</p><p>Nous obtenons le vecteur v(-5; -1). Si nous le traÃ§ons dans le plan, nous obtenonsâ€¦ ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_9ab2680615e34561b.gif width=auto alt="Image utilisateur"></p><p>HÃ©Ã©, câ€™est pas du tout Ã§a !</p><p>Mais si, il suffit de placer lâ€™origine du vecteur sur le point A et nous obtenons ce que nous cherchions.</p><hr><a href=#longueur-et-normalisation><h2 id=longueur-et-normalisation><span class=hanchor arialabel=Anchor># </span>Longueur et normalisation</h2></a><a href=#une-question-de-longueur><h2 id=une-question-de-longueur><span class=hanchor arialabel=Anchor># </span>Une question de longueur</h2></a><p>Avant de voir ce quâ€™est la <strong>normalisation</strong> dâ€™un vecteur, il nous faut dâ€™abord voir ce quâ€™est sa <strong>longueur</strong> et ce quâ€™elle reprÃ©sente.</p><a href=#la-longueur-dun-vecteur-cest-quoi-><h3 id=la-longueur-dun-vecteur-cest-quoi-><span class=hanchor arialabel=Anchor># </span>La longueur dâ€™un vecteur, câ€™est quoi ?</h3></a><p>La longueur dâ€™un vecteur, câ€™est la distance qui sÃ©pare le point (0; 0) du point pointÃ© par le vecteur dont on veut connaÃ®tre la longueur. Lorsque nous dessinons ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_7db73c6554c54e6cb.gif width=auto alt="Image utilisateur"></p><p>Il est aisÃ© de sâ€™appercevoir que la longueur du vecteur v est de <strong>1</strong>. En revanche, la longueur dâ€™un vecteur comme nous en avons vu tout Ã  lâ€™heure :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_f0a8f712d45045f19.gif width=auto alt="Image utilisateur"></p><p>est moins Ã©vidente, il nous faut la calculer.</p><a href=#calculer-la-longueur-dun-vecteur><h3 id=calculer-la-longueur-dun-vecteur><span class=hanchor arialabel=Anchor># </span>Calculer la longueur dâ€™un vecteur</h3></a><p>Vous connaÃ®ssez probablement Pythagore, ce Grec philosophe et mathÃ©maticien de lâ€™antiquitÃ© ? Non ? Mais alors connaÃ®ssez-vous seulement son thÃ©orÃ¨me ? Si vous ne le connaÃ®ssez pas, vous risquez dâ€™avoir quelques difficultÃ©s Ã  comprendre cette partie du chapitre.</p><p>La longueur dâ€™un vecteur se calcule ainsi :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_f93afa7099b0476b9.gif width=auto alt="Image utilisateur"></p><p>Dans le cas dâ€™un vecteur Ã  3 dimensions, le calcul est le mÃªme, il suffit de rajouter la composante z comme ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_8eeb270d72b849799.gif width=auto alt="Image utilisateur"></p><p>longueur est Ã©gal Ã  la longueur du vecteur v. Il est possible dâ€™illustrer le calcul de la longueur de notre vecteur Ã  deux dimensions v :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_d29e16361dd54ffbb.gif width=auto alt="Image utilisateur"></p><p>Nous remarquons ici la prÃ©sence dâ€™un triangle rectangle, sur lequel on a en fait tout simplement appliquÃ© le thÃ©orÃ¨me de Pythagore ;)</p><a href=#la-normalisation><h2 id=la-normalisation><span class=hanchor arialabel=Anchor># </span>La normalisation</h2></a><p>La normalisation dâ€™un vecteur revient Ã  donner une <strong>norme</strong> de <strong>1</strong> Ã  sa longueur. Ce qui veut dire que la longueur dâ€™un vecteur normalisÃ© est toujours de <strong>1</strong>.</p><a href=#reprÃ©sentation-de-la-normalisation><h3 id=reprÃ©sentation-de-la-normalisation><span class=hanchor arialabel=Anchor># </span>ReprÃ©sentation de la normalisation</h3></a><p>Il est possible dâ€™illustrer la normalisation dâ€™un vecteur par un simple schÃ©ma :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_b20a32530e914fe7a.gif width=auto alt="Image utilisateur"></p><p>Soit 1 le rayon de ce cercle, tout vecteur partant du point (0; 0) et ayant une longueur de 1 touchera pile poil un endroit de la courbe de ce cercle.</p><p>Quel est lâ€™utilitÃ© de la normalisation ?</p><p>Lâ€™utilitÃ© est difficile Ã  dÃ©montrer pour lâ€™instant, nous verrons cela plus bas lorsque nous parlerons du produit scalaire.</p><a href=#calcul-de-la-normalisation><h3 id=calcul-de-la-normalisation><span class=hanchor arialabel=Anchor># </span>Calcul de la normalisation</h3></a><p>Effectuer une normalisation est trÃ¨s simple, surtout si lâ€™on sait calculer la longueur dâ€™un vecteur et quâ€™on a bien compris le principe de la normalisation.</p><p>Il suffit en fait de diviser chaque composante du vecteur (x, y, z (si 3D)) par la longueur du vecteur, et nous obtenons un vecteur normalisÃ©. Rappelez-vous du calcul de la longueur dâ€™un vecteur, vu plus haut. Nous avons donc une valeur appelÃ©e longueur qui est la longueur de notre vecteur v. Puisque la normalisation dâ€™un vecteur signifie quâ€™il faut diviser chaque composante du vecteur par la longueur du vecteur, le calcul sâ€™effectue ainsi :</p><p>v.x = v.x / longueur; v.y = v.y / longueur;</p><p>Il faut bien sÃ»r rajouter ce calcul :</p><p>v.z = v.z / longueur;</p><p>si le vecteur est en 3D.</p><p>Notez que pour un vecteur 4D (câ€™est-Ã -dire avec une composante w), la normalisation de ce dernier revient Ã  diviser chacune de ses trois premiÃ¨res composantes par w au lieu de longueur.</p><p>Si vous recalculez la longueur dâ€™un vecteur normalisÃ©, vous verrez que le rÃ©sultat sera 1.</p><a href=#une-application-pratique><h3 id=une-application-pratique><span class=hanchor arialabel=Anchor># </span>Une application pratique</h3></a><p>Je vous propose de voir une premiÃ¨re utilisation pratique des vecteurs normalisÃ©s, car je suis sÃ»r que vous vous demandez Ã  quoi la normalisation peut servir.</p><p>Souvenez-vous de notre schÃ©ma avec nos objets A et B, nous avions rÃ©ussi Ã  crÃ©er un vecteur qui allait de A vers B :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_9b1d25760d014eaf8.gif width=auto alt="Image utilisateur"></p><p><em>(notez quâ€™ici je nâ€™ai pas dessinÃ© le vecteur normalisÃ©)</em></p><p>Supposons que nous normalisons ce vecteur et que nous lâ€™appelons v.</p><p>Avec la normalisation, on sait de combien on se dÃ©place : on se dÃ©place toujours de <strong>1</strong>. Supposons que vous ayez considÃ©rÃ© en OpenGL que 1 = 1 mÃ¨tre, alors vous Ãªtes sÃ»rs quâ€™en additionnant un vecteur normalisÃ© Ã  un point celui-ci se dÃ©placera dâ€™un mÃ¨tre dans la direction indiquÃ©e par le vecteur.</p><p>Ainsi, en additionnant v Ã  A, nous sommes sÃ»rs et certains que A se dÃ©placera dâ€™un mÃ¨tre dans la direction de B. Et si nous voulons quâ€™il se dÃ©place dâ€™un centimÃ¨tre, comme nous avons un vecteur normalisÃ©, nous nâ€™aurons quâ€™Ã  diviser celui-ci par 100 avant de lâ€™additionner Ã  A pour quâ€™il se dÃ©place dâ€™un centimÃ¨tre.</p><p>Diviser un vecteur par un rÃ©el quelconque revient Ã  diviser chaque composante du vecteur par le rÃ©el en question, comme pour la normalisation, mais en remplaÃ§ant longueur par ce rÃ©el. Il en va de mÃªme pour la multiplication dâ€™un vecteur par un rÃ©el, sauf que cette fois au lieu de diviser on multiplie.</p><p>Et voilÃ , vous savez maintenant normaliser un vecteur et vous en servir pour une utilisation basique. Nous allons voir maintenant une technique de calcul qui nÃ©cessite obligatoirement des vecteurs normalisÃ©s : le produit scalaire.</p><hr><a href=#le-produit-scalaire-dot-product><h2 id=le-produit-scalaire-dot-product><span class=hanchor arialabel=Anchor># </span>Le produit scalaire (dot product)</h2></a><p>Le produit scalaire se dit <em>dot product</em> en anglais. Vous avez peut-Ãªtre dÃ©jÃ  entendu parler du produit scalaire, mais savez-vous comment le calculer et surtout, Ã  quoi il peut servir ? Non ? Et bien nous allons voir Ã§a :)</p><a href=#le-produit-scalaire-comme-calculateur-dangles><h2 id=le-produit-scalaire-comme-calculateur-dangles><span class=hanchor arialabel=Anchor># </span>Le produit scalaire comme calculateur dâ€™angles</h2></a><p>Effectuer le produit scalaire de deux vecteurs, câ€™est connaÃ®tre lâ€™angle quâ€™il y a entre deux vecteurs. Voici un schÃ©ma qui illustre assez bien ce que nous voulons calculer :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_b7277dcdb3224bc19.gif width=auto alt="Image utilisateur"></p><p>Bon, lÃ  je vous lâ€™accorde, lâ€™angle se devine facilement. Mais il se devine seulement, car en programmation 3D il ne sâ€™agit pas de deviner, il sâ€™agit de calculer.</p><p>Si nous prenons deux vecteurs, (3; 2; 5) et (0; 2; 1) par exemple, comment, Ã  partir de ces donnÃ©es, pourriez-vous calculer lâ€™angle qui sÃ©pare ces deux vecteurs ? Le produit scalaire sert Ã  calculer cela.</p><p>Ã‡a marche aussi en 3D ?</p><p>Bien sÃ»r ! sinon cela nâ€™aurait aucun intÃ©rÃªt.</p><p>Nous supposerons par la suite que tous nos vecteurs sont normalisÃ©s.</p><a href=#le-calcul-du-produit-scalaire><h2 id=le-calcul-du-produit-scalaire><span class=hanchor arialabel=Anchor># </span>Le calcul du produit scalaire</h2></a><p>En supposant que vous ayez deux vecteurs, a et b, et que vous souhaitez connaÃ®tre leur produit scalaire, le calcul est, pour des vecteurs 2D :</p><p>dot = (a.x * b.x) + (a.y * b.y)</p><p>Et en 3D, on rajoute la composante Z, aussi simplement que cela :</p><p>dot = (a.x * b.x) + (a.y * b.y) + (a.z * b.z)</p><p>Euh, câ€™est bien joli ce dot, mais câ€™est quoi ? Câ€™est la valeur de lâ€™angle ?</p><p>Non, mais câ€™est le cosinus de lâ€™angle.</p><p>Si dot vaut <strong>1</strong>, les deux vecteurs pointent dans la mÃªme direction (0Â°). Si dot vaut <strong>0</strong>, alors les deux vecteurs pointent dans deux directions qui sont Ã  angle droit (90Â°).</p><p>Et donc logiquement, quand dot est entre 0 et 1, lâ€™angle est compris entre 90Â° et 0Â°.</p><p>Mais moi je veux un angle en degrÃ¨s prÃ©cis, Ã§a va me servir Ã  quoi sinon ? Et que vaut dot quand les vecteurs sont sÃ©parÃ©s par plus de 90Â° ? Et puis Ã  quoi Ã§a sert de calculer le produit scalaire ?</p><p>Tout dâ€™abord, pour obtenir lâ€™angle, il suffit dâ€™utiliser la simple fonction mathÃ©matique arc cosinus (cos-1() sur les calculatrices) sur notre valeur dot. Mais attention, arc cosinus ne fonctionne pas sur des nombres nÃ©gatifs, et lorsque lâ€™angle qui sÃ©pare deux vecteurs est supÃ©rieur Ã  90Â°, dot prend alors une valeur nÃ©gative, et on ne peut alors plus calculer lâ€™angle qui sÃ©pare nos vecteurs.</p><p>Mais rassurez-vous, en 3D cela sera inutile, nous nous contenterons de vÃ©rifier si dot se situe entre 0 et 1, sinon on considÃ¨rera sa valeur comme Ã©tant de 0.</p><p>Ah ouais, mais alors il sert Ã  quoi ce produit scalaire ?</p><p>Pour vous rÃ©pondre en quelques mots : Ã  calculer le taux de reception de lumiÃ¨re dâ€™un plan. Nous Ã©tudierons cela plus en dÃ©tail lorsque nous apprendrons Ã  gÃ©rer la lumiÃ¨re dans la 3eme partie du tutoriel.</p><p>Pour clore, retenez que :</p><ul><li><p>Le produit scalaire sert Ã  calculer lâ€™angle entre deux vecteurs.</p></li><li><p>Le produit scalaire ne fonctionne <strong>que</strong> sur des vecteurs normalisÃ©s !</p></li></ul><hr><a href=#le-produit-vectoriel-cross-product><h2 id=le-produit-vectoriel-cross-product><span class=hanchor arialabel=Anchor># </span>Le produit vectoriel (cross product)</h2></a><p>Le produit vectoriel sert Ã  calculer le vecteur perpendiculaire Ã  deux autres vecteurs. Le produit vectoriel se dit <em>cross product</em> (produit croisÃ©) en anglais, mais vous voudriez peut-Ãªtre savoir Ã  quoi cela sert avant dâ€™apprendre Ã  le calculer ? Pas de problÃ¨me.</p><a href=#notion-de-normale-dune-face><h2 id=notion-de-normale-dune-face><span class=hanchor arialabel=Anchor># </span>Notion de â€œnormaleâ€ dâ€™une face</h2></a><p>Nous allons commencer simplement.</p><p>Toute face (surface plane) possÃ¨de une <strong>normale</strong>. Prenons par exemple votre table de bureau, câ€™est une surface plane. Sa normale pointe pile poil vers le plafond (vers le haut).</p><p>Voici comment schÃ©matiser la normale dâ€™une face :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_ae9852d9b75e4915a.png width=auto alt="Image utilisateur"></p><p>Voici un cube. Jâ€™ai dessinÃ© (Ã  lâ€™aide de Blender) pour chaque face du cube, sa normale. Comme vous pouvez le voir, la normale dâ€™une face plane est un vecteur qui est perpendiculaire Ã  la face.</p><p>Quel est le rapport avec le produit vectoriel ?</p><p>Et bien le produit vectoriel permet de calculer cette normale, uniquement grÃ¢ce aux positions des sommets qui la composent :)</p><a href=#calcul-du-produit-vectoriel><h2 id=calcul-du-produit-vectoriel><span class=hanchor arialabel=Anchor># </span>Calcul du produit vectoriel</h2></a><p>Il est temps maintenant de reprÃ©senter le produit vectoriel, ainsi que de montrer le calcul quâ€™il faut faire pour le trouver.</p><p>Le calcul du produit vectoriel se fait Ã  partir de deux vecteurs et permet dâ€™obtenir un autre vecteur. Ce vecteur obtenu est perpendiculaire aux deux autres vecteursâ€¦ tout comme la normale dâ€™une face est perpendiculaire Ã  la face elle mÃªme.</p><p>Nous pouvons faire lâ€™analogie avec le produit vectoriel et la normale dâ€™une face. En effet, voyez plutÃ´t ce schÃ©ma :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_c89a026e6f5b43558.gif width=auto alt="Image utilisateur"></p><p>Cette illustration rÃ©sume assez bien tout ce que nous venons de voir :) Nous pouvons voir dâ€™une part les vecteurs a et b, dâ€™autre part le vecteur n, qui nâ€™est autre que le rÃ©sultat du produit vectoriel de a et b, en effet, n est perpendiculaire Ã  a et b. Mais il est aussi perpendiculaire Ã  la face, il reprÃ©sente donc sa normale.</p><p>Nous venons de voir quâ€™avec deux vecteurs qui longent les bords dâ€™une face, nous pouvons obtenir la normale de cette face</p><p>Et comment on les trouve ces vecteurs qui longent les bords de notre face ? (a et b)</p><p>Revoyez la premiÃ¨re partie de ce chapitre, et plus prÃ©cisÃ©ment lâ€™endroit qui parle de la soustraction de vecteursâ€¦ vous devriez trouver assez aisÃ©ment ;) Rappelez-vous que nous connaissons les positions des sommets qui constituent notre face.</p><p>Mais Ã§a ne nous dit pas le plus important : comment on calcule Ã§a ?</p><p>Oh Ã§a, câ€™est le moins important, il sâ€™agit dâ€™une grosse formule barbare, lâ€™important câ€™est de bien savoir ce que permet de faire le produit vectoriel.</p><p>Voici le calcul du produit vectoriel :</p><p>n.x = (a.y * b.z) - (a.z * b.y) n.y = (a.z * b.x) - (a.x * b.z) n.z = (a.x * b.y) - (a.y * b.x)</p><p>Notez que si vous Ã©changez les vecteurs a et b dans les calculs, le vecteur obtenu sera exactement le vecteur opposÃ© Ã  celui que vous auriez obtenu sans Ã©changer a et b.</p><p>Mais alors comment connaÃ®tre le bon ordre de calcul pour obtenir la bonne normale de notre face ?</p><p>Il nâ€™existe pas de mÃ©thode magique pour celaâ€¦ Comment savoir quelle doit Ãªtre la normale de votre face ? Il nâ€™y a pas de â€œhautâ€ en 3D, ni nulle part dâ€™ailleurs, tout est relatif. Les sommets des triangles dans les maillages sont gÃ©nÃ©ralement donnÃ© dans un ordre conventionnel, ce qui permet de dÃ©termnier lâ€™orientation de la face.</p><p>Les vecteurs ne sont pas une notion simple Ã  aborder, il est possible quâ€™il vous fasse du temps avant de vous y faire. Prenez le temps de relire tranquillement chaque passage de ce chapitre afin de vous familiariser avec les vecteurs, câ€™est essentiel croyez-moi, car nous les utiliserons en permanence par la suite. Il est donc important que vous vous sentiez Ã  lâ€™aise avec ceux-ci.</p><p>Pour finir, je vais vous renvoyer sur les articles de Wikipedia Ã  propos de tout ce que nous avons appris, Ã§a vaut toujours le coup dâ€™oeil.</p><ul><li><p><a href=http://fr.wikipedia.org/wiki/Vecteur rel=noopener>Le vecteur.</a></p></li><li><p><a href=http://fr.wikipedia.org/wiki/Produit_scalaire rel=noopener>Le produit scalaire.</a></p></li><li><p><a href=http://fr.wikipedia.org/wiki/Produit_vectoriel rel=noopener>Le produit vectoriel.</a></p></li></ul><p>Et voilÃ , câ€™est la fin de cette annexe, nâ€™hÃ©sitez pas Ã  venir la consulter rÃ©guliÃ¨rement si vous vous sentez bloquÃ© par la suite.</p><p>Merci au site
<a href=http://www.developpez.com/ rel=noopener>www.developpez.com</a> et aux membres de sa section programmation 3D, grÃ¢ce auxquels jâ€™ai acquis la plupart des mes connaissances actuelles en terme de programmation 3D.</p><p>Les commentaires, critiques ou corrections sont les bienvenus. Si vous pensez avoir trouvÃ© une incohÃ©rence ou si vous avez mal compris quelque chose, nâ€™hÃ©sitez pas Ã  mâ€™en faire part, je serai heureux de pouvoir amÃ©liorer le tutoriel pour vous ;)</p><p>*
<a href=http://creativecommons.org/licenses/by-sa/2.0/fr/ rel=noopener><img src=https://deuxfois.github.io/quartz//../../../_resources/88x31_f68b4c5b8aa1497ab41e05225e616157.png width=auto alt="Image utilisateur"></a>Cette crÃ©ation est mise Ã  disposition sous un
<a href=http://creativecommons.org/licenses/by-sa/2.0/fr/ rel=noopener>contrat Creative Commons</a>.*</p><hr></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/Master/Graphisme/ data-ctx="Tutoriel _ Les shaders en GLSL" data-src=/Master/Graphisme class=internal-link></a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://deuxfois.github.io/quartz/js/graph.afdb02e537635f9a611b53a988e5645b.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://deuxfois.github.io/quartz/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>