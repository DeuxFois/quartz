<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Les shaders en GLSL Bonjour à tous ! :)
Vous êtes-vous jamais demandé comment étaient faits les superbes effets 3D à la mode comme on en voit dans les jeux vidéos récents, comme par exemple l’eau, l’HDR ou l’effet de flou de vitesse dans les jeux de voiture ?"><title>Tutoriel : Les shaders en GLSL</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://deuxfois.github.io/quartz//icon.png><link href=https://deuxfois.github.io/quartz/styles.17d6b88a150cefaa68444ffe6a99c9bc.min.css rel=stylesheet><link href=https://deuxfois.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://deuxfois.github.io/quartz/js/darkmode.69b2c08ae0f08c3a3f86259a122e1f06.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://deuxfois.github.io/quartz/js/popover.287fef157aa83f5993c885f838baad9f.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://deuxfois.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://deuxfois.github.io/quartz/",fetchData=Promise.all([fetch("https://deuxfois.github.io/quartz/indices/linkIndex.8e314bfec2e2abaad4f366a0b2775988.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://deuxfois.github.io/quartz/indices/contentIndex.d410083db931d6af0335102013694297.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://deuxfois.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://deuxfois.github.io/quartz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/deuxfois.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://deuxfois.github.io/quartz/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://deuxfois.github.io/quartz/>⛄ DeuxFoi's blog</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><div class=navigation-menu><a href=https://deuxfois.github.io/quartz/>home</a>
<span style=color:var(--gray)>/</span>
<a href=https://deuxfois.github.io/quartz/master>master</a>
<span style=color:var(--gray)>/</span>
<a href=https://deuxfois.github.io/quartz/master/graphisme>graphisme</a>
<span style=color:var(--gray)>/</span>
<a href=https://deuxfois.github.io/quartz/master/graphisme/glsl-shader>glsl-shader</a>
<span style=color:var(--gray)>/</span></div><a href=https://deuxfois.github.io/quartz/master/graphisme class=back-button>↩</a><article><h1>Tutoriel : Les shaders en GLSL</h1><ul class=tags><li><a href=https://deuxfois.github.io/quartz/tags/graphisme/>Graphisme</a></li><li><a href=https://deuxfois.github.io/quartz/tags/s1/>S1</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#cest-quoi->C’est quoi ?</a></li><li><a href=#la-programmation-gpu>La programmation GPU</a><ol><li><a href=#en-assembleur->En assembleur ?</a></li></ol></li><li><a href=#pourquoi-faire->Pourquoi faire ?</a></li><li><a href=#le-traitement-dun-vertex-et-dun-pixel-cest-quoi->Le traitement d’un vertex et d’un pixel, c’est quoi ?</a></li><li><a href=#un-exemple-concret->Un exemple concret ?</a></li><li><a href=#comment-faire->Comment faire ?</a></li><li><a href=#programmer-un-shader-cest-dur->Programmer un shader, c’est dur ?</a></li><li><a href=#programmer-un-shader-avec-quel-ide->Programmer un shader, avec quel IDE ?</a></li><li><a href=#programmer-un-shader-avec-quel-compilateur->Programmer un shader, avec quel compilateur ?</a><ol><li><a href=#les-spécifications-du-langage>Les spécifications du langage</a></li></ol></li></ol><ol><li><a href=#création-dun-shader>Création d’un shader</a></li><li><a href=#les-extensions-des-shaders>Les extensions des shaders</a></li><li><a href=#création-dun-shader-1>Création d’un shader</a></li><li><a href=#envoi-dun-code-source-à-un-shader>Envoi d’un code source à un shader</a></li><li><a href=#charger-un-code-source-à-partir-dun-fichier>Charger un code source à partir d’un fichier</a></li><li><a href=#compilation-dun-shader>Compilation d’un shader</a></li><li><a href=#compiler-un-shader>Compiler un shader</a></li><li><a href=#vérifier-le-succès-dune-compilation>Vérifier le succès d’une compilation</a></li><li><a href=#récupérer-les-messages-derreur-de-la-compilation>Récupérer les messages d’erreur de la compilation</a></li><li><a href=#création-et-utilisation-dun-program>Création et utilisation d’un program</a></li><li><a href=#créer-un-objet-de-program>Créer un objet de program</a></li><li><a href=#association-dun-ou-plusieurs-shaders-à-un-program>Association d’un ou plusieurs shaders à un program</a></li><li><a href=#liage-dun-program-de-shader>Liage d’un program de shader</a></li><li><a href=#utiliser-un-program-de-shader>Utiliser un program de shader</a></li></ol><ol><li><a href=#les-bases-du-langage>Les bases du langage</a></li><li><a href=#une-forte-ressemblance-avec-le-c>Une forte ressemblance avec le C</a></li><li><a href=#les-variables>Les variables</a></li><li><a href=#les-opérateurs>Les opérateurs</a><ol><li><a href=#la-surcharge-des-opérateurs>La surcharge des opérateurs</a></li><li><a href=#les-limites-de-la-surcharge>Les limites de la surcharge</a></li></ol></li><li><a href=#le-cast>Le cast</a><ol><li><a href=#initialiser-le-contenu-dun-vecteur>Initialiser le contenu d’un vecteur</a></li><li><a href=#et-les-matrices->Et les matrices… ?</a></li></ol></li><li><a href=#les-commentaires>Les commentaires</a></li><li><a href=#les-tableaux>Les tableaux</a><ol><li><a href=#les-tableaux-à-deux-dimensions>Les tableaux à deux dimensions</a></li></ol></li></ol><ol><li><a href=#un-vertex-shader--ça-fait-quoi->Un vertex shader : ça fait quoi ?</a></li><li><a href=#quelques-règles-de-programmation>Quelques règles de programmation</a><ol><li><a href=#la-fonction-main>La fonction main</a></li></ol></li><li><a href=#les-variables-dentréesortie>Les variables d’entrée/sortie</a><ol><li><a href=#les-variables-dentrée>Les variables d’entrée</a></li><li><a href=#les-variables-de-sortie>Les variables de sortie</a></li></ol></li><li><a href=#les-matrices-quelques-variables-dentrée-supplémentaires>Les matrices, quelques variables d’entrée supplémentaires</a><ol><li><a href=#vous-avez-dit-variable-dentrée->Vous avez dit “variable d’entrée” ?</a></li><li><a href=#exercice>Exercice</a></li><li><a href=#correction>Correction</a></li></ol></li><li><a href=#un-pixel-shader>Un pixel shader</a></li><li><a href=#traiter-le-rendu-dun-pixel->Traiter le rendu d’un pixel ?</a><ol><li><a href=#une-limite-en-puissance-assez-restreinte->Une limite en puissance assez restreinte ?</a></li><li><a href=#pourquoi->Pourquoi ?</a></li></ol></li><li><a href=#bon-quest-ce-quon-attend-pour-programmer-ça->Bon, qu’est-ce qu’on attend pour programmer ça ?</a><ol><li><a href=#le-code-source-de-base>Le code source de base</a></li><li><a href=#les-variables-dentrée-1>Les variables d’entrée</a></li><li><a href=#les-variables-de-sortie-1>Les variables de sortie</a></li><li><a href=#programmer-un-simple-pixel-shader>Programmer un simple pixel shader</a></li></ol></li></ol><ol><li><a href=#notions-communes-et-incompatibilités-avec-le-c>Notions communes et incompatibilités avec le C</a></li><li><a href=#notions-communes>Notions communes</a><ol><li><a href=#les-instructions-ifelse>Les instructions if…else</a></li><li><a href=#instructions-break-et-continue>Instructions break et continue</a></li><li><a href=#la-boucle-dowhile>La boucle do…while</a></li><li><a href=#la-boucle-while>La boucle while</a></li><li><a href=#la-boucle-for>La boucle for</a></li><li><a href=#les-structures>Les structures</a></li><li><a href=#le-préprocesseur>Le préprocesseur</a></li></ol></li><li><a href=#incompatibilités-et-différences>Incompatibilités et différences</a><ol><li><a href=#les-déclarations-de-variables>Les déclarations de variables</a></li><li><a href=#les-pointeurs-et-linstruction-switch>Les pointeurs et l’instruction switch</a></li></ol></li><li><a href=#créer-et-surcharger-des-fonctions>Créer et surcharger des fonctions</a></li><li><a href=#déclarer-une-simple-fonction>Déclarer une simple fonction</a><ol><li><a href=#paramètres-et-valeur-de-retour>Paramètres et valeur de retour</a></li></ol></li><li><a href=#la-surcharge-des-fonctions>La surcharge des fonctions</a><ol><li><a href=#notion-de-surcharge>Notion de surcharge</a></li><li><a href=#surcharger-une-fonction>Surcharger une fonction</a></li><li><a href=#exemple-complet>Exemple complet</a></li></ol></li></ol><ol><li><a href=#fonctions-de-manipulation-de-vecteurs>Fonctions de manipulation de vecteurs</a><ol><li><a href=#normalisation-de-vecteurs>Normalisation de vecteurs</a></li><li><a href=#produit-scalaire>Produit scalaire</a></li><li><a href=#produit-vectoriel>Produit vectoriel</a></li><li><a href=#longueur-dun-vecteur>Longueur d’un vecteur</a></li><li><a href=#distance-entre-deux-vecteurs>Distance entre deux vecteurs</a></li></ol></li><li><a href=#la-fonction-ftransform>La fonction <em>ftransform()</em></a></li><li><a href=#encore-quelques-fonctions>Encore quelques fonctions</a><ol><li><a href=#min>min()</a></li><li><a href=#max>max()</a></li><li><a href=#clamp>clamp()</a></li></ol></li><li><a href=#spécifications-du-glsl>Spécifications du GLSL</a></li></ol><ol><li><a href=#les-variables-de-type-uniform>Les variables de type uniform</a></li><li><a href=#principe>Principe</a></li></ol><ol><li><a href=#implémentation-côté-api>Implémentation côté API</a><ol><li><a href=#une-affaire-didentifiants>Une affaire d’identifiants</a></li><li><a href=#récupérer-un-id>Récupérer un ID</a></li><li><a href=#assigner-une-valeur>Assigner une valeur</a></li></ol></li><li><a href=#les-différentes-formes-de-gluniform>Les différentes formes de <em>glUniform</em>()*</a><ol><li><a href=#envoi-dune-simple-variable>Envoi d’une simple variable</a></li><li><a href=#envoi-dun-simple-vecteur>Envoi d’un simple vecteur</a></li><li><a href=#étude-de-la-version-vectorielle-de-gluniform>Étude de la version vectorielle de glUniform*()</a></li><li><a href=#et-les-matrices--1>Et les matrices ?</a></li></ol></li><li><a href=#les-attributs-de-sommet>Les attributs de sommet</a></li><li><a href=#quest-ce-quun-attribut->Qu’est-ce qu’un attribut ?</a></li></ol><ol><li><a href=#côté-api>Côté API</a><ol><li><a href=#récupérer-lindex>Récupérer l’index</a></li><li><a href=#spécifier-la-valeur-dun-attribut>Spécifier la valeur d’un attribut</a></li></ol></li><li><a href=#les-tableaux-dattributs>Les tableaux d’attributs</a></li><li><a href=#activation-des-tableaux-dattributs>Activation des tableaux d’attributs</a></li><li><a href=#envoi-dun-tableau>Envoi d’un tableau</a><ol><li><a href=#et-les-vbos->Et les VBOs ?</a></li></ol></li><li><a href=#désactivation-des-tableaux-dattributs>Désactivation des tableaux d’attributs</a></li><li><a href=#exemple-dutilisation>Exemple d’utilisation</a></li><li><a href=#téléchargement>Téléchargement</a></li><li><a href=#les-vecteurs>Les vecteurs</a></li><li><a href=#les-vecteurs-notions-de-base>Les vecteurs, notions de base</a></li><li><a href=#un-vecteur-cest-quoi->Un vecteur, c’est quoi ?</a></li><li><a href=#laddition-de-vecteurs>L’addition de vecteurs</a><ol><li><a href=#laddition-de-vecteurs-pour-trouver-une-moyenne>L’addition de vecteurs pour trouver une moyenne</a></li></ol></li><li><a href=#la-soustraction-de-vecteurs>La soustraction de vecteurs</a></li><li><a href=#longueur-et-normalisation>Longueur et normalisation</a></li><li><a href=#une-question-de-longueur>Une question de longueur</a><ol><li><a href=#la-longueur-dun-vecteur-cest-quoi->La longueur d’un vecteur, c’est quoi ?</a></li><li><a href=#calculer-la-longueur-dun-vecteur>Calculer la longueur d’un vecteur</a></li></ol></li><li><a href=#la-normalisation>La normalisation</a><ol><li><a href=#représentation-de-la-normalisation>Représentation de la normalisation</a></li><li><a href=#calcul-de-la-normalisation>Calcul de la normalisation</a></li><li><a href=#une-application-pratique>Une application pratique</a></li></ol></li><li><a href=#le-produit-scalaire-dot-product>Le produit scalaire (dot product)</a></li><li><a href=#le-produit-scalaire-comme-calculateur-dangles>Le produit scalaire comme calculateur d’angles</a></li><li><a href=#le-calcul-du-produit-scalaire>Le calcul du produit scalaire</a></li><li><a href=#le-produit-vectoriel-cross-product>Le produit vectoriel (cross product)</a></li><li><a href=#notion-de-normale-dune-face>Notion de “normale” d’une face</a></li><li><a href=#calcul-du-produit-vectoriel>Calcul du produit vectoriel</a></li></ol></nav></details></aside><a href=#les-shaders-en-glsl><h1 id=les-shaders-en-glsl><span class=hanchor arialabel=Anchor># </span>Les shaders en GLSL</h1></a><p>Bonjour à tous ! :)</p><p>Vous êtes-vous jamais demandé comment étaient faits les superbes effets 3D à la mode comme on en voit dans les jeux vidéos récents, comme par exemple l’eau, l’HDR ou l’effet de flou de vitesse dans les jeux de voiture ? Une bonne partie de la réponse se trouve dans l’utilisation de
<a href=http://fr.wikipedia.org/wiki/Shader_Model rel=noopener><strong>shaders</strong></a> au sein d’un rendu 3D.</p><p>Vous en avez sans doute déjà entendu parler (<em>Shader Model 2.0</em>, <em>Shader Model 3.0</em>, …), mais savez-vous vraiment ce qu’est un shader ? Savez-vous ce que permet de faire un shader ? Non ? Et bien c’est justement ce que je vais essayer de vous apprendre à travers ce tutoriel.</p><p>Ici, je vous apprendrai à programmer dans un langage de programmation de shaders appelé le GLSL. Nous allons tout d’abord voir en quoi cela consiste, comment on s’y prend, et enfin je vous apprendrai à créer quelques effets graphiques sympathiques :) Allons-y !</p><p>Ce tutoriel nécessite la lecture du
<a href=http://www.siteduzero.com/tuto-3-5616-0-creez-des-programmes-en-3d-avec-opengl.html rel=noopener>tutoriel sur OpenGL</a> de Kayl,
<a href=http://www.siteduzero.com/tuto-3-23980-1-la-trigonometrie.html rel=noopener>annexe sur la trigonométrie</a> comprise. Les exemples de code seront écrits en langage C, et la connaissance de ce langage en général (ou d’un langage qui lui ressemble syntaxiquement comme le C++ ou le Java) est conseillée car le GLSL est basé dessus. Je ne vous détaillerai donc aucune base de la programmation avec GLSL puisqu’elles sont quasiment identiques à celles du C (if, else, for, etc…).</p><a href=#introduction-au-glsl><h1 id=introduction-au-glsl><span class=hanchor arialabel=Anchor># </span>Introduction au GLSL</h1></a><p>Vous vous demandez probablement qui peut bien être ce GLSL, et à quoi il peut servir ? o_O</p><p>Je vais, dans ce premier chapitre, essayer de vous expliquer à quoi il peut amener. Nous verrons ce qu’il représente exactement et comment il intervient dans un rendu 3D avec OpenGL.</p><p><strong>Que saurais-je faire à la fin de ce tutoriel ?</strong></p><p>Je ne peux pas être affirmatif sur ce point, mais je pense pouvoir vous apprendre :</p><ul><li><p>à faire de la lumière. Nous apprendrons à gérer des lumières avec le GLSL;</p></li><li><p>cel-shading, ou rendu cartoon. Cet effet est très simple à réaliser, je pense que c’est l’un des premiers que nous étudierons;</p></li><li><p>manipulation de textures. Nous verrons comment déformer simplement nos textures pour donner des effets de distorsion, mais aussi des effets de flou (comme le flou de vitesse de certains jeux de voiture);</p></li><li><p>pseudo-HDR. La gestion de la lumière alliée à la manipulation des textures nous permettra de réaliser “facilement” un effet de pseudo-HDR.</p></li></ul><p>Mais avant de voir toutes ces jolies choses, il nous faut tout d’abord connaître l’essentiel : qu’est-ce que le GLSL, et comment on l’utilise.</p><a href=#cest-quoi-><h2 id=cest-quoi-><span class=hanchor arialabel=Anchor># </span>C’est quoi ?</h2></a><p>A l’origine pensé par
<a href=http://www.pixar.com/ rel=noopener>Pixar</a> pour ses animations vidéos, les shaders ont fait leur apparition dans le domaine du jeu vidéo assez récemment et sont aujourd’hui indispensables pour qui veut réaliser des effets graphiques un tant soit peu évolués.</p><p>GLSL (
<a href=http://en.wikipedia.org/wiki/GLSL rel=noopener>Def. GLSL (en)</a>) est l’abréviation de Open<strong>GL****S</strong>hading <strong>L</strong>anguage, traduisez : langage de programmation de shaders OpenGL. Effectivement, le GLSL est un langage de programmation de shaders.</p><a href=#la-programmation-gpu><h2 id=la-programmation-gpu><span class=hanchor arialabel=Anchor># </span>La programmation GPU</h2></a><p>Le GPU est le processeur de votre carte graphique, c’est lui qui calcule vos rendus 3D. La programmation GPU revient donc à… programmer nos calculs de rendus 3D o_O Ah bah tiens, c’est la meilleure du siècle celle-là :p</p><p>Les shaders servent à programmer le
<a href="http://jeux.developpez.com/faq/3d/?page=definitions#DEFINITIONS_pipeline" rel=noopener>pipeline</a> de rendu par défaut de votre carte graphique, appelé le FFP. Les shaders ne sont donc rien de plus que des programmes, donc :</p><ul><li><p>un code source;</p></li><li><p>une compilation;</p></li><li><p>une exécution.</p></li></ul><p>Ils se différencient toutefois des programmes écrits en C, C++ ou autre langage réservé à une exécution CPU, de par leur compilation et leur exécution. La compilation d’un shader est effectuée lors du lancement de votre application, et l’exécution se passe au niveau du GPU, contrairement à vos programmes habituels (C, C++, C#, Java, …) qui eux sont traités par le CPU, et c’est ce qui fait la puissance et la flexibilité des shaders dans le rendu 3D en général :)</p><a href=#en-assembleur-><h3 id=en-assembleur-><span class=hanchor arialabel=Anchor># </span>En assembleur ?</h3></a><p>Quand on parle de la programmation d’un processeur, on pense généralement à l’assembleur. Il existe effectivement des langages assembleur pour programmer un GPU, mais nous ne les traiterons pas dans ce tutoriel. Ici, nous ne parlerons que d’un langage de programmation GPU dit de haut niveau, le GLSL. Le GLSL a été développé par l’ARB pour l’API graphique OpenGL afin d’offrir une plus grande souplesse dans la programmation de shaders. DirectX a également développé son propre langage haut niveau pour la programmation de shaders, il s’agit du HLSL, mais il est plutôt hors-sujet, je ne vous en parle qu’à titre de comparaison.</p><p>Le GLSL est donc un langage de programmation de shaders de haut niveau, mais à quoi ça ressemble au juste ? Voici le code source d’un shader écrit en GLSL :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_TexCoord[0] = gl_MultiTexCoord0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_Position = gl_Vertex * gl_ModelViewMatrix;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Il s’agit là d’un simple vertex shader.</p><p>Vertex shader ??</p><p>Oui. Il est important de distinguer deux types de shaders différents, remplissant chacun des fonctions bien définies et aucunement identiques :</p><ul><li><p>les <strong>vertex shaders</strong> : ce sont des shaders qui interviennent lors du traitement de chaque sommet. Dans les vertex shaders vous pourrez modifier le calcul des différents attributs de vos sommets;</p></li><li><p>les <strong>pixel shaders</strong> : aussi appelés fragment shaders, ils permettent de traiter le rendu de chaque pixel qui s’affichera à l’écran. Ces derniers offrent une grande flexibilité dans le domaine du rendu 3D.</p></li></ul><p>J’espère que vous y voyez à présent un peu plus clair ;) Les shaders vous permettent de programmer le traitement de chaque sommet ainsi que de chaque pixel.</p><p>Une nouvelle génération de shaders vient de faire son apparition avec le nouveau GPU (GeForce8) de nVidia, les <em>geometry shaders</em>. Cette technologie étant assez nouvelle je n’en parlerai pas. Aussi je n’ai pas les moyens de me procurer ce genre de carte, et beaucoup de gens étant dans mon cas, l’explication d’une fonctionnalité que personne ne pourrait exploiter serait plutôt inutile à l’heure actuelle ;)</p><hr><a href=#pourquoi-faire-><h2 id=pourquoi-faire-><span class=hanchor arialabel=Anchor># </span>Pourquoi faire ?</h2></a><p>Les shaders permettent donc de programmer la fonction de traitement d’un vertex ainsi que d’un pixel. Mais à quoi cela rime-t-il ? Quel utilité cela peut-il bien avoir ?</p><a href=#le-traitement-dun-vertex-et-dun-pixel-cest-quoi-><h2 id=le-traitement-dun-vertex-et-dun-pixel-cest-quoi-><span class=hanchor arialabel=Anchor># </span>Le traitement d’un vertex et d’un pixel, c’est quoi ?</h2></a><p>Voilà une bien bonne question :) Quand vous envoyez des données de sommet à OpenGL via les commandes <em>glVertex</em>()<em>, <em>glColor</em>()</em>, <em>glTexCoord</em>()<em>, <em>glNormal</em>()</em>, … (ou par des tableaux via <em>gl</em>Pointer()* ) OpenGL les stocke et les associe à un ou plusieurs triangles bien définis.</p><p>Je rappelle que le triangle est la seule primitive supportée nativement par toutes les cartes graphiques, les GL_QUADS et autres ne sont que des émulations via des constructions de plusieurs triangles, d’où leur coût de traitement plus élevé.</p><p>Le traitement de ce triangle se décompose par le traitement de ses 3 sommets, puis par une interpolation des données de ses sommets pour obtenir un triangle plein. Ce sont ces deux dernières étapes qui sont traitées respectivement par le vertex et le pixel shader.</p><p>Le traitement d’un vertex consiste à lui appliquer des transformations matricielle (GL_MODELVIEW, GL_TEXTURE, …) pour obtenir les données des sommets définitives qui seront ensuite interpolées. Le pixel shader reçoit des données interpolées de couleur et autres attributs traités dans le vertex shader.</p><p>Quel est l’intérêt des shaders ?</p><p>Pensez bien qu’il y en a un ;) En réalité, il y a deux grands avantages à utiliser les shaders. Le premier est qu’ils permettent une énorme flexibilité de rendu. En gérant le rendu de chaque pixel vous avez un contrôle quasi absolu sur vos rendus 3D et vous pouvez ainsi réaliser beaucoup d’effets chouettes sans trop vous compliquer la vie. Le second intérêt réside dans leur principe même. Étant exécutés par la carte graphique, les shaders ne consomment <strong>pas</strong> de processeur (CPU), ce dernier peut alors souffler un peu et se concentrer sur la gestion de l’IA ou du réseau par exemple. Dans cette optique de décharger le processeur, les shaders ont également un énorme intérêt si l’on utilise un langage assez “gourmand” comme le C# ou le Java, qui sont moins rapides que le C.</p><a href=#un-exemple-concret-><h2 id=un-exemple-concret-><span class=hanchor arialabel=Anchor># </span>Un exemple concret ?</h2></a><p>Mais concrètement, qu’est-ce qu’on peut faire avec des shaders ?</p><p>Il est temps de vous montrer à quoi cela ressemble. Voici deux captures d’écran de la même scène, l’une utilisant le FFP standard, l’autre, des shaders.</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_640_73c7119f82b84068b.jpg width=auto alt="Image utilisateur"></p><p>Rendu standard</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_640_15af334fbee54bcd9.jpg width=auto alt="Image utilisateur"></p><p>Rendu avec shaders</p><p><em>(source du modèle 3D et des textures :
<a href=http://mdeverdelhan.developpez.com/tutoriel/dynamiclight/tutoriel6/ rel=noopener>http://mdeverdelhan.developpez.com/tut […] ht/tutoriel6/</a>)</em></p><p>Les shaders permettent d’ajouter des effets qui peuvent être réalistes, beaux ou encore rigolos, comme le cel-shading (aussi appelé rendu cartoon).</p><p>Hey je veux savoir faire ça !</p><p>Pas de problème :) Toutefois soyez prévenus, pour aboutir à un résultat tel que vous venez d’en voir, les shaders ne suffisent pas, mais ils constituent une partie importante de la réalisation d’un tel effet. Et oui, les shaders ça ne fait pas tout, il faudra souvent les associer à des techniques de rendu (rendu offscreen notamment).</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/users.teledisnet.be_web_mde28256_01c6017f34b24ea68.gif width=auto alt="Image utilisateur"></p><p>:’(</p><p>Ne pleurez pas, je tâcherai de vous enseigner ces techniques au fur et à mesure à travers d’autres tutoriels ;) Et puis sachez qu’il existe aussi des techniques de rendu qui ne se contentent que des shaders.</p><hr><a href=#comment-faire-><h2 id=comment-faire-><span class=hanchor arialabel=Anchor># </span>Comment faire ?</h2></a><p>Malgré quelques explications en début de chapitre, il est important que vous sachiez avec un peu plus de précision comment fonctionne l’implémentation théorique des shaders au sein d’un programme OpenGL.</p><a href=#programmer-un-shader-cest-dur-><h2 id=programmer-un-shader-cest-dur-><span class=hanchor arialabel=Anchor># </span>Programmer un shader, c’est dur ?</h2></a><p>Pour peu que vous sachiez raisonner logiquement, la programmation d’un shader ne devrait pas vous poser de problème ;) Cela n’a en réalité rien de sorcier, et si vous maîtrisez un temps soit peu la programmation d’un langage procédural tel que le C, vous vous apercevrez que le GLSL y ressemble beaucoup ;)</p><p>En effet, le GLSL est un langage ressemblant fortement au langage C.</p><p>Cependant, il est important<strong>impératif</strong> de distinguer deux choses :</p><ul><li><p>la programmation d’un shader en GLSL;</p></li><li><p>son utilisation au sein d’une application OpenGL.</p></li></ul><p>Ces deux choses sont totalement différentes, il est primordial de bien faire leur distinction. Nous avons d’une part la programmation du shader lui-même, c’est-à-dire le codage de la fonction qu’il remplira, l’effet graphique qu’il produira, d’autre part la définition de son utilisation, quand et comment l’utiliser dans notre application.</p><p>Nous pouvons comparer cela à l’utilisation des textures, nous avons d’une part la création de la texture, soit la création de l’image via un logiciel de dessin 2D, et d’autre part le chargement et l’utilisation de cette texture dans notre programme.</p><p>L’idée est la même pour les shaders, nous allons tout d’abord programmer un shader, nous placerons son code source dans un fichier, puis nous programmerons notre application OpenGL et nous chargerons via celle-ci le code source de notre shader afin de l’utiliser à notre convenance au sein de notre programme.</p><a href=#programmer-un-shader-avec-quel-ide-><h2 id=programmer-un-shader-avec-quel-ide-><span class=hanchor arialabel=Anchor># </span>Programmer un shader, avec quel IDE ?</h2></a><p>Il n’existe pas beaucoup d’éditeurs de texte qui colorent le langage GLSL.</p><p>On peut toutefois citer
<a href=http://kate-editor.org/ rel=noopener>Kate</a>, qui bénéficie du support de la coloration syntaxique du GLSL, il active automatiquement celle-ci pour tout fichier ayant pour extension .vert pour les vertex shader, ou .frag pour les fragment shader (ou pixel shader).</p><p>Il existe également
<a href="http://castano.ludicon.com/page.php?page_id=118" rel=noopener>QShaderEdit</a>, un éditeur qui semble assez pratique ainsi que portable (bien qu’il utilise QT), mais que je n’ai jamais testé (merci à
<a href=http://www.siteduzero.com/membres-294-22249.html rel=noopener>XT95</a> pour l’info).</p><a href=#programmer-un-shader-avec-quel-compilateur-><h2 id=programmer-un-shader-avec-quel-compilateur-><span class=hanchor arialabel=Anchor># </span>Programmer un shader, avec quel compilateur ?</h2></a><p>Aucun ! :p</p><p>Vous avez bien lu, il ne vous faut télécharger aucun compilateur. Comme je l’ai déjà dit, les shaders GLSL sont compilés lors de l’exécution de votre application, c’est OpenGL qui s’en charge ;) Donc rien à faire de particulier ici.</p><p>Vous savez à présent qui sont ces fameux shaders, et ce qu’ils permettent de réaliser. Mais vous ne savez pas encore <em>comment</em> le réaliser. Pour l’instant le plus important est que vous ayez compris leur fonctionnement global, il faut pour cela retenir une chose importante : <strong>les shaders sont des programmes exécutés par la carte graphique.</strong></p><p>À partir de cette bonne base, nous allons étudier leur fonctionnement plus en profondeur afin de comprendre comment ils marchent réellement :)</p><a href=#les-spécifications-du-langage><h3 id=les-spécifications-du-langage><span class=hanchor arialabel=Anchor># </span>Les spécifications du langage</h3></a><p>Pour les adeptes des specs, voici
<a href=http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf rel=noopener>les spécifications</a> du langage GLSL.</p><hr><a href=#implémentation-du-glsl-côté-api><h1 id=implémentation-du-glsl-côté-api><span class=hanchor arialabel=Anchor># </span>Implémentation du GLSL côté API</h1></a><p>Vous savez normalement comment fonctionne un shader et quel est son rôle, mais vous ne savez pas encore comment <strong>l’intégrer</strong> dans un programme avec OpenGL. Comment diable va-t-on réussir à utiliser une telle chose dans nos programmes OpenGL ? Comment ça marche ? C’est ce que nous allons étudier dans ce chapitre, nous apprendrons à manier les shaders avec OpenGL.</p><p>L’implémentation des shaders se décompose en plusieurs parties :</p><ul><li><p>premièrement, la <strong>création</strong> d’un shader. Nous verrons comment créer un shader en OpenGL;</p></li><li><p>nous verrons ensuite comment attribuer un contenu à ce shader. Souvenez-vous : un shader est un programme, il possède donc un code source. Nous verrons comment <strong>envoyer un code source</strong> à notre shader précédemment créé;</p></li><li><p>une fois le code source spécifié, il nous faudra le <strong>compiler</strong>. Il faudra également gérer les erreurs, car comme toute compilation, la compilation d’un shader peut échouer;</p></li><li><p>notre shader est fin prêt, mais il n’est pas encore utilisable. Il nous faudra pour cela créer un <strong>program</strong>, car celui-ci peut être exécuté directement par la carte graphique.</p></li></ul><p>Ici nous allons uniquement programmer en C avec l’API OpenGL, ne confondez pas ce que nous allons écrire maintenant avec le langage GLSL, celui-ci ne sera étudié qu’à partir du prochain chapitre.</p><a href=#création-dun-shader><h2 id=création-dun-shader><span class=hanchor arialabel=Anchor># </span>Création d’un shader</h2></a><p>Nous y voilà :)</p><p>Vous vous demandez probablement comment fonctionnent ces tant convoités shaders ? En réalité, ils ne sont pas difficiles à manier rassurez-vous ;)</p><p>Nous allons voir ici la simple opération qu’est la création d’un shader, mais avant cela, il est important de savoir si votre implémentation supporte les shaders GLSL.</p><p>Comment ça ?</p><a href=#les-extensions-des-shaders><h2 id=les-extensions-des-shaders><span class=hanchor arialabel=Anchor># </span>Les extensions des shaders</h2></a><p>Si vous possédez une ancienne carte graphique, vous risquez de ne pas pouvoir utiliser les shaders ou alors leur utilisation conduirait à une erreur indéterminée (erreur de segmentation la plupart du temps :-° ), il est donc important de tester si l’extension correspondante aux shaders GLSL est disponible.</p><p>C’est quoi les extensions ?</p><p>Je vous invite à lire
<a href=http://www.siteduzero.com/tuto-3-17911-1-opengl-les-extensions.html rel=noopener>mon tutoriel sur les extensions d’OpenGL</a>. Il vous expliquera dans le détail ce que sont les extensions, et comment on les utilise.</p><p>Bon OK, et c’est quoi le nom de l’extension des shaders GLSL ?</p><p>Il y en a en fait 4 :D</p><p>Voici la liste des noms des extensions nécessaires à l’utilisation de shaders GLSL dans un programme OpenGL :</p><ul><li><p><strong>GL_ARB_shading_language_100</strong> : support du langage GLSL;</p></li><li><p><strong>GL_ARB_shader_objects</strong> : support des objets de shader (cf plus bas);</p></li><li><p><strong>GL_ARB_vertex_shader</strong> : support des vertex shaders;</p></li><li><p><strong>GL_ARB_fragment_shader</strong> : support des pixel shaders.</p></li></ul><p>Globalement, on peut dire que les shaders GLSL sont supportés à partir des GeForceFX chez nVidia, et à partir du Radeon 9500 chez ATI.</p><a href=#création-dun-shader-1><h2 id=création-dun-shader-1><span class=hanchor arialabel=Anchor># </span>Création d’un shader</h2></a><p>Vous vous souvenez de ce que je vous ai dit dans l’introduction ? Le maniement des shaders ressemble à celui des textures ;) Et c’est quoi une texture ? … (réflexion intense…) un <strong>GLuint</strong> !</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span></code></pre></td></tr></table></div></div><p>Bon, et bien voilà, ça c’est fait… :-°</p><p>Hep hep hep, une minute ! J’ai rien compris moi…</p><p>Eh bien un shader est un objet qui ne se manie qu’à partir de son identifiant, tout comme les textures. Cependant, les shaders ne se manipulent pas avec les habituelles fonctions glGen*, glIs*, glBind* et compagnie, il va donc falloir que je vous fasse découvrir dans un premier temps la fonction qui va venir remplacer glGen*, autrement dit : la fonction qui va créer un shader et nous renvoyer son identifiant. Il s’agit de la fonction glCreateShader, dont voici le prototype :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint glCreateShader(GLenum type);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>type</strong></em> : attend une constante qui peut être GL_VERTEX_SHADER ou GL_FRAGMENT_SHADER. Chacune de ces constantes représente respectivement un shader de sommet et un shader de pixel. Souvenez-vous lors de l’introduction je vous avait dit qu’il existait deux types de shader, et bien c’est ici que vous allez spécifier ce type ;)</li></ul><p>Cette fonction renvoie l’identifiant de l’objet de shader créé.</p><p>Allez, un exemple complet :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span><span class=line><span class=cl>shader = glCreateShader(GL_VERTEX_SHADER);
</span></span></code></pre></td></tr></table></div></div><p>Et voilà, nous avons à présent un shader de sommet prêt à être utilisé :)</p><p>Et quand on ne voudra plus l’utiliser ?</p><p>Alors il faudra le supprimer. Voici le prototype de la fonction qui permet de supprimer un shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glDeleteShader(GLuint shader);
</span></span></code></pre></td></tr></table></div></div><p>Nous l’utiliserons comme ceci au sein de notre programme :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* creation */
</span></span><span class=line><span class=cl>shader = glCreateShader(GL_VERTEX_SHADER);
</span></span><span class=line><span class=cl>if(shader == 0)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    /* erreur de creation :( */
</span></span><span class=line><span class=cl>    return;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* utilisation ... */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* suppression */
</span></span><span class=line><span class=cl>glDeleteShader(shader);
</span></span><span class=line><span class=cl>shader = 0;
</span></span></code></pre></td></tr></table></div></div><p>Notez l’ajout de la dernière ligne de code, ainsi que de la vérification de la valeur de l’identifiant. Tout comme tout autre identifiant d’objet OpenGL, 0 n’est pas un identifiant de shader valide. Bien que cela soit rare, il n’est pas impossible qu’à priori OpenGL vous renvoie 0, il est donc conseillé de tester la valeur de retour de glCreateShader, mais ce n’est pas obligatoire comme avec malloc.</p><p>Pour finir, je vais vous présenter une fonction dont la syntaxe devrait vous être familière : glIsShader. A l’instar des autres fonctions glIs* d’OpenGL, cette fonction permet de savoir si l’identifiant qu’elle reçoit en paramètre est un identifiant de shader valide. Voici le prototype de cette fonction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLboolean glIsShader(GLuint shader);
</span></span></code></pre></td></tr></table></div></div><p>Bien, nous avons réussi à créer un shader… mais quelles sont les fonctions permettant de le manipuler afin de l’utiliser à notre guise ? Eh bien suivez-moi, c’est par là :)</p><hr><a href=#envoi-dun-code-source-à-un-shader><h2 id=envoi-dun-code-source-à-un-shader><span class=hanchor arialabel=Anchor># </span>Envoi d’un code source à un shader</h2></a><p>Nous voici parvenus à la seconde étape de la création d’un shader fonctionnel.</p><p>Nous allons voir ici comment charger notre code source afin de le donner à manger à OpenGL.</p><p>Comment ça ?</p><p>Je vous l’ai déjà dit lors de l’introduction, les shaders sont compilés lors de l’exécution de votre application, il va donc falloir charger leur code source dynamiquement, à partir d’un fichier par exemple ;)</p><p>Pourquoi un shader doit se compiler à l’exécution ? Ça doit être lent non ?</p><p>Ce n’est pas lent du tout rassurez-vous ;) Sans être affirmatif, je pense que les principales raisons à cela sont :</p><ul><li><p>plus simple à gérer, s’il fallait procéder à la compilation séparée des shaders on ne s’en sortirait plus;</p></li><li><p>je pense qu’une compilation à l’exécution permet à OpenGL d’optimiser le shader en fonction du matériel de la machine qui exécute le programme OpenGL.</p></li></ul><a href=#charger-un-code-source-à-partir-dun-fichier><h2 id=charger-un-code-source-à-partir-dun-fichier><span class=hanchor arialabel=Anchor># </span>Charger un code source à partir d’un fichier</h2></a><p>Voilà une étape des plus enfantines, pour peu que vous sachiez utiliser les fichiers dans le langage que vous utilisez pour faire vos programmes OpenGL.</p><p>Je vais ici vous présenter un exemple de code en langage C (langage qui est et sera d’ailleurs utilisé pour tous les exemples). Le but est donc d’obtenir un code source, et qu’est-ce qu’un code source ? Une chaîne de caractères ! Bingo ;) Voyons voir… :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char* LoadSource(const char *filename);
</span></span></code></pre></td></tr></table></div></div><p>Ceci pourrait être un bon prototype pour une fonction ayant pour but de charger le code source de nos shaders :) C’est une fonction simple et générique, je l’adopte ! Il faut à présent la programmer, rien de très sorcier :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char* LoadSource(const char *filename)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    char *src = NULL;   /* code source de notre shader */
</span></span><span class=line><span class=cl>    FILE *fp = NULL;    /* fichier */
</span></span><span class=line><span class=cl>    long size;          /* taille du fichier */
</span></span><span class=line><span class=cl>    long i;             /* compteur */
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on ouvre le fichier */
</span></span><span class=line><span class=cl>    fp = fopen(filename, &#34;r&#34;);
</span></span><span class=line><span class=cl>    /* on verifie si l&#39;ouverture a echoue */
</span></span><span class=line><span class=cl>    if(fp == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible d&#39;ouvrir le fichier &#39;%s&#39;\n&#34;, filename);
</span></span><span class=line><span class=cl>        return NULL;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on recupere la longueur du fichier */
</span></span><span class=line><span class=cl>    fseek(fp, 0, SEEK_END);
</span></span><span class=line><span class=cl>    size = ftell(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on se replace au debut du fichier */
</span></span><span class=line><span class=cl>    rewind(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on alloue de la memoire pour y placer notre code source */
</span></span><span class=line><span class=cl>    src = malloc(size+1); /* +1 pour le caractere de fin de chaine &#39;\0&#39; */
</span></span><span class=line><span class=cl>    if(src == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fclose(fp);
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;erreur d&#39;allocation de memoire!\n&#34;);
</span></span><span class=line><span class=cl>        return NULL;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* lecture du fichier */
</span></span><span class=line><span class=cl>    for(i=0; i&lt;size; i++)
</span></span><span class=line><span class=cl>        src[i] = fgetc(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* on place le dernier caractere a &#39;\0&#39; */
</span></span><span class=line><span class=cl>    src[size] = &#39;\0&#39;;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    fclose(fp);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    return src;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ceci étant fait, nous devons voir à présent comment envoyer notre code source à notre objet <em>shader</em>. Effectivement, OpenGL nous propose de spécifier le code source de notre shader via un <strong>char</strong>*. Ça tombe bien, nous l’avons celui-ci :p</p><p>Voici la fonction qui permet d’envoyer le code source d’un shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glShaderSource(GLuint shader, GLsizei nombre, const GLchar **sources, const GLint *longueur);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>shader</strong></em> : c’est l’identifiant de notre shader, afin que la fonction adresse notre code source à ce shader et pas un autre.</p></li><li><p><em><strong>nombre</strong></em> : c’est le nombre de chaînes contenues dans <em>sources</em>.</p></li><li><p><em><strong>sources</strong></em> : c’est notre code source, décomposé en plusieurs chaînes.</p></li><li><p><em><strong>longueur</strong></em> : un paramètre bizarre autant que compliqué :-° nous le laisserons à NULL, c’est tout à fait autorisé ;)</p></li></ul><p>Hé mais cette fonction attend plusieurs chaînes, mais nous on en a qu’une seule !</p><p>Ce fut également la réaction que j’ai eu lorsque j’ai vu le prototype de la fonction pour la première fois :-° J’ai vite compris que ça n’avait aucune importance, nous avons une seule chaîne, donc nous allons positionner <em>nombre</em> à 1 et nous enverrons l’adresse de notre pointeur sur notre code source.</p><p>Un exemple ? Ok :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char *src = LoadSource(...);
</span></span><span class=line><span class=cl>glShaderSource(shader, 1, &amp;src, NULL);
</span></span></code></pre></td></tr></table></div></div><p>Voilà, notre shader est à présent prêt à être compilé :)</p><p>C’est quoi l’intérêt d’envoyer un code source à OpenGL si ce n’est pas pour qu’il le compile ? Pourquoi ne l’a-t-il pas déjà compilé ?</p><p>Vous restez ainsi maître de votre application et c’est réellement vous qui choisissez quand il doit se passer telle ou telle chose.</p><p>Notez qu’il n’est pas possible de procéder à plusieurs appels de la fonction <em>glShaderSource()</em> afin “d’entasser” les codes sources, seul le dernier code envoyé sera pris en compte !</p><p>Bien, passons à présent à la compilation. Elle a droit à toute une sous-partie et ce n’est pas pour rien, comme nous allons le voir :p</p><hr><a href=#compilation-dun-shader><h2 id=compilation-dun-shader><span class=hanchor arialabel=Anchor># </span>Compilation d’un shader</h2></a><p>Vous avez sans doute l’habitude de compiler vos programmes en C ou dans un autre langage, et en général la procédure se déroule ainsi :</p><ul><li><p>vous enregistrez votre code source dans un fichier;</p></li><li><p>vous demandez la compilation de ce code source;</p></li><li><p>vous tombez sur une erreur de compilation :-°</p></li></ul><p>C’est la dernière étape la plus intéressante :D En effet, imaginez que vous ayez fait une faute dans l’écriture du code de votre shader, OpenGL va alors refuser la compilation et générera une erreur accompagnée d’un message, vous indiquant où vous vous êtes plantés :-° Il est très important de récupérer les messages d’erreur de compilation des shaders, vous ferez probablement des erreurs parfois en programmant vos shaders, ou bien des fautes de frappe. Récupérer une erreur de compilation c’est aussi et surtout récupérer une ligne de code, c’est grâce à elle que vous pourrez localiser votre erreur.</p><p>Nous allons dans un premier temps voir comment compiler un shader, puis nous verrons comment vérifier le succès de cette compilation en récupérant un code d’erreur, en l’analysant, et en agissant en fonction de celui-ci.</p><a href=#compiler-un-shader><h2 id=compiler-un-shader><span class=hanchor arialabel=Anchor># </span>Compiler un shader</h2></a><p>Pour compiler un shader GLSL, rien de compliqué, il existe une fonction dédiée à cela. La fonction permettant de compiler un shader est glCompileShader, tout simplement. Voici son prototype :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glCompileShader(GLuint shader);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>shader</strong></em> : c’est l’identifiant de notre shader à compiler.</li></ul><p>Voici un exemple de code complet, reprenant les exemples précédents (le contenu de la fonction <em>LoadSource()</em> a été enlevé afin d’alléger le code) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint shader;
</span></span><span class=line><span class=cl>    char *src = NULL;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* creation d&#39;un shader de sommet */
</span></span><span class=line><span class=cl>    shader = glCreateShader(GL_VERTEX_SHADER);
</span></span><span class=line><span class=cl>    if(shader == 0)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible de creer le shader\n&#34;);
</span></span><span class=line><span class=cl>        return -1;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* chargement du code source */
</span></span><span class=line><span class=cl>    src = LoadSource(&#34;test.vert&#34;);
</span></span><span class=line><span class=cl>    if(src == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        /* theoriquement, la fonction LoadSource a deja affiche un message
</span></span><span class=line><span class=cl>           d&#39;erreur, nous nous contenterons de supprimer notre shader
</span></span><span class=line><span class=cl>           et de retourner 0 */
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        glDeleteShader(shader);
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* assignation du code source */
</span></span><span class=line><span class=cl>    glShaderSource(shader, 1, (const GLchar**)&amp;src, NULL);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* compilation du shader */
</span></span><span class=line><span class=cl>    glCompileShader(shader);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* liberation de la memoire du code source */
</span></span><span class=line><span class=cl>    free(src);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* verification du succes de la compilation ... */
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* utilisation ... */
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* suppression */
</span></span><span class=line><span class=cl>    glDeleteShader(shader);
</span></span></code></pre></td></tr></table></div></div><p>Ne pas oublier de libérer le pointeur src après la compilation, même si celle-ci a échoué, le code source ne nous sera de toute façon d’aucune utilité.</p><a href=#vérifier-le-succès-dune-compilation><h2 id=vérifier-le-succès-dune-compilation><span class=hanchor arialabel=Anchor># </span>Vérifier le succès d’une compilation</h2></a><p>Comme pour toute compilation, des erreurs sont possibles et leur nature doit être connue. Pour cela, il nous faut savoir si il y a eu une erreur, et s’il y en a une, on récupère le message qu’elle contient et on affiche ce dernier à l’écran.</p><p>Il existe une fonction pour récupérer l’état de la compilation. Plus globalement, il s’agit d’une fonction permettant de récupérer un entier relatif à une information spécifique d’un shader.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetShaderiv(GLuint shader, GLenum type, GLint *result);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>shader</strong></em> : nous placerons ici l’identifiant de notre shader.</p></li><li><p><em><strong>type</strong></em> : il s’agit du type d’état demandé. Nous recherchons l’état de la compilation du shader, nous placerons donc ici la constante GL_COMPILE_STATUS.</p></li><li><p><em><strong>result</strong></em> : il s’agit d’un pointeur sur un entier dans lequel OpenGL écrira la valeur de l’état demandé.</p></li></ul><p>Cette fonction va donc placer dans <em>result</em> la valeur de l’état demandé, en l’occurrence, l’état de la compilation du shader. Nous allons procéder ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint compile_status = GL_TRUE;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* verification du succes de la compilation */
</span></span><span class=line><span class=cl>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compile_status);
</span></span><span class=line><span class=cl>if(compile_status != GL_TRUE)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    /* erreur a la compilation
</span></span><span class=line><span class=cl>       recuperation du log d&#39;erreur */
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Si <em>compile_status</em> est différent de la constante GL_TRUE, une erreur est survenue et il nous faut donc récupérer le message qu’elle contient. Attention, cette procédure n’est à effectuer que si la compilation a échoué, sinon elle est inutile et ne ferait que ralentir l’application. C’est pour cela que nous allons à présent remplir de quelques lignes de code le bloc de ce <strong>if</strong>.</p><a href=#récupérer-les-messages-derreur-de-la-compilation><h2 id=récupérer-les-messages-derreur-de-la-compilation><span class=hanchor arialabel=Anchor># </span>Récupérer les messages d’erreur de la compilation</h2></a><p>Bien, supposons qu’une erreur soit intervenue, nous nous trouvons à présent dans le bloc du <strong>if</strong> du code précédent, et il nous faut agir.</p><p>Le message d’erreur se trouve sous la forme d’une chaîne de caractères, mais attention, OpenGL n’allouera aucune mémoire pour nous, il va donc falloir lui demander quelle est la taille du message d’erreur, allouer une chaîne de cette taille puis demander à OpenGL d’écrire le message d’erreur dans notre mémoire fraîchement allouée.</p><p>Nous allons reprendre notre fonction glGetShaderiv, mais cette fois-ci en lui envoyant comme second paramètre (<em>type</em>) la constante GL_INFO_LOG_LENGTH, afin d’obtenir la longueur du message d’erreur :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint logsize;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logsize);
</span></span></code></pre></td></tr></table></div></div><p>A présent, il nous faut allouer un espace mémoire de la taille de <em>logsize</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>char *log = NULL;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>log = malloc(logsize+1); /* +1 pour le caractere de fin de chaine &#39;\0&#39; */
</span></span><span class=line><span class=cl>if(log == NULL)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    fprintf(stderr, &#34;erreur d&#39;allocation memoire !\n&#34;);
</span></span><span class=line><span class=cl>    return -1; /* ou autre code approprie */
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Et pour finir, nous allons récupérer le message d’erreur en envoyant notre pointeur <em>log</em> à une fonction d’OpenGL appelée glGetShaderInfoLog. Voici le prototype de cette fonction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetShaderInfoLog(GLuint shader, GLsizei max_size, Glsizei *longueur, char *info_log);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>shader</strong></em> : c’est l’identifiant de notre shader.</p></li><li><p><em><strong>max_size</strong></em> : c’est le nombre maximal de bytes qu’OpenGL écrira dans notre mémoire. OpenGL ne dépassera pas cette valeur.</p></li><li><p><em><strong>longueur</strong></em> : c’est la longueur de notre chaîne. C’est un paramètre un peu bizarre je vous l’accorde, nous placerons ici l’adresse de notre variable <em>logsize</em>.</p></li><li><p><em><strong>info_log</strong></em> : c’est l’adresse mémoire dans laquelle OpenGL écrira le message d’erreur.</p></li></ul><p>Il ne faudra évidemment pas oublier de libérer notre mémoire <em>log</em> après avoir affiché son contenu.</p><p>Voyons à présent si vous le voulez bien, un exemple de code complet :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint LoadShader(GLenum type, const char *filename)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    GLuint shader = 0;
</span></span><span class=line><span class=cl>    GLsizei logsize = 0;
</span></span><span class=line><span class=cl>    GLint compile_status = GL_TRUE;
</span></span><span class=line><span class=cl>    char *log = NULL;
</span></span><span class=line><span class=cl>    char *src = NULL;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* creation d&#39;un shader de sommet */
</span></span><span class=line><span class=cl>    shader = glCreateShader(type);
</span></span><span class=line><span class=cl>    if(shader == 0)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible de creer le shader\n&#34;);
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* chargement du code source */
</span></span><span class=line><span class=cl>    src = LoadSource(filename);
</span></span><span class=line><span class=cl>    if(src == NULL)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        /* theoriquement, la fonction LoadSource a deja affiche un message
</span></span><span class=line><span class=cl>           d&#39;erreur, nous nous contenterons de supprimer notre shader
</span></span><span class=line><span class=cl>           et de retourner 0 */
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        glDeleteShader(shader);
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* assignation du code source */
</span></span><span class=line><span class=cl>    glShaderSource(shader, 1, (const GLchar**)&amp;src, NULL);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* compilation du shader */
</span></span><span class=line><span class=cl>    glCompileShader(shader);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* liberation de la memoire du code source */
</span></span><span class=line><span class=cl>    free(src);
</span></span><span class=line><span class=cl>    src = NULL;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* verification du succes de la compilation */
</span></span><span class=line><span class=cl>    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compile_status);
</span></span><span class=line><span class=cl>    if(compile_status != GL_TRUE)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        /* erreur a la compilation recuperation du log d&#39;erreur */
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        /* on recupere la taille du message d&#39;erreur */
</span></span><span class=line><span class=cl>        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logsize);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        /* on alloue un espace memoire dans lequel OpenGL ecrira le message */
</span></span><span class=line><span class=cl>        log = malloc(logsize + 1);
</span></span><span class=line><span class=cl>        if(log == NULL)
</span></span><span class=line><span class=cl>        {
</span></span><span class=line><span class=cl>            fprintf(stderr, &#34;impossible d&#39;allouer de la memoire !\n&#34;);
</span></span><span class=line><span class=cl>            return 0;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        /* initialisation du contenu */
</span></span><span class=line><span class=cl>        memset(log, &#39;\0&#39;, logsize + 1);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        glGetShaderInfoLog(shader, logsize, &amp;logsize, log);
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;impossible de compiler le shader &#39;%s&#39; :\n%s&#34;,
</span></span><span class=line><span class=cl>                filename, log);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        /* ne pas oublier de liberer la memoire et notre shader */
</span></span><span class=line><span class=cl>        free(log);
</span></span><span class=line><span class=cl>        glDeleteShader(shader);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        return 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    return shader;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Et voilà, nous avons une fonction opérationnelle capable de charger un shader à partir d’un fichier :) La fonction renvoie 0 en cas d’erreur, ou bien l’identifiant du shader créé si elle a réussi.</p><hr><a href=#création-et-utilisation-dun-program><h2 id=création-et-utilisation-dun-program><span class=hanchor arialabel=Anchor># </span>Création et utilisation d’un program</h2></a><p>“program” ? C’est quoi ce nouveau mot ?</p><p>C’est comme cela que l’on appelle les program de shader en OpenGL. Un peu flou ? :D Nous venons de voir comment créer un shader, mais ce shader n’est hélas pas exécutable, la seule chose qui soit exécutable est un program.</p><p>Un program recueille un ou deux shaders, et il est exécutable par la carte graphique.</p><a href=#créer-un-objet-de-program><h2 id=créer-un-objet-de-program><span class=hanchor arialabel=Anchor># </span>Créer un objet de program</h2></a><p>Et oui, nous revoilà à nouveau avec des objets OpenGL, eux aussi différents de tous ceux que vous aurez pu manipuler jusqu’à maintenant.</p><p>Rassurez-vous toutefois, leur fonctionnement est très simple :) La base des objets OpenGL est d’ailleurs reprise, un objet de program est un GLuint (entier non signé) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLuint program;
</span></span></code></pre></td></tr></table></div></div><p>La création d’un program est simple, il suffit d’appeler la fonction <em>glCreateProgram()</em> qui ne prend aucun paramètre, et retourne simplement l’identifiant du program créé :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>program = glCreateProgram();
</span></span></code></pre></td></tr></table></div></div><p>Jusque là, pas de difficulté majeure :-°</p><p>Idem pour la suppression d’un program, cela se fait en toute simplicité avec la fonction <em>glDeleteProgram()</em>. Un exemple ? :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glDeleteProgram(program);
</span></span></code></pre></td></tr></table></div></div><p>Pour l’instant, notre program ne fait rien, il va donc falloir lui donner des shaders à exécuter.</p><a href=#association-dun-ou-plusieurs-shaders-à-un-program><h2 id=association-dun-ou-plusieurs-shaders-à-un-program><span class=hanchor arialabel=Anchor># </span>Association d’un ou plusieurs shaders à un program</h2></a><p>Oui, vous avez bien lu.</p><p>Comme je l’ai déjà dit, un program est un recueil de un ou deux shaders. On peut y mettre soit un vertex shader, soit un pixel shader, soit les deux.</p><p>Pour clarifier vos idées dès à présent, je vous ai préparé un petit schéma :) Voici la procédure à suivre pour créer un program exécutable :</p><ol><li><p>créer un vertex shader, nous allons l’appeler <em>VS</em>;</p></li><li><p>créer un pixel shader, nous allons l’appeler <em>PS</em>;</p></li><li><p>créer un program, nous l’appellerons <em>Program</em>;</p></li><li><p>incorporer (je fais de la cuisine là :-° ) le vertex et le pixel shader dans le program;</p></li><li><p>rendre le program exécutable en le liant (nous verrons plus bas en quoi cela consiste);</p></li><li><p>le program étant lié, nous pouvons supprimer nos shaders VS et PS si nous en avons plus besoin;</p></li><li><p>utiliser le program à notre guise :)</p></li><li><p>détruire les shaders (si ce n’est pas déjà fait) et le program.</p></li></ol><p>Et voici le schéma correspondant :) :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_640_f2c7faf9a7d448d09.gif width=auto alt="Image utilisateur"></p><p>Ici, trois notions qui vous sont encore inconnues ont été introduites, il s’agit de “attach”, “construction” et “utilisation”. Nous allons sans plus tarder nous intéresser à “attach”.</p><p>Bon, nous voulons donc associer un ou plusieurs shaders à un program. Il existe pour cela une fonction très simple, <em>glAttachShader()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glAttachShader(GLuint program, GLuint shader);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>program</strong></em> : il s’agit là du program qui recevra le shader.</p></li><li><p><em><strong>shader</strong></em> : c’est le shader à associer à <em>program</em>.</p></li></ul><p>Son utilisation est tellement simple qu’on en pleurerait :’( Je vous épargne l’exemple de code pour cette fonction, je pense que ça serait inutile.</p><p>A l’inverse de <em>glAttachShader()</em>, il existe une fonction qui a l’effet contraire. Supposez que vous vouliez mettre à jour un shader, il faudra d’abord que vous le détachiez du program auquel il a été attaché via <em>glAttachShader()</em>, utilisez pour cela <em>glDetachShader()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glDetachShader(GLuint program, GLuint shader);
</span></span></code></pre></td></tr></table></div></div><p>Je pense qu’elle se passe de commentaire ;)</p><p>Bien, nous savons à présent comment créer un program exécutable, comment lui assigner des shaders, mais nous ne savons toujours pas comment l’utiliser. Toutefois avant de pouvoir utiliser un program, il est important de le rendre opérationnel en le liant.</p><a href=#liage-dun-program-de-shader><h2 id=liage-dun-program-de-shader><span class=hanchor arialabel=Anchor># </span>Liage d’un program de shader</h2></a><p>Le liage (ou linking) d’un program peut se comparer à la compilation des shaders car il se décompose également en deux étapes :</p><ul><li><p>le liage en lui même;</p></li><li><p>la vérification du succès de ce liage.</p></li></ul><p>Oui mais qu’est-ce que le liage d’un program ? Et bien en fait lorsqu’on lie un program de shader on demande à OpenGL de lier le vertex shader avec le pixel shader. Cette liaison peut échouer dans la mesure où les deux shaders peuvent être incompatibles entre eux.</p><p>Nous verrons dans une autre partie de ce tutoriel en quoi consiste réellement le linking et ce qu’il apporte.</p><p>Bien, passons à présent au vif du sujet : nous voulons lier un program de shaders. Pour ce faire, il existe une simple fonction appelée <em>glLinkProgram()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glLinkProgram(GLuint program);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>program</strong></em> : c’est le program que l’on souhaite lier.</li></ul><p>Comme je l’ai dit plus haut, l’étape suivante consiste à vérifier que le liage a bien fonctionné. La méthode employée est très similaire à celle des shaders :</p><ul><li><p>on vérifie si une erreur est présente;</p></li><li><p>s’il y en a une, on récupère la taille de la chaîne contenant le message d’erreur;</p></li><li><p>on alloue un espace mémoire de cette taille;</p></li><li><p>on indique l’adresse de cette mémoire à OpenGL pour qu’il puisse y écrire le message d’erreur.</p></li></ul><p>Voici la fonction permettant (entre autres) de savoir si une erreur a été levée :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetProgramiv(GLuint program, GLenum type, GLint *result);
</span></span></code></pre></td></tr></table></div></div><p>Son fonctionnement est identique à glGetShaderiv pour les shaders, je vais donc passer les descriptions minutieuses. Tout ce que vous devez savoir ici, c’est la constante à passer à <em>type</em> pour obtenir ce que l’on cherche. Nous cherchons l’état du précédent liage du program, pour cela nous allons passer la constante GL_LINK_STATUS. La vérification de la valeur de <em>result</em> fonctionne de la même façon que pour les shaders, si elle est différente de GL_TRUE, alors une erreur a été levée.</p><p>Etape suivante, nous voulons récupérer la longueur du message d’erreur, nous allons utiliser pour cela glGetProgramiv avec comme paramètre <em>type</em> la constante GL_INFO_LOG_LENGTH (comme pour les shaders).</p><p>Enfin, pour récupérer le message d’erreur, nous avons à notre disposition la fonction glGetProgramInfoLog :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glGetProgramInfoLog(GLuint program, GLsizei max_size, GLsizei *longueur, char *log);
</span></span></code></pre></td></tr></table></div></div><p>Son fonctionnement est lui aussi identique à la fonction glGetShaderInfoLog pour les shaders.</p><p>Un exemple de code complet sera disponible à la fin du chapitre.</p><a href=#utiliser-un-program-de-shader><h2 id=utiliser-un-program-de-shader><span class=hanchor arialabel=Anchor># </span>Utiliser un program de shader</h2></a><p>Ah ! Nous voici arrivés à la partie la plus intéressante :)</p><p>Résumons une fois de plus si vous le voulez bien :</p><ul><li><p>nous savons créer un shader;</p></li><li><p>nous savons créer un program exécutable;</p></li><li><p>nous savons attribuer à ce program des shaders à exécuter;</p></li><li><p>nous ne savons pas comment rendre ce program actif :-°</p></li></ul><p>Utiliser un program, c’est le rendre actif pour tous les prochains rendus jusqu’à ce que l’on demande explicitement l’arrêt de l’utilisation d’un quelconque program de shader, ou jusqu’à ce que l’on active un autre program de shader.</p><p>Comme toujours, je vais reprendre mon exemple sur la similitude avec les textures. Vous savez certainement comment on rend une texture active ?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBindTexture(GL_TEXTURE_2D, tex_id);
</span></span></code></pre></td></tr></table></div></div><p>Ce code rend la texture <em>tex_id</em> active pour tous les prochains rendus jusqu’à ce qu’un appel de glBindTexture avec un identifiant de 0 soit effectué :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* desactive la precedente texture active */
</span></span><span class=line><span class=cl>glBindTexture(GL_TEXTURE_2D, 0);
</span></span></code></pre></td></tr></table></div></div><p>Vous noterez que pour les textures, l’emploi de glDisable(GL_TEXTURE_2D) est préférable, mais pour utiliser un program de shader, aucun état OpenGL n’est à activer.</p><p>Bien, il est temps de vous présenter la fonction qui permet de rendre un program actif pour le rendu :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUseProgram(GLuint program);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>program</strong></em> : il s’agit là de l’identifiant du program que l’on souhaite activer, si cet identifiant est de 0, OpenGL désactivera l’utilisation des programs de shaders.</li></ul><p>Allez, un exemple pour le fun :-° :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* super rendus avec des effets de la mort qui tue */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* desactive l&#39;utilisation des shaders, OpenGL retourne en mode normal (passe par le FFP) */
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span></code></pre></td></tr></table></div></div><p>Tout comme les textures, vous pouvez charger plusieurs shaders en début de programme et ensuite les utiliser simultanément, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glUseProgram(prog1);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* rendus utilisant le program prog1 */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(prog2);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* rendus utilisant le program prog2 */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(prog3);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* rendus utilisant le program prog3 */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* fin des rendus utilisant les shaders */
</span></span></code></pre></td></tr></table></div></div><p>Attention toutefois, comme avec les textures, il est impossible d’utiliser deux programs à la fois. Ici, le second appel à glUseProgram défini prog2 comme étant actif <strong>à la place</strong> de prog1.</p><hr><a href=#un-exemple-complet><h1 id=un-exemple-complet><span class=hanchor arialabel=Anchor># </span>Un exemple complet</h1></a><p>Voilà, je crois que nous avons abordé toutes les facettes de la gestion des shaders GLSL du côté de l’API :) Bien sûr, il reste encore quelques détails, mais je vous les ferai connaître plus tard, pour l’instant ils ne feraient que vous embrouiller croyez-moi ;)</p><p>Afin que vous vous fassiez une meilleure idée de la façon dont tout ce bazar s’assemble, je vous ai préparé un programme complet chargeant un simple vertex shader qui a pour effet de transformer l’image affichée en couleurs négatives. Pour activer le shader, vous devez appuyer sur une touche du clavier.</p><p><a href=http://yno.goldzoneweb.info/sdz/ch2.zip rel=noopener>Télécharger l’exemple de code et le Makefile Unix</a></p><p>J’utilise
<a href=http://glew.sourceforge.net/ rel=noopener>Glew</a> pour charger les extensions d’OpenGL, vous devez le posséder si vous voulez pouvoir compiler/recompiler le code source. L’exécutable fourni utilise la glibc2.4</p><p>Que les utilisateurs de MacOS et Windows m’excusent, je n’utilise pas ces OS et par conséquent je n’ai pas pu vous mijoter quelque chose, il va falloir que vous vous débrouilliez pour compiler les sources :euh: Toutefois je vous recommande fortement de télécharger ces sources pour les étudier afin de bien comprendre comment fonctionne le chargement et l’utilisation des shaders. N’hésitez pas à relire les parties du chapitre que vous n’avez pas comprises, avec l’exemple de code sous les yeux afin de bien faire la relation entre ce que j’explique et la mise en pratique ;)</p><p>Un peu à l’instar de Kayl avec son sdlglutils, je vous propose de télécharger cet ensemble de deux fichiers qui proposent quelques fonctions bien pratiques pour charger un shader simplement sans trop se fatiguer :</p><p><a href=http://yno.goldzoneweb.info/sdz/loadprogram.zip rel=noopener>Télécharger loadprogram.zip</a></p><p>Ce sont en réalité les fonctions que nous avons construites ensembles, avec quelques petits ajouts toutefois ;) Dorénavant j’utiliserai ces fonctions pour le chargement des shaders afin d’alléger les exemples de code.</p><p>Ces deux exemples de code sont distribués sous licence GPL ;)</p><p>Ouf, nous voici enfin arrivés au terme de ce long chapitre ! :)</p><p>Vous savez à présent comment utiliser les shaders dans vos programmes OpenGL, les activer, les désactiver, etc… Mais (parce qu’il y a un mais :-° ), vous ne savez pas programmer un shader.</p><p>Et d’ailleurs, ça vous dirait de savoir les programmer, ces fameux shaders ? Oui ? Pas de problème, c’est par ici :)</p><hr><a href=#les-bases-du-langage><h2 id=les-bases-du-langage><span class=hanchor arialabel=Anchor># </span>Les bases du langage</h2></a><p>Nous y voilà enfin, nous allons ici commencer à apprendre le langage GLSL qui est un langage de programmation de shaders conçu pour OpenGL.</p><p>Nous étudierons d’abord les bases du langage :</p><ul><li><p>les variables et leur types ;</p></li><li><p>la surcharge des opérateurs ;</p></li><li><p>le cast (très important et très employé en GLSL).</p></li></ul><p>Nous programmerons ensuite de simples vertex et pixel shaders, afin de voir comment ils fonctionnent :) Vous verrez qu’ils utilisent tout deux des variables d’entrée et des variables de sortie, qui nous permettent de recevoir et de renvoyer des données. Les données reçues seront traitées par les instructions contenues dans le code source du shader, pour obtenir un résultat qui sera ensuite renvoyé. Ces résultats représentent généralement des informations de <strong>position à l’écran</strong> pour les vertex shaders, et de <strong>couleur</strong> pour les pixel shaders.</p><a href=#une-forte-ressemblance-avec-le-c><h2 id=une-forte-ressemblance-avec-le-c><span class=hanchor arialabel=Anchor># </span>Une forte ressemblance avec le C</h2></a><p>Le langage GLSL a beaucoup de points communs avec le langage C. Syntaxiquement, les deux langages sont quasiment identiques.</p><a href=#les-variables><h2 id=les-variables><span class=hanchor arialabel=Anchor># </span>Les variables</h2></a><p>Tout comme en C, il est possible de créer des variables en GLSL. Il existe une multitude de types de variables, chacun ayant une utilité bien précise. Par exemple, si vous souhaitez créer une variable capable de stocker des nombres flottants, faites ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float variable;
</span></span></code></pre></td></tr></table></div></div><p>Et oui, comme en C :) Notez également la présence d’un point-virgule, qui se place aux mêmes endroits qu’en C. La création de deux variables à la fois est également autorisée, avec l’ajout d’une virgule entre les deux noms de variable :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float a, b;
</span></span></code></pre></td></tr></table></div></div><p>Les variables préfixées <strong>gl_</strong> sont réservées au langage lui-même, il est donc interdit de créer une variable dont le nom commence par gl_ !</p><p>Il est possible de créer des variables des types suivants :</p><ul><li><p><strong>int</strong> : entier ;</p></li><li><p><strong>float</strong> : flottant ;</p></li><li><p><strong>bool</strong> : booléen, peut valoir <strong>true</strong> ou <strong>false</strong> ;</p></li><li><p><strong>vec2</strong> : vecteur à 2 composantes flottantes ;</p></li><li><p><strong>vec3</strong> : vecteur à 3 composantes flottantes ;</p></li><li><p><strong>vec4</strong> : vecteur à 4 composantes flottantes ;</p></li><li><p><strong>mat2</strong> : matrice 2 * 2 de flottants ;</p></li><li><p><strong>mat3</strong> : matrice 3 * 3 de flottants ;</p></li><li><p><strong>mat4</strong> : matrice 4 * 4 de flottants ;</p></li><li><p><strong>ivec2</strong> : vecteur à 2 composantes entières ;</p></li><li><p><strong>ivec3</strong> : vecteur à 3 composantes entières ;</p></li><li><p><strong>ivec4</strong> : vecteur à 4 composantes entières ;</p></li><li><p><strong>bvec2</strong> : vecteur à 2 composantes booléennes ;</p></li><li><p><strong>bvec3</strong> : vecteur à 3 composantes booléennes ;</p></li><li><p><strong>bvec4</strong> : vecteur à 4 composantes booléennes.</p></li></ul><p>Soudainement, les ressemblances avec le C s’arrêtent :-° Effectivement, le GLSL possède beaucoup de types de variables… qui ne sont finalement plus des variables mais des ensembles de variables. Nous pouvons toutefois les comparer à des structures, et nous allons voir pourquoi. Lorsque vous créez un vecteur à 3 composantes par exemple (<strong>vec3</strong>), GLSL vous permet d’accéder à une seule de ses composante de cette façon :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 direction;
</span></span><span class=line><span class=cl>direction.x = 0.2;
</span></span></code></pre></td></tr></table></div></div><p>La seconde instruction place la valeur 0.2 dans la composante X du vecteur <em>direction</em> grâce à l’opérateur d’affectation =, qui fonctionne de la même façon qu’en C… ou presque.</p><a href=#les-opérateurs><h2 id=les-opérateurs><span class=hanchor arialabel=Anchor># </span>Les opérateurs</h2></a><p>Il est bien sûr possible de multiplier une variable par une autre, ou bien encore de soustraire une valeur à une variable. Les opérateurs en GLSL s’utilisent comme en C, voici un exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float var1 = 0.2, var2 = 3.0;
</span></span><span class=line><span class=cl>float resultat = (var1 - 0.1) * var2;
</span></span></code></pre></td></tr></table></div></div><p>Ici, <em>resultat</em> vaudra (0.2 - 0.1) * 3.0 soit 0.3.</p><p>Et si je vous apprenais qu’on peut multiplier un vecteur par un vecteur, vous me répondriez quoi ?</p><a href=#la-surcharge-des-opérateurs><h3 id=la-surcharge-des-opérateurs><span class=hanchor arialabel=Anchor># </span>La surcharge des opérateurs</h3></a><p>Premier point commun avec le langage C++ : les opérateurs en GLSL sont surchargés.</p><p>Euh, et ça veut dire quoi ?</p><p>Je ne vais pas vous faire une description avancée de ce qu’est la surcharge des opérateurs, mais pour vous expliquer en deux mots, ça veut dire qu’on peut additionner, soustraire, multiplier et diviser tous les types de variable par tous les types de variable !</p><p>J’y comprend rien o_O</p><p>Vous connaissez probablement la multiplication matricielle ? Et bien effectuer ce genre de multiplication en GLSL est un jeu d’enfant :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mat4 a = ..., b = ...;
</span></span><span class=line><span class=cl>mat4 resultat = a * b;
</span></span></code></pre></td></tr></table></div></div><p><em>resultat</em> vaut maintenant le résultat de la multiplication matricielle de <em>a</em> par <em>b</em>. Et ça marche aussi pour les vecteurs ! :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec4 position = ...;
</span></span><span class=line><span class=cl>mat4 m = ...;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>vec4 resultat = m * position;
</span></span></code></pre></td></tr></table></div></div><p><em>resultat</em> vaut à présent la position que représente le vecteur <em>position</em> transformé par la matrice <em>m</em>.</p><p>Notez qu’ici l’ordre de la multiplication est important ! C’est d’abord la matrice, puis le vecteur. Si cela vous semble flou, n’hésitez pas à aller lire
<a href=http://www.siteduzero.com/tuto-3-23978-1-les-matrices.html rel=noopener>le tutoriel de Kayl sur les matrices</a>.</p><p>Allez, encore un exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 vecteur = ...;
</span></span><span class=line><span class=cl>vecteur *= 2.0;
</span></span></code></pre></td></tr></table></div></div><p>La seconde ligne de ce code a pour effet de multiplier chaque composante du vecteur <em>vecteur</em> par 2.</p><a href=#les-limites-de-la-surcharge><h3 id=les-limites-de-la-surcharge><span class=hanchor arialabel=Anchor># </span>Les limites de la surcharge</h3></a><p>Hé oui malheureusement cette surcharge a des limites, on ne peut pas réellement tout faire comme je l’ai dit avant, il existe des exceptions. Ces exceptions sont toutefois logiques et n’ont rien de mystérieux comme nous allons le voir. Par exemple, il est impossible de multiplier une matrice 3*3 par une matrice 4*4, si vous vous y risquez, OpenGL lèvera une erreur lors de la compilation de votre shader. Autre cas typique : les vecteurs, il est impossible d’effectuer une quelconque opération entre deux vecteurs de type différents. Enfin, il est également impossible de multiplier un vecteur à 2 composantes (<strong>vec2</strong>) par une matrice autre qu’une 2*2 (<strong>mat2</strong>), et il en va de même pour tous les autres types, <strong>vec3</strong> avec <strong>mat3</strong> et <strong>vec4</strong> avec <strong>mat4</strong>.</p><p>Maintenant que je vous ai exposé pleins d’inconvénients dûs à la surcharge, je vais vous proposer des une solution :)</p><a href=#le-cast><h2 id=le-cast><span class=hanchor arialabel=Anchor># </span>Le cast</h2></a><p>Tout comme en C, il est possible de forcer la conversion d’un type vers un autre. Ici, la syntaxe est différente que celle du C où l’on fait comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float flottant = (float)entier;
</span></span></code></pre></td></tr></table></div></div><p>En GLSL, le cast d’une variable se fait ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float flottant = float(entier);
</span></span></code></pre></td></tr></table></div></div><p>La conversion explicite de int vers float ou de float vers int n’est pas obligatoire, en revanche, si vous souhaitez convertir un <strong>vec3</strong> en <strong>vec2</strong>, là il va falloir le demander explicitement.</p><p>Comment on peut convertir un vecteur à trois dimensions en un vecteur à deux dimensions ?</p><p>Je ne vais rien vous cacher, et une conversion de ce type amène forcément à une perte de donnée(s), nous allons uniquement conserver dans le vecteur à 2 dimensions deux composantes du vecteur à 3 dimensions. Mais avec le cast, c’est vous qui allez choisir quelles données vous souhaiterez supprimer et quelles données vous souhaiterez garder. (par donnée je sous-entend <em>composante</em> d’un vecteur)</p><p>Étant donné qu’il existe un trop grand nombre de conversions possible (chaque type peut être converti en chaque type), je ne vais pas vous faire une démonstration pour chacune d’entre elles, je vais juste vous fournir la technique à utiliser, elle est logique et fonctionne de la même façon (ou presque) pour tous les types de conversion.</p><p>Nous allons prendre l’exemple de la conversion d’un <strong>vec3</strong> vers un <strong>vec2</strong>, puis nous prendrons ensuite l’exemple inverse, à savoir <strong>vec2</strong> -> <strong>vec3</strong>.</p><p>Pour convertir un vec3 en vec2, une méthode simple existe :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v = ...;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>vec2 v2 = vec2(v);
</span></span></code></pre></td></tr></table></div></div><p>Ce code est simple et pourrait se traduire de la façon suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v = ...;
</span></span><span class=line><span class=cl>vec2 v2;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>v2.x = v.x;
</span></span><span class=line><span class=cl>v2.y = v.y;
</span></span></code></pre></td></tr></table></div></div><p>En réalité, le cast du premier code prend les <em>n</em> premières composantes de la variable à caster et les places dans la variable finale, où <em>n</em> représente le nombre maximal de variables stockables dans le type de la variable finale, dans notre exemple, <em>n</em> vaut 2.</p><p>Vous pouvez également prendre d’autres composantes de <em>v</em> pour les placer dans <em>v2</em> sans avoir à spécifier manuellement les composantes de <em>v</em> qui recevrons la valeur. L’instruction suivante place les composantes de <em>v</em> demandées et les places respectivement dans <em>v2.x</em> et <em>v2.y</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v2 = vec2(v.z, v.x);
</span></span></code></pre></td></tr></table></div></div><p>Voyons à présent comment convertir un <strong>vec2</strong> en <strong>vec3</strong>, nous verrons cette voici qu’à l’inverse d’une conversion <strong>vec3</strong> -> <strong>vec2</strong>, il y a un manque de données. À priori, on pourrait se dire qu’une conversion comme ceci est correct :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v2 = ...;
</span></span><span class=line><span class=cl>vec3 v3 = vec3(v2);
</span></span></code></pre></td></tr></table></div></div><p>Mais…</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>impossible de compiler le shader &#39;test.vert&#39; :
</span></span><span class=line><span class=cl>(5) : error C1033: cast not allowed
</span></span><span class=line><span class=cl>(5) : error C1056: invalid initialization
</span></span></code></pre></td></tr></table></div></div><p>En effet, c’est une instruction non valide, refusée par OpenGL à la compilation du shader.</p><p>Ce que vous avez sous les yeux est le résultat d’une compilation d’un shader ayant échouée, c’est le message d’erreur que nous a retourné OpenGL. La première phrase est de moi, je l’ai placée dans le code source C du programme. Les deux autres lignes contiennent un message mais avant cela, entre parenthèses, la ligne de code de notre shader qui a été refusée (5). C’est très important, retenez cela ;)</p><p>Afin de pouvoir effectuer un cast sans encombre, il va falloir donner à notre shader ce qu’il attend : la composante manquante. (en l’occurrence il s’agit de la composante z) Il nous faut donc la spécifier explicitement, comme dans l’exemple qui suit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v2 = ...;
</span></span><span class=line><span class=cl>vec3 v3 = vec3(v2, 0.0);
</span></span></code></pre></td></tr></table></div></div><p>Ce code est équivalent à :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v2 = ...;
</span></span><span class=line><span class=cl>vec3 v3;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>v3.x = v2.x;
</span></span><span class=line><span class=cl>v3.y = v2.y;
</span></span><span class=line><span class=cl>v3.z = 0.0;
</span></span></code></pre></td></tr></table></div></div><p>Si vous le souhaitez, vous pouvez aussi faire ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v2 = ...;
</span></span><span class=line><span class=cl>vec3 v3 = vec3(0.0, v2);
</span></span></code></pre></td></tr></table></div></div><p>Mais ce code n’aura pas le même effet que le précédent, voici ce que l’on obtient en l’appelant :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v2 = ...;
</span></span><span class=line><span class=cl>vec3 v3;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>v3.x = 0.0;
</span></span><span class=line><span class=cl>v3.y = v2.x;
</span></span><span class=line><span class=cl>v3.z = v2.y;
</span></span></code></pre></td></tr></table></div></div><a href=#initialiser-le-contenu-dun-vecteur><h3 id=initialiser-le-contenu-dun-vecteur><span class=hanchor arialabel=Anchor># </span>Initialiser le contenu d’un vecteur</h3></a><p>Maintenant que vous savez comment fonctionne l’opérateur de cast, vous devriez comprendre facilement ce que fait ce bout de code :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v = vec3(0.0, 1.0, 0.5);
</span></span></code></pre></td></tr></table></div></div><p>Allez cherchez un peu :-°</p><p>…</p><p>Alors vous trouvez ? :D</p><p>…</p><p>Bon, je sens que vous avez fait bouillonner votre cerveau, c’est l’heure de votre récompense :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>v.x = 0.0;
</span></span><span class=line><span class=cl>v.y = 1.0;
</span></span><span class=line><span class=cl>v.z = 0.5;
</span></span></code></pre></td></tr></table></div></div><p>Et voilà l’travail :)</p><p>Il est également possible d’initialiser toutes les composantes d’un vecteur d’un seul coup :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v = vec3(0.0);
</span></span></code></pre></td></tr></table></div></div><p>Ce code place toutes les composantes du vecteur <em>v</em> à 0.</p><a href=#et-les-matrices-><h3 id=et-les-matrices-><span class=hanchor arialabel=Anchor># </span>Et les matrices… ?</h3></a><p>Vous savez quoi ? On peut mettre des vecteurs dans des matrices :D Si si je vous assure :) Ainsi, ce code est tout à fait correct :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec4 a, b, c, d;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>a = vec4(1.0, 0.0, 0.0, 0.0);
</span></span><span class=line><span class=cl>b = vec4(0.0, 1.0, 0.0, 0.0);
</span></span><span class=line><span class=cl>c = vec4(0.0, 0.0, 1.0, 0.0);
</span></span><span class=line><span class=cl>d = vec4(0.0, 0.0, 0.0, 1.0);
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>mat4 m = mat4(a, b, c, d);
</span></span></code></pre></td></tr></table></div></div><p>Ce code a pour effet de charger dans <em>m</em> la matrice d’identité. Bien évidemment, il est inutilement lourd à cause de la création de 4 vecteurs, il n’est là qu’à titre indicatif ;)</p><p>Il est important de noter ici que chaque vecteur représente une ligne de la matrice, c’est-à-dire que le premier vecteur ira se loger de <em>m</em>1,1 à <em>m</em>1,4</p><p>Tout comme pour les vecteurs, il est possible d’initialiser une matrice ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mat3 m = mat3(1.0);
</span></span></code></pre></td></tr></table></div></div><p>Toutefois il y a une différence ici avec les vecteurs. L’initialisation d’une matrice comme nous l’avons fait place toutes les composantes de <strong>la diagonale</strong> de la matrice à 1, et toutes les autres à 0. Avec 1, la matrice chargée est celle d’identité, avec une autre valeur, la matrice est une matrice de mise à l’échelle de la valeur envoyée.</p><a href=#les-commentaires><h2 id=les-commentaires><span class=hanchor arialabel=Anchor># </span>Les commentaires</h2></a><p>Tout comme en C, il est possible d’intégrer des commentaires en GLSL. Ils ont la même forme ainsi que le même comportement :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* commentaire sur
</span></span><span class=line><span class=cl>   plusieurs lignes */
</span></span></code></pre></td></tr></table></div></div><p>Le GLSL accepte également les commentaires commençant par // comme en C99 :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// ceci est un commentaire sur une seule ligne
</span></span></code></pre></td></tr></table></div></div><a href=#les-tableaux><h2 id=les-tableaux><span class=hanchor arialabel=Anchor># </span>Les tableaux</h2></a><p>Encore une similitude avec le C : les tableaux. Ils se définissent et s’utilisent comme en C. Il est interdit de fournir une variable comme taille de tableau lors de sa déclaration, seules les constantes sont acceptées :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float tab[3] = {0.0, 0.5, 1.0};
</span></span></code></pre></td></tr></table></div></div><p>En revanche l’accès aux valeurs contenues dans un tableau est des plus simples, cette fois-ci les variables sont bien sûr acceptées :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int case = 2;
</span></span><span class=line><span class=cl>float val = tab[case]; // val = 1
</span></span></code></pre></td></tr></table></div></div><p>Les tableaux en GLSL commencent également à 0 : tab[0]</p><p>Vous souvenez-vous de la manière dont on accède à une composante d’un vecteur ? Nous faisions comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v = vec2(1.0, 0.0);
</span></span><span class=line><span class=cl>float vx = v.x;
</span></span></code></pre></td></tr></table></div></div><p>Et bien sachez qu’il est possible de considérer un vecteur comme un tableau ! Ainsi, ce code est strictement identique :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 v = vec2(1.0, 0.0);
</span></span><span class=line><span class=cl>float vx = v[0];
</span></span></code></pre></td></tr></table></div></div><p>Notez que l’on préfèrera la première méthode car elle est beaucoup plus légère et beaucoup plus lisible ;) .</p><p>Et pour les matrices ? Il existe aussi un tour de passe-passe ?</p><a href=#les-tableaux-à-deux-dimensions><h3 id=les-tableaux-à-deux-dimensions><span class=hanchor arialabel=Anchor># </span>Les tableaux à deux dimensions</h3></a><p>Rien qu’à la vue de ce titre, j’imagine que vous prévoyez déjà ce que je vais vous dire :D Allons-y franchement : les matrices sont des tableaux à deux dimensions !</p><p>Si vous connaîssez les tableaux à deux dimensions en C, alors vous ne devriez pas avoir de problèmes. Allez, un exemple de code vaudra sûrement mieux qu’un long discours :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mat4 m = mat4(
</span></span><span class=line><span class=cl>    1.0, 0.0, 0.0, 0.0,
</span></span><span class=line><span class=cl>    0.0, 1.0, 0.0, 0.0,
</span></span><span class=line><span class=cl>    0.0, 5.0, 1.0, 0.0,
</span></span><span class=line><span class=cl>    0.0, 0.0, 0.0, 1.0);
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>float var = m[2][1];
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>// ici, var = 5.0
</span></span></code></pre></td></tr></table></div></div><p>Dans <em>m[i][j]</em> on a :</p><ul><li><p><em><strong>i</strong></em> : la ligne (position en hauteur)</p></li><li><p><em><strong>j</strong></em> : la colonne (position en largeur)</p></li></ul><p>Et voilà, rien de très compliqué, encore faut-il le savoir ;) .</p><p>Et comment on crée un tableau à deux dimensions ?</p><p>Comme en C :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float tab[3][3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    {0.0, 0.0, 0.0},
</span></span><span class=line><span class=cl>    {0.0, 0.0, 2.0},
</span></span><span class=line><span class=cl>    {0.0, 0.0, 0.0}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>float var = tab[1][2];
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>// var = 2.0
</span></span></code></pre></td></tr></table></div></div><p>Notez qu’il est impératif de définir la taille d’un tableau lors de sa déclaration en GLSL, contrairement au langage C qui est capable de déduire tout seul de la taille d’un tableau rien que par son contenu. Cette règle s’applique aussi bien aux tableaux 1D que 2D.</p><hr><a href=#un-vertex-shader><h1 id=un-vertex-shader><span class=hanchor arialabel=Anchor># </span>Un vertex shader</h1></a><p>Maintenant que vous avez acquis les bases du langage, ça vous dirait de programmer votre premier vertex shader ? Oui ? Pas de problème, allons-y :p</p><a href=#un-vertex-shader--ça-fait-quoi-><h2 id=un-vertex-shader--ça-fait-quoi-><span class=hanchor arialabel=Anchor># </span>Un vertex shader : ça fait quoi ?</h2></a><p>Un shader est donc un code source qui, une fois compilé, est exécutable par la carte graphique. Quand vous écrivez ce code source en OpenGL :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glColor3f(1.0, 0.0, 0.0); glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glColor3f(0.0, 1.0, 0.0); glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glColor3f(0.0, 0.0, 1.0); glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span></code></pre></td></tr></table></div></div><p>vous envoyez exactement 3 sommets (ou vertices, nom au choix) à la carte graphique. Avant d’être affichés à l’écran ils sont tout d’abord traités; ils subissent de nombreuses transformations, puis les données sont interpolées afin de donner naissance à un triangle plein.</p><p>Et qu’est-ce qu’il fait le vertex shader là dedans ?</p><p>Le vertex shader effectue entre autres la première opération : il fait subir des transformations (matricielles) aux sommets. Il vous permet en fait de toucher à toutes les composantes (coordonnées de texture, normale, couleur, etc…) d’un sommet et de les modifier à votre guise :) Nous allons voir qu’il y a des règles pour le codage d’un vertex shader, mais passé celles-ci vous êtes libres de faire tout ce dont vous avez envie.</p><p>Avec l’exemple ci-dessus, le vertex shader sera invoqué exactement 3 fois, ce qui est très peu. Le nombre d’appel au vertex shader dépend donc du nombre de sommet que comporte votre scène, plus elle en comporte, et plus il y aura d’appels au vertex shader, et donc plus le traitement sera lourd et consommateur de ressources.</p><p><strong>Il est important de savoir :</strong> qu’un vertex shader activé sera actif sur tous les futurs sommets qui seront envoyés à la carte graphique, jusqu’à ce que les shaders de sommet soient désactivés. Quand vous activez un vertex shader, il vient remplacer une partie du FFP, donc tous les sommets envoyés après l’activation du shader seront traités par le vertex shader que vous avez activé.</p><p>Ça a l’air d’être un vrai chantier…</p><p>C’est une réflexion normale :-° Vous vous apercevrez vite que ça n’a rien de sorcier et que le langage a été bien pensé, ce n’est pas si difficile que ça en a l’air rassurez-vous, et puis, je suis là pour vous guider :D</p><a href=#quelques-règles-de-programmation><h2 id=quelques-règles-de-programmation><span class=hanchor arialabel=Anchor># </span>Quelques règles de programmation</h2></a><p>Tout comme en C, la programmation d’un shader ne se fait pas à “l’arrache”, il y a des règles à respecter.</p><a href=#la-fonction-main><h3 id=la-fonction-main><span class=hanchor arialabel=Anchor># </span>La fonction main</h3></a><p>En GLSL une fonction principale appelée <em>main()</em> est nécessaire. Cette dernière se différencie des habituelles formes du <em>main()</em> du langage C par sa valeur de retour et ses arguments : la fonction main en GLSL ne renvoie rien et ne prend aucun paramètre.</p><p>Nous l’invoquerons comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // notre code ici
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Comme en C, la fonction main représente la première fonction qui sera exécutée.</p><p>Contrairement au C, les codes sources GLSL ne réclament pas de retour chariot en fin de fichier.</p><p>C’est quoi un retour chariot ?</p><p>C’est un retour à la ligne (entrée) tout à la fin du fichier.</p><p>Enfin, une dernière chose à retenir : un vertex shader doit <strong>toujours</strong> placer une valeur dans la variable de sortie gl_Position.</p><p>Hein ? C’est quoi ce truc ?</p><a href=#les-variables-dentréesortie><h2 id=les-variables-dentréesortie><span class=hanchor arialabel=Anchor># </span>Les variables d’entrée/sortie</h2></a><p>Il est ici important de se rappeler ce qu’est en gros un vertex shader : son objectif est d’agir sur le traitement de chaque vertex qu’on lui enverra. Nous allons à présent voir quel est le rôle précis d’un vertex shader, et ce qu’il permet de faire.</p><a href=#les-variables-dentrée><h3 id=les-variables-dentrée><span class=hanchor arialabel=Anchor># </span>Les variables d’entrée</h3></a><p>Les variables d’entrée sont généralement destinées à être lues puis traitées. Lorsque vous programmerez un vertex shader (et uniquement un vertex shader), OpenGL aura créé pour vous quelques variables utiles, dont voici justement la liste :</p><table><thead><tr><th>Nom de la variable GLSL</th><th>Type</th><th>Fonction OpenGL appropriée</th><th>Description</th></tr></thead><tbody><tr><td>gl_Vertex</td><td><strong>vec4</strong></td><td><em>glVertex</em>()*</td><td>Position du sommet</td></tr><tr><td>gl_Color</td><td><strong>vec4</strong></td><td><em>glColor</em>()*</td><td>Couleur du sommet</td></tr><tr><td>gl_Normal</td><td><strong>vec3</strong></td><td><em>glNormal</em>()*</td><td>Normale du sommet.</td></tr><tr><td>gl_MultiTexCoord<em>n</em></td><td><strong>vec4</strong></td><td><em>glMultiTexCoord</em>()* ou <em>glTexCoord</em>()*</td><td>Coordonnées de l’unité de texture <em>n</em></td></tr><tr><td>gl_SecondaryColor</td><td><strong>vec4</strong></td><td><em>glSecondaryColor</em>()*</td><td>Couleur secondaire du sommet</td></tr><tr><td>gl_FogCoord</td><td><strong>float</strong></td><td><em>glFogCoord</em>()*</td><td>Coordonnées de brouillard</td></tr></tbody></table><p>J’espère qu’à la vue de cette liste vous y voyez déjà plus clair sur la tâche que remplie un vertex shader. Mais je pense que vous y verrez d’autant plus clair lorsque vous aurez vu la liste des variables de sortie ;)</p><a href=#les-variables-de-sortie><h3 id=les-variables-de-sortie><span class=hanchor arialabel=Anchor># </span>Les variables de sortie</h3></a><p>Après avoir traité les variables d’entrées à notre guise, nous pourrons écrire dans les variables de sortie. Les variables de sortie d’un vertex shader (uniquement) représentent la position finale du sommet (position écran, ou presque) sa couleur finale, etc… Voici la liste des variables de sortie disponibles :</p><table><thead><tr><th>Nom de la variable GLSL</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_Position</td><td><strong>vec4</strong></td><td>Position en coordonnées écran du sommet</td></tr><tr><td>gl_FrontColor</td><td><strong>vec4</strong></td><td>Couleur du côté “avant” de la face à laquelle<br>est rattaché le sommet</td></tr><tr><td>gl_BackColor</td><td><strong>vec4</strong></td><td>Couleur du côté “arrière” de la face à laquelle<br>est rattaché le sommet</td></tr><tr><td>gl_FrontSecondaryColor</td><td><strong>vec4</strong></td><td>Couleur secondaire du côté “avant” de la face<br>à laquelle est rattaché le sommet</td></tr><tr><td>gl_BackSecondaryColor</td><td><strong>vec4</strong></td><td>Couleur secondaire du côté “arrière” de la face<br>à laquelle est rattaché le sommet</td></tr><tr><td>gl_TexCoord[n]</td><td>tableau de <strong>vec4</strong></td><td>Coordonnées de l’unité de texture <em>n</em></td></tr><tr><td>gl_FogFragCoord</td><td><strong>float</strong></td><td>Coordonnée de fog</td></tr><tr><td>gl_PointSize</td><td><strong>float</strong></td><td>Taille du point du sommet</td></tr><tr><td>gl_ClipVertex</td><td><strong>vec4</strong></td><td>Vecteur utilisé pour les plans de clipping</td></tr></tbody></table><p>On y voit tout de suite plus clair n’est-ce pas ? :D Vous pouvez déjà vous faire une petite idée de la fonction d’un vertex shader à la vue de ces deux tableaux.</p><p>Vous vous souvenez de la règle de base pour un vertex shader ? C’est que la variable gl_Positiondoit être affectée à une valeur à la fin du vertex shader, sinon le vertex shader est invalide. Nous pouvons donc construire un vertex shader de base, tout simple, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_Position = gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ce vertex shader est tout à fait correct, mais sa fonctionnalité laisse à désirer :-° Je vous propose tout de même de l’étudier, afin de mettre les choses au clair pour la gestion des vertex shaders.</p><p>Si vous appliquez ce vertex shader à vos rendus, les données envoyées à la fonction <em>glVertex</em>()* seront les coordonnées <strong>écran</strong> de vos sommets, même si vous utilisez une transformation quelconque (<em>glTranslate</em>()* et compagnie) <strong>elle ne sera pas appliquée au sommet</strong> ! Idem pour la matrice de projection, elle n’affectera pas la position que vous aurez envoyé à la fonction <em>glVertex</em>()*.</p><p>C’est un peu débile non ?</p><p>Non ! C’est ce qui fait la flexibilité des shaders, c’est vous qui décidez exactement comment vos sommets seront rendus, vous êtes le maître absolu de votre machine :)</p><p>Et alors comment on fait pour que notre vertex soit au bon endroit en subissant les transformations de nos matrices modelview et de projection ?</p><a href=#les-matrices-quelques-variables-dentrée-supplémentaires><h2 id=les-matrices-quelques-variables-dentrée-supplémentaires><span class=hanchor arialabel=Anchor># </span>Les matrices, quelques variables d’entrée supplémentaires</h2></a><p>Si vous avez à peu près compris ce que sont les variables d’entrée, vous devriez sauter au plafond à la vue de ce titre :D</p><p>Ah bon ? Moi ça ne fait que m’embrouiller encore plus… Qu’est-ce qu’elles peuvent nous faire ces matrices ?</p><p>Chers Zér0s, vous devriez savoir comment fonctionne le rendu d’un sommet et quelles sont les transformations qui lui sont appliquées, sinon c’est que vous n’êtes pas totalement prêts à lire ce tutoriel. Bien sûr je pourrais vous faire gober des principes tout cuits, mais ça ne serait pas très pédagogique en plus du fait que vous risqueriez d’être un peu bloqué par la suite. Sur ce, je vous renvoie sur
<a href="http://jeux.developpez.com/faq/3d/?page=definitions#DEFINITIONS_3d_to_2d" rel=noopener>cet excellent lien</a> qui vous expliquera comment on passe des coordonnées 3D aux coordonnées écran.</p><a href=#vous-avez-dit-variable-dentrée-><h3 id=vous-avez-dit-variable-dentrée-><span class=hanchor arialabel=Anchor># </span>Vous avez dit “variable d’entrée” ?</h3></a><p>Parfaitement :) Ces variables ne sont rien d’autre que des matrices, et ô combien utiles. Je vous propose de voir sans plus tarder la listes des matrices disponibles au sein d’un vertex shader uniquement :</p><table><thead><tr><th>Nom de la variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_ModelViewMatrix</td><td><strong>mat4</strong></td><td>C’est la matrice de modélisation/visualisation,<br>celle que l’on manipule avec GL_MODELVIEW en C</td></tr><tr><td>gl_ModelViewMatrixInverse</td><td><strong>mat4</strong></td><td>C’est l’inverse de la matrice gl_ModelViewMatrix</td></tr><tr><td>gl_ModelViewMatrixTranspose</td><td><strong>mat4</strong></td><td>C’est la transposée de la matrice gl_ModelViewMatrix</td></tr><tr><td>gl_ModelViewMatrixInverseTranspose</td><td><strong>mat4</strong></td><td>C’est la transposée de la matrice gl_ModelViewMatrixInverse</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_ProjectionMatrix</td><td><strong>mat4</strong></td><td>C’est la matrice de projection GL_PROJECTION, maniable<br>entre autres avec gluPerspective() dans le code C</td></tr><tr><td>gl_ProjectionMatrixInverse</td><td><strong>mat4</strong></td><td>C’est l’inverse de la matrice gl_ProjectionMatrix</td></tr><tr><td>gl_ProjectionMatrixTranspose</td><td><strong>mat4</strong></td><td>C’est la transposée de la matrice gl_ProjectionMatrix</td></tr><tr><td>gl_ProjectionMatrixInverseTranspose</td><td><strong>mat4</strong></td><td>C’est la transposée de la matrice gl_ProjectionMatrixInverse</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_ModelViewProjectionMatrix</td><td><strong>mat4</strong></td><td>C’est la matrice gl_ModelViewMatrix multipliée<br>par la matrice gl_ProjectionMatrix</td></tr><tr><td>gl_ModelViewProjectionMatrixInverse</td><td><strong>mat4</strong></td><td>C’est l’inverse de la matrice gl_ModelViewProjectionMatrix</td></tr><tr><td>gl_ModelViewProjectionMatrixTranspose</td><td><strong>mat4</strong></td><td>C’est la transposée de la matrice gl_ModelViewProjectionMatrix</td></tr><tr><td>gl_ModelViewProjectionMatrixInverseTranspose</td><td><strong>mat4</strong></td><td>C’est la transposée de la matrice gl_ModelViewProjectionMatrixInverse</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_TextureMatrix[n]</td><td>tableau de <strong>mat4</strong></td><td>C’est la matrice de l’unité de texturage <em>n</em>,<br>maniable en C avec GL_TEXTURE</td></tr><tr><td>gl_TextureMatrixInverse[n]</td><td>tableau de <strong>mat4</strong></td><td>C’est l’inverse de la matrice gl_TextureMatrix[n]</td></tr><tr><td>gl_TextureMatrixTranspose[n]</td><td>tableau de <strong>mat4</strong></td><td>C’est la transposée de la matrice gl_TextureMatrix[n]</td></tr><tr><td>gl_TextureMatrixInverseTranspose[n]</td><td>tableau de <strong>mat4</strong></td><td>C’est la transposée de la matrice gl_TextureMatrixInverse[n]</td></tr><tr><td>---</td><td>---</td><td>---</td></tr><tr><td>gl_NormalMatrix</td><td><strong>mat3</strong></td><td>C’est la transposée inverse de la partie 3*3 de la matrice gl_ModelViewMatrix<br>(matrice généralement appliquée à la variable gl_Normal<br>pour les transformations de normales)</td></tr></tbody></table><p>Pffiouuu, ça fait du monde hein ? :D Allez, que diriez-vous d’un petit…</p><a href=#exercice><h3 id=exercice><span class=hanchor arialabel=Anchor># </span>Exercice</h3></a><p>Fini d’rire ! :diable:</p><p>Bien, voici le vertex shader que nous avons précédemment écrit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_Position = gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>J’aimerai que vous le modifiez afin que la position finale du sommet (gl_Position) soit affectée par la matrice de modélisation <strong>et</strong> la matrice de projection, comme ça notre sommet aura la bonne position à l’écran si par exemple nous avons configuré une projection 3D :) Un indice ? Rappelez-vous la première partie du tutoriel, à l’endroit où je parle des opérateurs, et plus précisément de leur surcharge ;)</p><p>Allez-y !</p><p>…</p><a href=#correction><h3 id=correction><span class=hanchor arialabel=Anchor># </span>Correction</h3></a><p>Voici la réponse :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Allez, avouez que c’était pas trop difficile :-°</p><p>Voilà, vous savez à présent théoriquement comment faire un vertex shader, évidemment celui-ci est extrêmement simple et n’a que peu d’intérêt, mais vous pouvez déjà essayer de vous amuser à modifier les variables de sortie pour voir le résultat que cela donnera et aussi pour vous familiariser avec le langage GLSL ;)</p><hr><a href=#un-pixel-shader><h2 id=un-pixel-shader><span class=hanchor arialabel=Anchor># </span>Un pixel shader</h2></a><p>Nous avons vu en gros quel était la tâche d’un vertex shader, son rôle au sein du rendu 3D. Que diriez-vous de savoir ce que fait un pixel shader à présent ? Vous vous demandez probablement à quoi ils peuvent bien servir, mais croyez-moi : ils servent énormément ;)</p><a href=#traiter-le-rendu-dun-pixel-><h2 id=traiter-le-rendu-dun-pixel-><span class=hanchor arialabel=Anchor># </span>Traiter le rendu d’un pixel ?</h2></a><p>Un pixel shader agit au niveau du rendu du pixel à l’écran. C’est petit, très petit, et pourtant chaque pixel est traité indépendamment et nécessite des calculs, parfois nombreux, pour obtenir sa couleur exacte à l’écran.</p><p>Le code source d’un pixel shader peut être plus ou moins gros, mais une chose est sûre : plus il est conséquent et demande beaucoup de calculs et plus les performances chutent vite. Effectivement, alors que les vertex shaders agissent au niveau de chaque sommet, si vous n’affichez qu’un triangle, le code de votre vertex shader ne sera exécuté qu’une seule fois. Les pixel shaders quant à eux sont exécutés autant de fois qu’il y a de pixels dans ce triangle à l’écran ! Si votre triangle rempli tout l’écran et que votre fenêtre de rendu fait 1024*768 pixels, alors votre pixel shader sera appelé 1024 * 768 = 786432 fois ! C’est beaucoup, très beaucoup ! :D</p><a href=#une-limite-en-puissance-assez-restreinte-><h3 id=une-limite-en-puissance-assez-restreinte-><span class=hanchor arialabel=Anchor># </span>Une limite en puissance assez restreinte ?</h3></a><p>Et pourtant non ! Il est aujourd’hui possible de programmer des pixels shaders très complexes sur des résolutions d’écran de 1600*1024 sans que le frame rate en soit très affecté. Prenez un exemple simple : les jeux vidéo. Les jeux vidéo récents utilisent énormément les shaders, vertex et pixel. Les joueurs s’achètent des écrans toujours plus larges et arrivent tout de même à jouer à des jeux gourmands tels que F.E.A.R ou SplinterCell DA en haute résolution et sans lags (saccades).</p><a href=#pourquoi-><h3 id=pourquoi-><span class=hanchor arialabel=Anchor># </span>Pourquoi ?</h3></a><p>Pourquoi, avec des résolutions énormes, des shaders complexes et des scènes rendues en plusieurs passes les jeux ne mettent pas à genoux les PC modernes ? (bien que certains se plaignent de jouer à 40 FPS :-° ) Comment est-il possible de traiter plusieurs millions, et parfois même milliard(s), d’appels à un pixel shader par seconde ? La réponse est relativement simple : les pixels shaders sont des shaders, et par conséquent ils sont traités par la <strong>carte graphique</strong>.</p><p>Ouah je suis super impressionné… En plus je le savais déjà.</p><p>Croyez-moi, il y a de quoi être impressionné, si vous demandiez à votre processeur de modifier une image pixel par pixel (vous comprendrez mieux cela lorsque nous parlerons des textures, plus loin dans le tutoriel), cela prendrait un temps énorme. Un exemple simple : les logiciels de dessin 2D (The GIMP, Photoshop, …) sont très lourds et parfois aussi très lents à rendre un effet sur vos images, essayez pour voir de regarder quelle est la consommation CPU rien que quand vous dessinez un trait avec un effet de flou ;)</p><p>Les cartes graphiques sont <strong>conçues pour</strong> traiter des pixels, enfin tout du moins les cartes graphiques un minimum récentes. Si vous avez une GeForce 6 ou supérieur, ou une Radeon 9800pro ou supérieur, vous pouvez êtres sûrs que les shaders de sommet tout comme de pixel sont parfaitement supportés ;)</p><a href=#bon-quest-ce-quon-attend-pour-programmer-ça-><h2 id=bon-quest-ce-quon-attend-pour-programmer-ça-><span class=hanchor arialabel=Anchor># </span>Bon, qu’est-ce qu’on attend pour programmer ça ?</h2></a><p>Que vous soyez psychologiquement prêts :D</p><a href=#le-code-source-de-base><h3 id=le-code-source-de-base><span class=hanchor arialabel=Anchor># </span>Le code source de base</h3></a><p>Tout comme le vertex shader, le pixel shader requiert une fonction main. En revanche contrairement aux vertex shaders, les pixel shaders GLSL n’exigent aucun code source de base au sein de la fonction main, ce qui veut dire qu’un pixel shader écrit comme suit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // rien
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>est tout à fait acceptable et compilera sans broncher. Par contre, son effet est plus que maigre : il ne fait <strong>rien</strong>. Et ici, rien signifie rien de rien, autrement dit, rien ne s’affichera à l’écran.</p><p>Avant de pouvoir faire afficher quelque chose à notre pixel shader, il est important de connaître ses variables d’entrée ainsi que celles de sortie, car il en possède, tout comme les vertex shaders.</p><a href=#les-variables-dentrée-1><h3 id=les-variables-dentrée-1><span class=hanchor arialabel=Anchor># </span>Les variables d’entrée</h3></a><p>Comme pour les variables d’entrée de nos vertex shaders, un joli tableau fera l’affaire. Il n’est bien sûr pas important que vous le reteniez par coeur pour l’instant, mais au moins, le jour où vous voudrez une info, vous n’aurez qu’à venir ici ;) :</p><table><thead><tr><th>Nom de la variable GLSL</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_Color</td><td><strong>vec4</strong></td><td>Couleur du pixel</td></tr><tr><td>gl_FragCoord</td><td><strong>vec2</strong></td><td>Coordonnées écran du pixel</td></tr><tr><td>gl_SecondaryColor</td><td><strong>bool</strong></td><td>Couleur secondaire</td></tr><tr><td>gl_TexCoord[n]</td><td>tableau de <strong>vec4</strong></td><td>Coordonnées de l’unité de texturage <em>n</em></td></tr><tr><td>gl_FogFragCoord</td><td><strong>float</strong></td><td>Coordonnée de fog</td></tr></tbody></table><p>Comme vous le voyez, certaines variables correspondent à des variables de sortie du vertex shader. Cela prouve bien que les vertex et les pixel shaders GLSL sont très liés entre eux.</p><p>Nous avons maintenant une couleur récupérable dans la variable gl_Color, chouette, on va pouvoir attribuer une couleur à notre pixel. Mais… il nous manque quelque chose… Comment dire à GLSL qu’on souhaite voir notre pixel avec la couleur contenue dans gl_Color ? Hé bien l’expérience des vertex shaders devrait vous le dire, il nous faut une variable de sortie à laquelle attribuer cette couleur :) .</p><a href=#les-variables-de-sortie-1><h3 id=les-variables-de-sortie-1><span class=hanchor arialabel=Anchor># </span>Les variables de sortie</h3></a><p>C’est bon, c’est fini les gros tableaux de la mort ?</p><p>Et non, pourtant avec un simple pixel shader on peut se demander ce qu’il peut bien faire à part affecter la couleur finale du pixel. Pourtant, il existe deux autres variables de sortie que celle qui permet de renvoyer la couleur du pixel :</p><table><thead><tr><th>Nom de la variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>gl_FragColor</td><td><strong>vec4</strong></td><td>Couleur finale du pixel</td></tr><tr><td>gl_FragDepth</td><td><strong>float</strong></td><td>Profondeur du pixel dans le depth buffer</td></tr><tr><td>gl_FragData[n]</td><td>tableau de <strong>vec4</strong></td><td>En rapport avec <em>glDrawBuffers()</em></td></tr></tbody></table><p>Il n’existe malheureusement encore aucune variable permettant de modifier la position finale du pixel à l’écran.</p><p>L’intérêt général des pixel shaders est plutôt mince non ?</p><p>Pas du tout ! Bon évidemment pour l’instant il est normal que vous soyez sceptiques, mais vous découvrirez au fur et à mesure l’utilité des pixel shaders, et à la fin vous verrez ; on ne s’en passe plus ;)</p><a href=#programmer-un-simple-pixel-shader><h3 id=programmer-un-simple-pixel-shader><span class=hanchor arialabel=Anchor># </span>Programmer un simple pixel shader</h3></a><p>Vous vous souvenez de la façon dont on s’y prend, dans les vertex shaders, pour affecter la variable de sortie gl_Position afin que notre vertex soit positionné au bon endroit ? Et bien le principe est le même dans les pixel shaders lorsqu’on veut affecter la couleur du pixel sortant par la couleur d’entrée de base. Contrairement au vertex shader où il faut appliquer des transformations matricielle pour obtenir la position finale, ici rien de particulier n’est à faire, il suffit de transmettre directement la couleur, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_FragColor = gl_Color; // c&#39;est aussi simple que cela
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ce pixel shader n’est pas très évolué et n’a pour effet que d’affecter à la couleur finale du pixel la couleur interpolée des trois sommets formant le triangle auquel appartient ce pixel. (phrase compliquée je vous l’accorde :-° ) Il n’y a aucun traitement des textures ou autres attributs du vertex, seules les données de couleur (<em>glColor</em>()*) sont traitées.</p><p><strong>Attention</strong> : Comme je l’ai déjà dit, le vertex shader est très lié au pixel shader, ainsi donc, si vous n’affectez pas la variable de sortie gl_FrontColor de votre vertex shader, la variable d’entrée gl_Color du pixel shader ne contiendra aucune valeur ! La valeur par défaut des variables est 0 généralement, vous aurez donc un écran noir si vous ne faites pas un vertex shader conçu comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_FrontColor = gl_Color;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Et voilà, c’est déjà enfin la fin de ce chapitre, peut-être un peu rebutant, mais très important ;) .</p><p>Maintenant la compréhension de la suite du tutoriel vous sera plus aisée, et nous pourrons donc avancer plus vite dans l’apprentissage du langage, et c’est tant mieux, parce que le GLSL c’est bien joli, mais notre but de base c’est d’apprendre des techniques de rendu pour réaliser de chouettes effets graphiques :)</p><p><em>Les tableaux énumératifs de variables de ce chapitre sont inspirés du livre
<a href=http://www.amazon.fr/Open-GL-2-0-Guide-officiel/dp/2744020869 rel=noopener>OpenGL 2.0 Guide Officiel</a>, mais certains sont également disponibles dans les
<a href=http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf rel=noopener>spécifications du langage</a>.</em></p><hr><a href=#notions-supplémentaires><h1 id=notions-supplémentaires><span class=hanchor arialabel=Anchor># </span>Notions supplémentaires</h1></a><p>Au terme de ce chapitre, vous serez fin prêts pour apprendre toutes les fonctionnalités avancées que propose le GLSL, et cela vous permettra de trouver une réelle utilité aux shaders.</p><p>Nous allons tout d’abord passer en revue toutes les notions du langage GLSL qui sont communes à celles du C, puis dans un second temps je vais vous montrer les quelques différences entre les deux langages, afin de mettre les choses au clair. Ensuite, nous apprendrons à créer des fonctions, mais surtout à les surcharger. Vous ne connaissez peut-être pas la notion de surcharge des fonctions, il est donc important que vous l’appreniez, vous verrez que cela ressemble à la surcharge des opérateurs. Puis je finirai par vous présenter quelques fonctions natives du langage GLSL bien pratiques, qui sont très souvent utilisées.</p><a href=#notions-communes-et-incompatibilités-avec-le-c><h2 id=notions-communes-et-incompatibilités-avec-le-c><span class=hanchor arialabel=Anchor># </span>Notions communes et incompatibilités avec le C</h2></a><p>Bien, commençons. Je voudrais tout d’abord vous présenter tout ce qui existe dans le langage GLSL qui se rapporte au C, afin de gagner du temps.</p><p>Le GLSL n’est pas un langage aussi rigoureux que le C, je le considérerais plutôt comme un langage “jouet”, il suffit d’enchaîner quelques instructions dans un <code>main()</code> et le tour est joué. À partir du moment où votre shader fonctionne correctement, il y a peu de chances que vous ayez à le réviser pour une raison autre que sa performance.</p><a href=#notions-communes><h2 id=notions-communes><span class=hanchor arialabel=Anchor># </span>Notions communes</h2></a><p>Je vous propose de commencer par les instructions de contrôle.</p><a href=#les-instructions-ifelse><h3 id=les-instructions-ifelse><span class=hanchor arialabel=Anchor># </span>Les instructions if…else</h3></a><p>En C, il est possible de créer une condition de la façon suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if(condition)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    instructions;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    autres instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Eh bien sachez que ce code fonctionne aussi en GLSL. Par exemple, ceci est tout à fait correct :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int a, b;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>if(a == b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    instructions;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    autres instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>L’omission des accolades est également autorisée si les instructions se résument à une seule instruction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int a, b;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>if(a == b)
</span></span><span class=line><span class=cl>    instruction;
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>    autre instruction;
</span></span></code></pre></td></tr></table></div></div><p>Les opérateurs de comparaison sont les mêmes qu’en C.</p><a href=#instructions-break-et-continue><h3 id=instructions-break-et-continue><span class=hanchor arialabel=Anchor># </span>Instructions break et continue</h3></a><p>Idem qu’en C là encore, les instructions <strong>break</strong> et <strong>continue</strong> existent et ont le même effet qu’en langage C ; à savoir :</p><ul><li><p><strong>break</strong> : sortir de la boucle d’instructions courante ;</p></li><li><p><strong>continue</strong> : poursuivre le déroulement de la boucle d’instructions à partir du “haut” du bloc.</p></li></ul><a href=#la-boucle-dowhile><h3 id=la-boucle-dowhile><span class=hanchor arialabel=Anchor># </span>La boucle do…while</h3></a><p>Comme en C, le mot clé <strong>do</strong> est suivi d’un bloc d’instructions, puis d’une condition entre parenthèses après un <strong>while</strong>, comme dans l’exemple ci-dessous :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>do
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    instructions;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>while(condition);
</span></span></code></pre></td></tr></table></div></div><p>Ce code veut dire :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>exécuter
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    tout ceci
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>tant que (condition) est vraie
</span></span></code></pre></td></tr></table></div></div><p>Ne pas oublier le point-virgule à la fin du while. Les accolades peuvent là aussi êtres omisent si il n’y a qu’une seule instruction dans le bloc.</p><a href=#la-boucle-while><h3 id=la-boucle-while><span class=hanchor arialabel=Anchor># </span>La boucle while</h3></a><p>S’utilise de la même façon qu’en C, et a le même effet, à savoir ; exécuter un bloc d’instructions en boucle tant que la condition contenue entre les parenthèses suivants le mot clé <strong>while</strong> est vraie, avec une vérification de celle-ci avant le premier lancement de la boucle (contrairement à do…while).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>while(condition)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Comme d’habitude, les accolades peuvent êtres enlevées si il n’y a qu’une instruction à exécuter.</p><a href=#la-boucle-for><h3 id=la-boucle-for><span class=hanchor arialabel=Anchor># </span>La boucle for</h3></a><p>Celle-ci permet, comme en C, d’intégrer facilement un compteur à une boucle. Voici un pseudo-code pour présenter l’instruction <strong>for</strong> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for( instructions1 ; conditions ; instructions2 )
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    autres instructions;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Son effet est le même qu’en C :</p><ol><li><p>exécuter <em>instructions1</em> ;</p></li><li><p>tant que <em>conditions</em> est vrai, exécuter :</p><ol><li><p><em>autre instructions</em> ;</p></li><li><p><em>instructions2</em>.</p></li></ol></li></ol><a href=#les-structures><h3 id=les-structures><span class=hanchor arialabel=Anchor># </span>Les structures</h3></a><p>Les structures sont également possibles en GLSL. Elles se définissent bien sûr de la même façon, en utilisant le mot clé <strong>struct</strong> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct MaStructure
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    int a, b;
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>Vous pouvez bien sûr créer toutes sortes de variables dans votre structure (des vecteurs, des matrices, etc…). Une structure se crée et s’utilise ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MaStructure str; // declaration
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>str.a = 0; // acces aux variables
</span></span><span class=line><span class=cl>str.b = str.a;
</span></span></code></pre></td></tr></table></div></div><p>Vous noterez qu’il n’est pas nécessaire de préfixer la déclaration des variables de type structure avec le mot clé <code>struct</code>. Eh oui, le mot clé <strong>typedef</strong> n’existe pas en GLSL, plus besoin de vous embêter avec.</p><a href=#le-préprocesseur><h3 id=le-préprocesseur><span class=hanchor arialabel=Anchor># </span>Le préprocesseur</h3></a><p>Il fonctionne comme en langage C : toutes les commandes de préprocesseur doivent être préfixées par « # ». Parmi ces commandes, on retrouvera entre autre le fameux <strong>"#define"</strong>, qui permet de définir des macros, <strong>"#undef"</strong> qui les “dé-défini”, mais aussi les instructions <strong>"#if"</strong>, <strong>"#ifdef"</strong>, <strong>"#ifndef"</strong>, <strong>"#else"</strong>, <strong>"#elif"</strong> et <strong>"#endif"</strong>, qui ont toutes le même effet qu’en C.</p><p>Par exemple, vous pourriez changer l’intégrité de votre shader juste avec une macro, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#ifdef SUPERSHADER
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>// code source du super shader
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>#else
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>// code source d&#39;un shader un peu moins bien
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>#endif
</span></span></code></pre></td></tr></table></div></div><p>Ainsi, si SUPERSHADER est définie, seules les instructions contenues entre <strong>"#ifdef"</strong> et <strong>"#else"</strong> seront compilées, sinon ça sera celles qui sont entre <strong>"#else"</strong> et <strong>"#endif"</strong>.</p><a href=#incompatibilités-et-différences><h2 id=incompatibilités-et-différences><span class=hanchor arialabel=Anchor># </span>Incompatibilités et différences</h2></a><a href=#les-déclarations-de-variables><h3 id=les-déclarations-de-variables><span class=hanchor arialabel=Anchor># </span>Les déclarations de variables</h3></a><p>Contrairement au C89 qui exige que les variables soient définies au début de votre code, le GLSL autorise quant à lui la création de variables n’importe où dans votre shader (autorisé également en C99). Avec cette liberté de création de variables, il est possible de créer une variable dans une instruction for, comme ceci par exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for(int i = 0; i &lt; 5; i++)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#les-pointeurs-et-linstruction-switch><h3 id=les-pointeurs-et-linstruction-switch><span class=hanchor arialabel=Anchor># </span>Les pointeurs et l’instruction switch</h3></a><p>Les pointeurs de même que l’instruction switch n’existent pas en GLSL.</p><hr><a href=#créer-et-surcharger-des-fonctions><h2 id=créer-et-surcharger-des-fonctions><span class=hanchor arialabel=Anchor># </span>Créer et surcharger des fonctions</h2></a><a href=#déclarer-une-simple-fonction><h2 id=déclarer-une-simple-fonction><span class=hanchor arialabel=Anchor># </span>Déclarer une simple fonction</h2></a><p>Tout est quasiment identique au C, mais je préfère tout de même mettre les choses au clair. Comme en C, une fonction possède :</p><ul><li><p>une valeur de retour d’un certain type ;</p></li><li><p>un nom ;</p></li><li><p>des paramètres ;</p></li><li><p>un contenu, entre accolades {}.</p></li></ul><p>La déclaration d’une fonction se fait comme en C, on commence par mettre son type de retour, son nom, puis ses paramètres entre parenthèses. Pour finir, on ouvre une accolade puis on place le contenu de notre fonction à l’intérieur :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void my_func(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    // contenu
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Vous voyez ici l’emploi du type <strong>void</strong>, qui signifie comme en C : vide. Donc notre fonction ne retourne rien et ne prend aucun paramètre. De même qu’en C, la notion de prototype existe. Déclarez vos prototypes tout en haut du code source, ainsi vous n’aurez aucun problème :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float my_func(void);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>float my_func(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Notez que d’une façon générale, si votre fonction n’a pas été déclarée, vous ne pourrez pas l’utiliser. Ainsi, soit vous déclarez son prototype tout en haut de votre code et vous vous épargnez tout problème, soit vous triez vos fonctions de façon sélective afin que les dépendances soient satisfaites.</p><a href=#paramètres-et-valeur-de-retour><h3 id=paramètres-et-valeur-de-retour><span class=hanchor arialabel=Anchor># </span>Paramètres et valeur de retour</h3></a><p>Nous pouvons également écrire une fonction qui prend un ou plusieurs paramètres, et renvoie une variable. Pour renvoyer une variable, vous devez mettre son type avant le nom de la fonction. Vous pouvez renvoyer n’importe quel type de variable en GLSL :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 my_func(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    vec3 result;
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    ... // calculs horriblement complexes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return result; // on renvoie le resultat
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Notez ici le mot clé <strong>return</strong>, il existe également en GLSL et a le même effet qu’en C : renvoyer une valeur de retour en terminant l’exécution de la fonction.</p><p>Pour donner un paramètre à une fonction, il suffit de rajouter son type suivi du nom de la variable qui contiendra la valeur du paramètre, entre les parenthèses qui suivent le nom de la fonction, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 my_func(vec3 v)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    vec3 result;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    result = v * 2; // calculs horriblement complexes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return result; // on renvoie le resultat
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Comme en C, on accède à un paramètre en écrivant son nom. Ici, la super fonction que j’ai écrit relève réellement du génie : elle renvoie un vecteur qui est celui envoyé en paramètre multiplié par 2.</p><a href=#la-surcharge-des-fonctions><h2 id=la-surcharge-des-fonctions><span class=hanchor arialabel=Anchor># </span>La surcharge des fonctions</h2></a><a href=#notion-de-surcharge><h3 id=notion-de-surcharge><span class=hanchor arialabel=Anchor># </span>Notion de surcharge</h3></a><p>Nous avons déjà vu la surcharge des opérateurs dans le précédent chapitre. La notion de surcharge existe également pour les fonctions. Surcharger une fonction signifie, en gros, qu’on va attribuer un seul nom de fonction à plusieurs fonctions.</p><p>Par exemple, supposez que vous vouliez écrire une fonction qui renvoie le
<a href=http://www.siteduzero.com/tuto-3-18391-1-les-vecteurs.html#ss_part_3 rel=noopener>produit scalaire</a> de deux vecteurs. En C, vous auriez écrit une fonction pour chaque type de vecteur : une pour les vecteurs à 2 dimensions et une autre pour les vecteurs en 3 dimensions, et elles auraient chacune un nom différent. Pas très pratique à utiliser.</p><p>Pour remédier à cela, la surcharge permet de ne créer qu’un seul nom de fonction pour deux fonctions différentes. Ainsi, vous pourrez appeler votre fonction de produit scalaire indifféremment avec des vecteurs 2D ou 3D :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec2 a, b;
</span></span><span class=line><span class=cl>vec3 x, y;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>float resultat1 = produitScalaire(a, b);
</span></span><span class=line><span class=cl>float resultat2 = produitScalaire(x, y);
</span></span></code></pre></td></tr></table></div></div><p>Cela évite de créer 36 noms de fonctions juste parce que le nombre et/ou le type de leur(s) paramètre(s) change. Nous pouvons aussi imaginer une fonction qui pourrait travailler aussi bien sur des entiers (<strong>int</strong>) que sur des flottants (<strong>float</strong>), dans ce cas la surcharge serait également utile.</p><a href=#surcharger-une-fonction><h3 id=surcharger-une-fonction><span class=hanchor arialabel=Anchor># </span>Surcharger une fonction</h3></a><p>Nous allons prendre l’exemple du produit scalaire, qui est un très bon exemple. Voici une fonction qui calcule le produit scalaire de deux vecteurs 3D :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float produitScalaire(vec3 a, vec3 b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    float resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on calcul le produit scalaire (3D)
</span></span><span class=line><span class=cl>    resultat = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on retourne le resultat
</span></span><span class=line><span class=cl>    return resultat;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Notez que les parenthèses dans le calcul du produit scalaire sont facultatives dans la mesure où * a la priorité sur +, elles ne sont présentes que pour une meilleure lisibilité.</p><p>Maintenant, nous voudrions que cette fonction marche aussi pour les vecteurs à 2 dimensions. En fait, il n’y a pas de secret : il faut re-écrire la fonction en entier. Ce qu’accepte le GLSL, contrairement au C, c’est d’avoir plusieurs fonctions du même nom, qui ne se différencient que par leurs paramètres et/ou leur type respectif.</p><p>Ainsi, pour surcharger notre fonction produitScalaire(), il nous suffit de rajouter une version de notre fonction qui calculera le produit scalaire de deux vecteurs 2D, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float produitScalaire(vec2 a, vec2 b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    float resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on calcul le produit scalaire (2D)
</span></span><span class=line><span class=cl>    resultat = (a.x * b.x) + (a.y * b.y);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on retourne le resultat
</span></span><span class=line><span class=cl>    return resultat;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>On n’oubliera pas de rajouter un prototype en haut de notre code pour chaque version de notre fonction.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float produitScalaire(vec3, vec3);
</span></span><span class=line><span class=cl>float produitScalaire(vec2, vec2);
</span></span></code></pre></td></tr></table></div></div><a href=#exemple-complet><h3 id=exemple-complet><span class=hanchor arialabel=Anchor># </span>Exemple complet</h3></a><p>Je vous propose un petit vertex shader tout simple pour illustrer tout ce que nous venons de voir, afin que vous sachiez comment emballer tout ça dans un joli code tout propre tout fini :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// prototypes de nos fonctions
</span></span><span class=line><span class=cl>float produitScalaire(vec4, vec4);
</span></span><span class=line><span class=cl>float produitScalaire(vec3, vec3);
</span></span><span class=line><span class=cl>float produitScalaire(vec2, vec2);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    // il est aussi possible d&#39;acceder aux composantes d&#39;un vecteur en utilisant
</span></span><span class=line><span class=cl>    // les noms r, g ou b, pour red, green et blue respectivement
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    // calculs au hasard, pour donner un effet rigolo
</span></span><span class=line><span class=cl>    gl_FrontColor.b = produitScalaire(gl_Color, gl_Vertex);
</span></span><span class=line><span class=cl>    gl_FrontColor.g = produitScalaire(gl_Color, gl_Vertex * 2.0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    gl_Position = gl_Vertex;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// version 4D
</span></span><span class=line><span class=cl>float produitScalaire(vec4 a, vec4 b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    float resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on calcul le produit scalaire (3D)
</span></span><span class=line><span class=cl>    resultat = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on retourne le resultat
</span></span><span class=line><span class=cl>    return resultat;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// version 3D
</span></span><span class=line><span class=cl>float produitScalaire(vec3 a, vec3 b)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    float resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on calcul le produit scalaire (3D)
</span></span><span class=line><span class=cl>    resultat = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on retourne le resultat
</span></span><span class=line><span class=cl>    return resultat;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// version 2D
</span></span><span class=line><span class=cl>float produitScalaire(vec2 a, vec2 b)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    float resultat;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on calcul le produit scalaire (2D)
</span></span><span class=line><span class=cl>    resultat = (a.x * b.x) + (a.y * b.y);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // on retourne le resultat
</span></span><span class=line><span class=cl>    return resultat;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Je vous avoue cependant que ce vertex shader ne fait rien de génial, il ne sert qu’à vous montrer l’implémentation complète d’une fonction en GLSL.</p><hr><a href=#quelques-fonctions-natives-du-glsl><h1 id=quelques-fonctions-natives-du-glsl><span class=hanchor arialabel=Anchor># </span>Quelques fonctions natives du GLSL</h1></a><p>Le langage GLSL offre par défaut de nombreuses fonctions. Parmi ces fonctions, on retrouve beaucoup de fonctions mathématiques qui permettent de calculer à peu près tout et n’importe quoi, mais on retrouve aussi des fonctions indispensables effectuant des tâches bien précises propres aux shaders.</p><p>Tout d’abord, vous devez savoir que la plupart des fonctions du GLSL sont surchargées, ce qui facilite leur utilisation, qui devient alors intuitive et un vrai jeu d’enfant. Pour faire simple, je vous préviens d’avance : toutes les fonctions que je vais vous présenter sont surchargées, donc utilisez-les à volonté et dans toutes les circonstances. De plus, l’usage des fonctions prédéfinies du GLSL est <strong>fortement recommandé</strong> dans la mesure où la plupart de celles-ci sont directement implantées dans les cartes graphique, ce qui vous permet de tirer parti de toute la puissance de vos cartes et ainsi gagner en performance.</p><a href=#fonctions-de-manipulation-de-vecteurs><h2 id=fonctions-de-manipulation-de-vecteurs><span class=hanchor arialabel=Anchor># </span>Fonctions de manipulation de vecteurs</h2></a><p>Pour comprendre la plupart des fonctions que nous allons étudier ici, je vous recommande la lecture du
<a href=http://www.siteduzero.com/tuto-3-18391-1-les-vecteurs.html rel=noopener>chapitre annexe sur les vecteurs</a>.</p><a href=#normalisation-de-vecteurs><h3 id=normalisation-de-vecteurs><span class=hanchor arialabel=Anchor># </span>Normalisation de vecteurs</h3></a><p>Le langage GLSL offre une fonction permettant de normaliser un vecteur. Cette fonction s’appelle <em>normalize()</em>. Elle prend un paramètre (un vecteur) et renvoie ce même vecteur, mais normalisé. Voici un code pour illustrer la normalisation d’un vecteur <em>v</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v = vec3(0.2, 0.4, 0.6);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>v = normalize(v);
</span></span></code></pre></td></tr></table></div></div><a href=#produit-scalaire><h3 id=produit-scalaire><span class=hanchor arialabel=Anchor># </span>Produit scalaire</h3></a><p>Pour calculer le produit scalaire de deux vecteurs en GLSL, rien de plus simple : appelez la fonction <em>dot()</em>. Cette fonction prend deux paramètres. Ces paramètres sont les deux vecteurs dont on veut connaître le produit scalaire. <em>dot()</em> renvoie un flottant qui n’est autre que le résultat du produit :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v1 = ..., v2 = ...;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>float res = dot(v1, v2);
</span></span></code></pre></td></tr></table></div></div><a href=#produit-vectoriel><h3 id=produit-vectoriel><span class=hanchor arialabel=Anchor># </span>Produit vectoriel</h3></a><p>Là encore, une fonction existe, il s’agit de <em>cross()</em>. Elle prend deux vecteurs en paramètres, et renvoie un vecteur qui est le résultat du produit vectoriel de ses deux paramètres :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v1 = ..., v2 = ...;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>vec3 res = cross(v1, v2);
</span></span></code></pre></td></tr></table></div></div><a href=#longueur-dun-vecteur><h3 id=longueur-dun-vecteur><span class=hanchor arialabel=Anchor># </span>Longueur d’un vecteur</h3></a><p>Pour connaître la longueur d’un vecteur simplement, utilisez la fonction <em>length()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float longueur = length( vec3(2.0, 0.8, 1.6) );
</span></span></code></pre></td></tr></table></div></div><a href=#distance-entre-deux-vecteurs><h3 id=distance-entre-deux-vecteurs><span class=hanchor arialabel=Anchor># </span>Distance entre deux vecteurs</h3></a><p>Bien que cette solution soit envisageable :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 a, b;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>float d = length( a - b );
</span></span></code></pre></td></tr></table></div></div><p>Il en existe une plus explicite : utiliser la fonction <em>distance()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 a, b;
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>float d = distance( a, b );
</span></span></code></pre></td></tr></table></div></div><p>Et voilà, ça sera tout pour les fonctions de manipulation de vecteurs :)</p><p>En ce qui concerne les additions/soustractions de vecteurs, rappelez-vous le précédent chapitre : les opérateurs en GLSL sont surchargés, par conséquent, vous n’aurez qu’à placer l’opérateur de votre choix entre deux vecteurs, ou entre un vecteur et une valeur.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vec3 v1 = ..., v2 = ...;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vec3 add = v1 + v2;  // add = le resultat de l&#39;addition des vecteurs v1 et v2
</span></span><span class=line><span class=cl>vec3 mul = v1 * 2.0; // chaque composante de mul = chaque composante de v1 * 2
</span></span></code></pre></td></tr></table></div></div><a href=#la-fonction-ftransform><h2 id=la-fonction-ftransform><span class=hanchor arialabel=Anchor># </span>La fonction <em>ftransform()</em></h2></a><p>Voici une fonction qui est souvent utilisée par les programmeurs pour… se faciliter la vie. Notez bien qu’elle n’est utilisable qu’au sein d’un vertex shader. Souvenez-vous lorsque vous avez créé votre premier vertex shader lors du précédent chapitre. Vous aviez attribué à la variable de sortie <em>gl_Position</em> le résultat de la multiplication de la position du sommet par les matrices modelview et projection combinées. Voici quel était le code final du vertex shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Ce code est plutôt lourd et long à coder. Il est cependant remplaçable par celui-ci, qui a l’avantage d’être beaucoup plus léger :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    gl_Position = ftransform();
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Vous me demanderez sans doute quel est l’intérêt de la première méthode, ce à quoi je vous répondrai : quel est l’intérêt de la seconde vous voulez dire ? En fait la fonction <em>ftransform()</em> a pour effet de vous rendre la position finale du sommet comme si il avait été traité par le FFP.</p><a href=#encore-quelques-fonctions><h2 id=encore-quelques-fonctions><span class=hanchor arialabel=Anchor># </span>Encore quelques fonctions</h2></a><p>Je vous montre encore quelques fonctions, et après c’est bon, je vous aurai montré le principal (fonctions les plus utilisées).</p><p>Nous allons voir trois fonctions très simples, mais très pratiques :</p><ul><li><p><em>min()</em> ;</p></li><li><p><em>max()</em> ;</p></li><li><p><em>clamp()</em>.</p></li></ul><a href=#min><h3 id=min><span class=hanchor arialabel=Anchor># </span>min()</h3></a><p>Cette fonction renvoie la plus petite valeur entre deux valeurs fournises :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float a = 0.2, b = 0.5;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>float res = min(a, b);
</span></span></code></pre></td></tr></table></div></div><p>Ici, <em>res</em> = <strong>0.2</strong></p><p>Notez que cette fonction peut être remplacée par l’instruction suivante (comme en C) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(a &lt; b) ? a : b;
</span></span></code></pre></td></tr></table></div></div><p>Tout comme de nombreuses fonctions, <em>min()</em> est surchargée, vous pouvez donc lui envoyer des vecteurs, elle vous renverra le plus court.</p><a href=#max><h3 id=max><span class=hanchor arialabel=Anchor># </span>max()</h3></a><p>Exactement l’inverse de <em>min()</em>, <em>max()</em> vous renvoie son plus grand paramètre :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int res = max(2, 4); // res = 4
</span></span></code></pre></td></tr></table></div></div><p>Elle est bien évidemment elle aussi surchargée.</p><a href=#clamp><h3 id=clamp><span class=hanchor arialabel=Anchor># </span>clamp()</h3></a><p>La fonction <em>clamp()</em> est un mélange des deux fonctions vues ci-dessus, elle prend trois paramètres :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T clamp(T var, T minimum, T maximum);
</span></span></code></pre></td></tr></table></div></div><p>L’emploi de ‘T’ représente juste un type quelconque.</p><p>et renvoie ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>min(max(var, minimum), maximum);
</span></span></code></pre></td></tr></table></div></div><p>Euh, j’ai rien compris, c’est normal ?</p><p>Oui, rassurez-vous :D</p><p>En fait, la fonction <em>clamp()</em> vous renvoie une valeur qui se situe forcément entre <em>minimum</em> et <em>maximum</em>. <em>clamp()</em> renvoie <em>var</em> si sa valeur est située entre <em>minimum</em> et <em>maximum</em>, sinon elle renvoie la valeur la plus proche de <em>var</em> (<em>minimum</em> ou <em>maximum</em>).</p><p>Nous pouvons programmer <em>clamp()</em> comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if(minimum &gt; var)
</span></span><span class=line><span class=cl>    return minimum;
</span></span><span class=line><span class=cl>else if(up &lt; var)
</span></span><span class=line><span class=cl>    return maximum;
</span></span><span class=line><span class=cl>else
</span></span><span class=line><span class=cl>    return var;
</span></span></code></pre></td></tr></table></div></div><a href=#spécifications-du-glsl><h2 id=spécifications-du-glsl><span class=hanchor arialabel=Anchor># </span>Spécifications du GLSL</h2></a><p>La version du langage étudié dans ce tutoriel possède
<a href=http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf rel=noopener>des spécifications</a> que vous trouverez sur le site d’OpenGL. Ceci est la documentation de référence et votre meilleur guide dans l’avenir pour l’apprentissage du GLSL.</p><p>Je reconnais que ce chapitre avait un aspect “bourrage de crâne”, mais il vous sera sûrement plus utile que vous ne le pensez. En effet, mine de rien nous avons appris beaucoup de choses très pratiques :</p><ul><li><p>les instructions de contrôle, et les incompatibilités avec le C ;</p></li><li><p>les fonctions et la surcharge des fonctions ;</p></li><li><p>quelques fonctions du GLSL, que nous utiliserons fréquemment.</p></li></ul><p>Maintenant que vous connaissez le langage GLSL, vous devriez être aptes à comprendre un code source quelconque, sauf bien sûr si celui-ci comporte des fonctions du GLSL qui vous sont inconnues.</p><hr><a href=#communiquer-avec-lapplication--attributs-et--uniforms-><h1 id=communiquer-avec-lapplication--attributs-et--uniforms-><span class=hanchor arialabel=Anchor># </span>Communiquer avec l’application : attributs et « uniforms »</h1></a><p>Bienvenue dans la seconde partie de ce tutoriel consacré aux shaders en GLSL ! :)</p><p>Nous allons la commencer sans plus tarder en abordant deux façons de <strong>transmettre</strong> des informations au shader, à partir de l’application. Ces deux façons sont relativement simples à mettre en œuvre, et puisqu’elles font intervenir toutes les deux des exemples en langage C (langage utilisé pour notre application), j’ai décidé de les fusionner dans un seul chapitre.</p><ul><li><p>Nous allons tout d’abord étudier les variables de type <strong>uniform</strong>. Ce type de variable du GLSL vous permettra de recevoir des variables provenant de l’application. Vous pourrez ainsi changer dynamiquement la valeur d’une variable au sein du shader, lorsque votre application sera en cours.</p></li><li><p>Nous apprendrons ensuite à utiliser les <strong>attributs</strong> de sommet. Ce sont en fait des informations qui sont différentes pour chaque sommet, un peu comme la couleur ou la position ;) Cela nous permettra de rajouter des données à nos sommets.</p></li></ul><a href=#les-variables-de-type-uniform><h2 id=les-variables-de-type-uniform><span class=hanchor arialabel=Anchor># </span>Les variables de type uniform</h2></a><a href=#principe><h2 id=principe><span class=hanchor arialabel=Anchor># </span>Principe</h2></a><p>L’idée est simple : envoyer une variable de l’application au shader. En réalité ce n’est pas un véritable envoi, mais plutôt une copie de valeur. Nous allons pour cela créer une variable dans notre shader, en lui assignant un type particulier, puis, à partir de notre application, localiser cette variable dans notre shader pour y demander la copie d’une valeur.</p><p>Vous pouvez bien sûr transmettre différents types de variables, comme des entiers, des flottants, des booléens, des vecteurs et même des matrices.</p><a href=#le-type--uniform-><h1 id=le-type--uniform-><span class=hanchor arialabel=Anchor># </span>Le type « uniform »</h1></a><p>Dans un shader, pour créer des variables capables de recevoir leur valeur à partir de l’application appelante, il faut les rendre <strong>globales</strong> et leur assigner le préfixe <strong>uniform</strong>.</p><p>Rendre une variable globale ? o_O</p><p>Cela veut dire, comme en C, rendre une variable accessible par tout le programme. Créer une variable globale en GLSL revient à faire ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int variable; // &#39;variable&#39; est globale
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void main(void)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>Et le type « uniform » dans tout ça ?</p><p>Il vient se placer devant le type de la variable, comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniform int variable;
</span></span></code></pre></td></tr></table></div></div><p>Déclarer une variable avec <strong>uniform</strong> revient à dire : “je veux que la valeur de cette variable soit indiquée par mon application”. Et voilà, c’est tout ce qu’on aura à faire dans notre shader pour indiquer à OpenGL les variables dont la valeur proviendra de l’application :)</p><a href=#implémentation-côté-api><h2 id=implémentation-côté-api><span class=hanchor arialabel=Anchor># </span>Implémentation côté API</h2></a><a href=#une-affaire-didentifiants><h3 id=une-affaire-didentifiants><span class=hanchor arialabel=Anchor># </span>Une affaire d’identifiants</h3></a><p>Dites donc, on dirait qu’ils aiment bien les identifiants chez OpenGL :D Avant de pouvoir transmettre une valeur à une variable de notre shader, il est important de préciser à OpenGL quelle variable recevra la valeur.</p><p>Ben, c’est celle qu’on a créée avant avec uniform non ?</p><p>Eh bien non, pas forcément, car il est possible de créer plusieurs variables uniform dans un même shader. Si par exemple vous en créez deux, comment OpenGL saura à quelle variable il doit transmettre la valeur ? Il est donc important de récupérer l’ID de notre variable avant de lui envoyer une valeur.</p><a href=#récupérer-un-id><h3 id=récupérer-un-id><span class=hanchor arialabel=Anchor># </span>Récupérer un ID</h3></a><p>Il n’existe pas 36 façons de localiser une variable dans un shader (et n’importe où d’ailleurs…), il va falloir donner à OpenGL le nom de notre variable, pour qu’il nous retourne son identifiant, nous nous servirons ensuite de celui-ci pour envoyer une valeur à notre variable.</p><p>Voici la fonction OpenGL permettant de récupérer l’ID d’une variable dans un shader :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint glGetUniformLocation(GLuint program, const char *nom);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>program</strong></em> : c’est l’identifiant du program tout entier dans lequel on voudra rechercher la variable.</p></li><li><p><em><strong>nom</strong></em> : le nom de la variable dont on veut récupérer l’identifiant.</p></li></ul><p>Attention : si vous créez une variable uniform qui a le même nom dans le vertex et le pixel shader, les deux variables seront affectées par la valeur que vous spécifierez.</p><p>La valeur retournée par cette fonction est l’identifiant de votre variable de shader nommée <em>“nom”</em>, si la fonction n’a pas trouvé votre variable, ou qu’elle a échoué pour une raison x ou y, elle renvoie -1.</p><p>Dans quelle mesure cette fonction peut “échouer” ?</p><p>Si votre program n’a pas été lié par exemple, rappelez-vous dans le second chapitre de la fonction <em>glLinkProgram()</em>.</p><a href=#assigner-une-valeur><h3 id=assigner-une-valeur><span class=hanchor arialabel=Anchor># </span>Assigner une valeur</h3></a><p>Nous voici enfin parvenus à l’étape finale : l’envoi d’une valeur à la variable de notre shader :)</p><p>Pour cela, nous avons besoin de 3 choses :</p><ol><li><p>l’identifiant de notre variable, récupéré avec <em>glGetUniformLocation()</em> ;</p></li><li><p>une valeur à attribuer à cette variable ;</p></li><li><p>et surtout, que notre program ait été défini comme actif pour le rendu, c’est-à-dire activé via <em>glUseProgram()</em> !</p></li></ol><p>La dernière condition est très importante, si votre program n’a pas été activé, une erreur OpenGL de type GL_INVALID_OPERATION sera levée.</p><p>Les erreurs OpenGL sont récupérables via la fonction <em>glGetError()</em>, et peuvent être transformées en chaînes de caractères avec <em>gluErrorString()</em> comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const char *err = gluErrorString(glGetError());
</span></span></code></pre></td></tr></table></div></div><p>Allez, il est temps que je vous présente la fonction permettant d’envoyer une valeur à une variable de notre shader :) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUniform*(GLint id, TYPE val);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>id</strong></em> : c’est l’ID de notre variable, récupéré via <em>glGetUniformLocation()</em>.</p></li><li><p><em><strong>val</strong></em> : la valeur que l’on souhaite envoyer à notre variable.</p></li></ul><p>Cette fonction agit directement sur le program actif, d’où la nécessité de l’avoir activé au préalable avec <em>glUseProgram()</em>.</p><p>Lorsque <em>glUniform</em>()* est appelée, la variable désignée par l’identifiant prend alors la valeur demandée, et garde cette valeur jusqu’à ce que le program soit à nouveau lié ou supprimé. Par conséquent, si vous souhaitez envoyer une valeur constante (un paramètre de démarrage par exemple), n’invoquez <em>glUniform</em>()*qu’une seule fois.</p><a href=#les-différentes-formes-de-gluniform><h2 id=les-différentes-formes-de-gluniform><span class=hanchor arialabel=Anchor># </span>Les différentes formes de <em>glUniform</em>()*</h2></a><p>Comme vous l’aurez remarqué, j’ai mis une petite étoile « * » au nom de la fonction, c’est pour dire qu’elle a été définie sous plusieurs formes, comme pour les fonctions <em>glVertex</em>()<em>, <em>glTexCoord</em>()</em>, etc… Cela permet d’envoyer différents types de variables, comme je l’ai dit plus haut ; des vecteurs, des matrices, etc…</p><a href=#envoi-dune-simple-variable><h3 id=envoi-dune-simple-variable><span class=hanchor arialabel=Anchor># </span>Envoi d’une simple variable</h3></a><p>La fonction <em>glUniform</em>()* a été définie sous de nombreuses formes. Toutefois, le nombre de types de variable qu’elle supporte est toujours limité à deux :</p><ul><li><p>les entiers (<strong>int</strong>) ;</p></li><li><p>les flottants (<strong>float</strong>).</p></li></ul><p>Du côté du GLSL, nous remarquons la présence d’un type supplémentaire : le type <strong>bool</strong>. Rassurez-vous cependant, vous pourrez affecter une variable <strong>bool</strong> en passant par la forme entière de <em>glUniform</em>()*.</p><p>Voici un premier exemple de code illustrant le simple envoi d’une variable à notre program nommé <em>prog</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniform int var; // n&#39;oublions pas de declarer &#39;var&#39; globale
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(prog, &#34;var&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(prog);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre variable (ici nous envoyons la valeur 2) */
</span></span><span class=line><span class=cl>glUniform1i(id, 2);
</span></span></code></pre></td></tr></table></div></div><p>Notez qu’il n’est pas obligatoire de récupérer l’identifiant à chaque fois que vous voudrez envoyer une valeur à une variable de votre shader, l’ID est invariable, sauf si vous liez à nouveau votre program. Donc, dans la mesure où la recherche d’un identifiant est plutôt lourde (analyse d’une chaîne de caractères), on essayera si possible de stocker au préalable tous les identifiants dans des variables.</p><a href=#envoi-dun-simple-vecteur><h3 id=envoi-dun-simple-vecteur><span class=hanchor arialabel=Anchor># </span>Envoi d’un simple vecteur</h3></a><p>Si vous voulez envoyer un vecteur à 3 dimensions (par exemple) à votre shader, vous pouvez faire comme ceci :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniform vec3 vecteur;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;vecteur&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre vecteur */
</span></span><span class=line><span class=cl>glUniform3f(id, 1.7, 5.2, 3.6);
</span></span></code></pre></td></tr></table></div></div><p>Cette méthode peut poser un petit problème ; elle est plutôt “lourde” et peut flexible, il faut spécifier chaque composante du vecteur une par une, et si l’on souhaite subitement envoyer un vecteur à deux dimensions à la place, il faudra non seulement changer le nom de la fonction, mais aussi le nombre de ses paramètres. Pour remédier à ce problème, vous pouvez utiliser la version vectorielle de <em>glUniform</em>()*.</p><a href=#étude-de-la-version-vectorielle-de-gluniform><h3 id=étude-de-la-version-vectorielle-de-gluniform><span class=hanchor arialabel=Anchor># </span>Étude de la version vectorielle de glUniform*()</h3></a><p>Afin d’envoyer un groupe de données (comme un vecteur), la fonction <em>glUniform</em>v()* vous propose de lui spécifier un pointeur vers ces données. De plus, elle bénéficie d’un nouveau paramètre :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUniform*v(GLint id, GLsizei count, TYPE *val);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>id</strong></em> : …</p></li><li><p><em><strong>count</strong></em> : nombre de groupes de données.</p></li><li><p><em><strong>val</strong></em> : …</p></li></ul><p>Voyons tout d’abord comment modifier le code précédent pour spécifier la valeur de notre vecteur par le biais d’un tableau :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniform vec3 vecteur;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* le vecteur que l&#39;on veut envoyer en parametre */
</span></span><span class=line><span class=cl>float vec[3] = {1.7, 5.2, 3.6};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;vecteur&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre vecteur */
</span></span><span class=line><span class=cl>glUniform3fv(id, 1, vec);
</span></span></code></pre></td></tr></table></div></div><p>Vous pouvez voir ici que j’ai spécifié le paramètre <em>count</em> de <em>glUniform</em>v()* à la valeur 1. Cela veut dire que j’ai souhaité envoyer <strong>un</strong> vecteur, un vecteur à <strong>3</strong> composantes ( <em>glUniform<strong>3</strong>fv()</em> ). En effet, le chiffre contenu dans le nom de la fonction <em>glUniform</em>()* (qui peut varier de 1 à 4 inclus) nous informe du type de la variable GLSL (nombre de composantes du vecteur), et par conséquent du nombre de données que la fonction <em>glUniform</em>()* va aller chercher dans notre pointeur.</p><p>Donc : faites bien attention aux débordements mémoire. Mais attendez, vous n’avez pas encore tout vu. Eh bien oui ; qu’advient-il de notre paramètre <em>count</em> ? Il ne faut pas l’oublier.</p><p>Le paramètre <em>count</em> vient complexifier la chose en vous permettant d’envoyer des tableaux de vecteurs. Avec ce paramètre, vous allez pouvoir spécifier le nombre de vecteurs que contient votre tableau. Prenons tout de suite un exemple :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniform vec3 vecteurs[2]; // tableau de deux vecteurs
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* les vecteurs que l&#39;on veut envoyer en parametre */
</span></span><span class=line><span class=cl>float vecs[2][3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    {0.8, 2.1, 1.3},
</span></span><span class=line><span class=cl>    {1.9, 3.2, 1.7}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;vecteurs&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie nos deux vecteurs */
</span></span><span class=line><span class=cl>glUniform3fv(id, 2, vecs);
</span></span></code></pre></td></tr></table></div></div><p>Comme vous le voyez, côté GLSL vous pouvez remarquer que j’ai créé un tableau de vecteurs, tout comme je l’ai fait dans l’exemple en C. J’ai également placé le paramètre <em>count</em> à la valeur <strong>2</strong> dans <em>glUniform</em>v()*, pour indiquer que je souhaite envoyer <strong>deux</strong> vecteurs.</p><p>**Prenez garde :***glUniform<em>v()</em> attend une suite de données, donc un tableau ou un tableau de tableaux, mais en aucun cas un pointeur de pointeurs ! La solution suivante est envisageable et produira le même effet :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>float vec[2*3] = {0.8, 2.1, 1.3, 1.9, 3.2, 1.7};
</span></span></code></pre></td></tr></table></div></div><p>Au final, le nombre de variables qui seront lues dans votre tableau sera égal au chiffre du nom de la fonction <em>glUniform</em>v()* multiplié par <em>count</em> (dans notre cas, 2*3).</p><p>Et si je veux envoyer un simple tableau, je fais comment ?</p><p>Invoquez <em>glUniform1</em>v()<em>, elle ira prendre exactement <em>count</em> données dans votre tableau et ira les loger dans votre shader dans un tableau de type <strong>bool</strong>, <strong>int</strong> ou <strong>float</strong>. Eh oui, un vecteur à <strong>une</strong> composante ( <em>glUniform<strong>1</strong></em>v()</em> ) n’est rien d’autre qu’une simple variable ;)</p><a href=#et-les-matrices--1><h3 id=et-les-matrices--1><span class=hanchor arialabel=Anchor># </span>Et les matrices ?</h3></a><p>À partir du moment où vous avez compris le fonctionnement de la version vectorielle de glUniform*(), les matrices vous paraîtront tout aussi simple ; en fait, le principe est identique, sauf qu’une matrice a plus de composantes qu’un vecteur ;)</p><p>Afin d’envoyer une matrice à votre shader, chose qui risque d’arriver assez rarement dans la mesure où les matrices de projection, de texturage et de visualisation sont déjà à votre disposition en GLSL, la fonction <em>glUniform</em>()* prend une autre… forme :p :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glUniformMatrix*fv(GLint id, GLsizei count, GLboolean transpose, const float *val);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>id</strong></em> : …</p></li><li><p><em><strong>count</strong></em> : …</p></li><li><p><em><strong>val</strong></em> : les valeurs doivent être contenues dans un pointeur sur des flottants de type <strong>float</strong> ;</p></li><li><p><em><strong>transpose</strong></em> : positionné à GL_TRUE, les matrices envoyées seront transposées avant d’arriver dans le shader.</p></li></ul><p>Comme vous le voyez, cette version laisse moins de libertés au programmeur, le forçant à utiliser des matrices codées sur des flottants de type <strong>float</strong>. Toutefois, elle lui permet :</p><ul><li><p>de spécifier l’ordre de sa matrice, via le paramètre <em>transpose</em> ;</p></li><li><p>d’indiquer la taille de sa matrice, via le nom de la fonction ( <em>glUniformMatrix<strong>2</strong>fv()</em> pour une matrice <strong>2*2</strong>, <em>glUniformMatrix<strong>3</strong>fv()</em> pour une matrice <strong>3*3</strong>, etc… ).</p></li></ul><p>Pour plus d’informations sur la transposée d’une matrice, vous pouvez consulter
<a href="http://jeux.developpez.com/faq/matquat/?page=arithmetique#Q8" rel=noopener>la FAQ de Developpez.com sur les matrices</a>.</p><p>Voici un bref exemple pour illustrer une utilisation possible :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>uniform mat3 matrix;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* la matrice que l&#39;on veut envoyer en parametre */
</span></span><span class=line><span class=cl>float mat[3][3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    {1.2, 0.0, 0.0},
</span></span><span class=line><span class=cl>    {0.0, 2.5, 0.0},
</span></span><span class=line><span class=cl>    {0.0, 0.0, 1.0}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;ID */
</span></span><span class=line><span class=cl>int id = glGetUniformLocation(program, &#34;matrix&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on defini notre program actif */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on envoie notre matrice */
</span></span><span class=line><span class=cl>glUniformMatrix3fv(id, 1, 0, mat);
</span></span></code></pre></td></tr></table></div></div><p>Et voilà, vous savez tout sur les variables uniform des shaders :) Servez-vous en pour envoyer des informations supplémentaires, de couleur par exemple, ou bien des données envoyées par l’utilisateur ; eh oui, aucun dialogue direct n’est possible entre l’utilisateur et le shader, servez-vous donc de votre application comme un tiers.</p><p>Un exemple complet est disponible en téléchargement à la fin de ce chapitre.</p><hr><a href=#les-attributs-de-sommet><h2 id=les-attributs-de-sommet><span class=hanchor arialabel=Anchor># </span>Les attributs de sommet</h2></a><a href=#quest-ce-quun-attribut-><h2 id=quest-ce-quun-attribut-><span class=hanchor arialabel=Anchor># </span>Qu’est-ce qu’un attribut ?</h2></a><p>Comme indiqué à l’introduction de ce chapitre, les <strong>attributs de sommet</strong> sont des données supplémentaires, différentes pour chaque sommet, à l’instar de la position, de la coordonnée de texture, etc…</p><p>Ainsi, les attributs de sommet ne sont accessibles que par les vertex shaders, là où les informations de sommets sont disponibles en lecture (et en lecture seulement).</p><p>Comment accéder aux attributs de sommet dans le vertex shader ?</p><p>Les données de position du sommet par exemple, sont disponible par défaut dans une variable du GLSL : <em>gl_Vertex</em>. Pour les attributs de sommet, il va falloir créer cette variable, mais pas n’importe comment.</p><a href=#le-type--attribute-><h1 id=le-type--attribute-><span class=hanchor arialabel=Anchor># </span>Le type « attribute »</h1></a><p>À l’instar des variables uniform, que nous avons vue à l’instant, il va à nouveau falloir attribuer un type différents à nos attributs de sommet. Tout comme les uniform, les attributs doivent être des variables globales, mais préfixées cette fois-ci avec le mot clé <strong>attribute</strong> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>attribute vec3 donnee_supplementaire;
</span></span></code></pre></td></tr></table></div></div><p>Ici, j’ai décidé de rajouter une variable de type <strong>vec3</strong>. En gros, ce bout de code peut se traduire : « <em>je rajoute une donnée à mes sommets qui seront dessinés avec ce vertex shader</em> ».</p><p>Supposons que nous voulions dessiner un triangle, nous allons donc spécifier trois sommets :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_780_d57889049e1e4cd6b.gif width=auto alt="Image utilisateur"></p><p>Chaque sommet possède son lot de données en tout genre : position, normale, couleur, etc… Eh bien imaginez que vous vouliez en rajouter ; vous pouvez !</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_780_449f98fe8e5040ef9.gif width=auto alt="Image utilisateur"></p><p>C’est ce qui se passe lorsque vous créez une variable avec le type <strong>attribute</strong> :)</p><a href=#côté-api><h2 id=côté-api><span class=hanchor arialabel=Anchor># </span>Côté API</h2></a><p>Bien, voyons maintenant comment spécifier la valeur de ces données en plus que sont les attributs de sommet.</p><p>Globalement, le principe est le même que pour les variables uniform :</p><ul><li><p>on récupère l’ID (plus couramment appelé <strong>index</strong> dans le cas des attributs de sommet) de notre attribut ;</p></li><li><p>on s’en sert pour localiser nos attributs et ainsi leur envoyer la valeur de notre choix.</p></li></ul><a href=#récupérer-lindex><h3 id=récupérer-lindex><span class=hanchor arialabel=Anchor># </span>Récupérer l’index</h3></a><p>Bon, comme vous avez déjà pris l’habitude avec les uniforms, je vais aller un peu plus vite dans la pratique. Pour récupérer l’index d’un attribut de sommet dans un shader GLSL, invoquez <em>glGetAttribLocation()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GLint glGetAttribLocation(GLuint program, const char *name);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>program</strong></em> : désigne le program dans lequel nous voulons rechercher l’index.</p></li><li><p><em><strong>name</strong></em> : c’est le nom de l’attribut dont on souhaite obtenir l’index.</p></li></ul><p>Une fois que nous avons notre index, il nous suffira de le spécifier à la fonction qui permet de définir les valeurs des attributs de sommet, et ces valeurs étant différentes pour chaque sommet, il nous faudra appeler cette fonction pour chaque sommet que nous définirons.</p><a href=#spécifier-la-valeur-dun-attribut><h3 id=spécifier-la-valeur-dun-attribut><span class=hanchor arialabel=Anchor># </span>Spécifier la valeur d’un attribut</h3></a><p>Prenons un exemple ; supposons un triangle, créé de la façon suivante avec OpenGL :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span></code></pre></td></tr></table></div></div><p>Avec ce code, nous demandons la création de trois sommets (pour former un triangle). Pour chaque sommet traité, le vertex shader actif sera invoqué et sa variable <em>gl_Vertex</em> sera affectée aux valeurs que nous avons spécifiées à la fonction <em>glVertex</em>()<em>. Il en va de même pour chaque variable d’entrée du vertex shader (couleur, normale, …), y compris son attribut. Ainsi, pour affecter un attribut d’un sommet, il suffit de spécifier sa valeur pour chaque création de sommet avec la fonction <em>glVertexAttrib</em>()</em>, en spécifiant bien quel attribut nous souhaitons affecter via son index :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glVertexAttrib3f(index, 0.0, 0.0, 0.0); glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib3f(index, 0.0, 0.0, 0.0); glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib3f(index, 0.0, 0.0, 0.0); glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span></code></pre></td></tr></table></div></div><p>Et voici son prototype :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glVertexAttrib*(GLuint index, TYPE vals);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>index</strong></em> : il s’agit là de placer l’index que l’on a récupéré avec <em>glGetAttribLocation()</em>.</p></li><li><p><em><strong>vals</strong></em> : ce sont les valeurs auquels on souhaite positionner notre attribut, le nombre de valeurs peut varier de 1 à 4 inclus.</p></li></ul><p>La fonction <em>glVertexAttrib</em>()* permet de spécifier la valeur de l’attribut de chaque sommet, comme vous venez de le voir. Voici un exemple d’utilisation des attributs de sommet :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>attribute float numero_sommet; // representera le numero du sommet
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* on recupere l&#39;index de notre attribut de sommets */
</span></span><span class=line><span class=cl>int index = glGetAttribLocation(program, &#34;numero_sommet&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on active notre program */
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glBegin(GL_TRIANGLES);
</span></span><span class=line><span class=cl>    glVertexAttrib1f(index, 0.0); glVertex2f(0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib1f(index, 1.0); glVertex2f(-0.9, -0.9);
</span></span><span class=line><span class=cl>    glVertexAttrib1f(index, 2.0); glVertex2f(0.0, 0.9);
</span></span><span class=line><span class=cl>glEnd();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on desactive les shaders */
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span></code></pre></td></tr></table></div></div><p>Vous noterez que la forme de <em>glVertexAttrib</em>()* utilisée doit correspondre au type de l’attribut dans le shader, sinon vous risquez de vous retrouver avec une valeur d’attribut erronée dans votre shader (en gros ça fera comme si vous faisiez un cast GLSL : <em>Attrib = TypeDeAttrib(TypeDeLaFonction)</em> ).</p><p>Je vous conseille d’aller faire un petit tour sur la page de manuel de <em><a href=http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttrib.xml rel=noopener>glVertexAttrib*()</a></em>, vous risquez d’y trouver quelques informations complémentaires intéressantes ; cette fonction vous permet notamment de normaliser le vecteur que vous lui envoyez.</p><hr><a href=#les-tableaux-dattributs><h2 id=les-tableaux-dattributs><span class=hanchor arialabel=Anchor># </span>Les tableaux d’attributs</h2></a><p>Si vous connaissez les
<a href=http://www.siteduzero.com/tuto-3-18395-1-les-vertex-arrays.html rel=noopener>vertex arrays</a>, et que vous êtes un flemmard (quelqu’un de normal quoi), vous vous êtes probablement demandé : mais existe-t-il une alternative pour envoyer mes attributs de sommets par le biais de tableaux ? Eh bien la réponse est oui :)</p><p>Cette section est bien sûr facultative, elle ne vous aidera pas à mieux comprendre le fonctionnement des attributs de sommet, elle est plutôt réservée aux connaisseurs des vertex arrays.</p><a href=#activation-des-tableaux-dattributs><h2 id=activation-des-tableaux-dattributs><span class=hanchor arialabel=Anchor># </span>Activation des tableaux d’attributs</h2></a><p>À l’instar des vertex arrays simples, les tableaux d’attributs ont besoin d’une activation qui leur est propre. Chaque index d’attribut doit être activé indépendamment, car chaque index représente un type de données différent.</p><p>Que quoi ? Hein ??</p><p>Oui, chaque index d’attribut représente un type différent ; la différence qu’il y a entre l’index 0 et l’index 1 est la même qu’entre la position d’un sommet et sa normale : ce ne sont pas les mêmes données, elles sont identifiées différemment. Je vous conseille d’aller jeter un oeil à
<a href=http://www.siteduzero.com/tuto-3-18395-1-les-vertex-arrays.html#ss_part_1 rel=noopener>ma petite définition de ce qu’est un sommet</a>, dans mon tutoriel sur les vertex arrays.</p><p>Bien, revenons-en au sujet initial : l’activation. Étant donné que chaque type d’attribut est identifié différemment par OpenGL, il va falloir, comme pour chaque type de donnée d’un sommet, l’activer indépendamment des autres, et pour cela, il va nous falloir son <strong>index</strong>. Avec la fonction <em>glEnableClientState()</em>, c’était facile, il nous suffisait de lui donner une constante au nom trivial et facile à retenir, et hop, elle activait le type de vertex array demandé.</p><p>La fonction <em>glEnableVertexAttribArray()</em> quant à elle, demande l’index de l’attribut à activer.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glEnableVertexAttribArray(GLuint index);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>index</strong></em> : c’est l’index du type de l’attribut que l’on souhaite activer.</li></ul><p>Avec les shaders GLSL, l’index d’un attribut de sommet se récupère comme nous l’avons vu plus haut : avec la fonction <em>glGetAttribLocation()</em>. Après vous être muni de cet index, vous n’aurez qu’à le donner à <em>glEnableVertexAttribArray()</em> pour que nous puissions exploiter les attributs de sommet demandés :)</p><a href=#envoi-dun-tableau><h2 id=envoi-dun-tableau><span class=hanchor arialabel=Anchor># </span>Envoi d’un tableau</h2></a><p>Allez, je ne vais pas passer par 36 chemins ; ici je considère que vous maîtrisez un minimum le concept des vertex arrays, je ne m’étalerai donc pas sur les détails.</p><p>Afin de spécifier un tableau d’attributs, utilisez la fonction <em>glVertexAttribPointer()</em> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glVertexAttribPointer(GLuint index, int size, GLenum type, GLboolean norm, GLsizei stride, const void *data);
</span></span></code></pre></td></tr></table></div></div><ul><li><p><em><strong>size</strong></em>, <em><strong>type</strong></em>, <em><strong>stride</strong></em>, <em><strong>data</strong></em> : référez-vous à mon tutoriel sur les vertex arrays, ces paramètres ont la même incidence que ceux des autres fonctions <em>gl</em>Pointer()*.</p></li><li><p><em><strong>index</strong></em> : il s’agit d’indiquer ici le type de l’attribut, c’est-à-dire son index récupéré à l’aide de <em>glGetAttribLocation()</em>.</p></li><li><p><em><strong>norm</strong></em> : positionné à GL_TRUE, les vecteurs contenus dans votre tableau de données seront normalisés. Je vous conseille personnellement de laisser ce paramètre à 0 (ou GL_FALSE), ainsi OpenGL ne touchera pas à vos données.</p></li></ul><p>Comme vous le voyez, cette fonction demande à ce qu’on lui fournisse le type d’attribut que représentera le tableau qu’on lui envoie.</p><p>Comment ça se fait ? Pourquoi elle a besoin de savoir ça, alors qu’on a déjà donné l’index lorsqu’on a activé les tableaux ?</p><p>Car vous pouvez avoir activé plusieurs tableaux d’attributs à la fois (c’est possible sachez-le), il est donc important de spécifier explicitement quel est le type d’attribut que vous lui envoyez.</p><p>Le reste du fonctionnement est le même que pour les vertex arrays (les tabeaux d’attributs sont en fait des vertex arrays un peu différents sur certains points) : après avoir appelé cette fonction, le tableau sera envoyé à la carte graphique pour traitement lorsque vous appelerez une fonction de dessin comme <em>glDrawArrays()</em> ou <em>glDrawElements()</em>.</p><a href=#et-les-vbos-><h3 id=et-les-vbos-><span class=hanchor arialabel=Anchor># </span>Et les VBOs ?</h3></a><p>Ah ! J’allais les oublier ceux-là. Les tableaux t’attributs ayant un système de fonctionnement identique aux vertex arrays, vous pouvez également héberger vos tableaux dans un VBO, puis utiliser l’adresse 0 avec <em>glVertexAttribPointer()</em> pour spécifier l’emplacement de votre VBO actif, et utiliser les données directement à partir de la mémoire de la carte graphique.</p><p>« VBO » ? Avons-nous été présentés ?</p><p>Vous ne connaissez pas les VBOs ? Eh bien alors il est grand temps que vous fassiez leur connaissance ! Les VBOs sont un sujet assez vaste, c’est pourquoi je vous ai concocté
<a href=http://www.siteduzero.com/tuto-3-18397-1-les-vertex-buffer-objects.html rel=noopener>un petit tutoriel à leur sujet</a>. Pour faire court ; les VBOs sont une sorte d’amélioration du système des vertex arrays, ils servent à augmenter considérablement leur performance (pour peu qu’ils soient bien utilisés) ;)</p><a href=#désactivation-des-tableaux-dattributs><h2 id=désactivation-des-tableaux-dattributs><span class=hanchor arialabel=Anchor># </span>Désactivation des tableaux d’attributs</h2></a><p>Je vous l’avais dit que les tableaux d’attributs étaient des vertex arrays :p Un peu différents toutefois, la fonction pour désactiver les tableaux d’attributs est la suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void glDisableVertexAttribArray(GLuint index);
</span></span></code></pre></td></tr></table></div></div><ul><li><em><strong>index</strong></em> : encore une fois, il est nécessaire d’indiquer quel type d’attribut on souhaite désactiver.</li></ul><a href=#exemple-dutilisation><h2 id=exemple-dutilisation><span class=hanchor arialabel=Anchor># </span>Exemple d’utilisation</h2></a><p>Un petit exemple ne fera pas de mal je pense. Vous vous rappelez de l’exemple qui présentait une utilisation possible des attributs de sommet, en spécifiant les attributs un à un ? Je vous en propose ici l’adaptation qui utilise les tableaux d’attributs :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>attribute float numero_sommet;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* notre index d&#39;attribut */
</span></span><span class=line><span class=cl>int index;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* tableau des positions */
</span></span><span class=line><span class=cl>float pos[6] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    0.9, -0.9,
</span></span><span class=line><span class=cl>    -0.9, -0.9,
</span></span><span class=line><span class=cl>    0.0, 0.9
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>/* tableau t&#39;attributs */
</span></span><span class=line><span class=cl>float attribs[3] =
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    0.0, 1.0, 2.0
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on recupere l&#39;index de notre attribut de sommets */
</span></span><span class=line><span class=cl>index = glGetAttribLocation(program, &#34;numero_sommet&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on active les tableaux */
</span></span><span class=line><span class=cl>glEnableClientState(GL_VERTEX_ARRAY);
</span></span><span class=line><span class=cl>glEnableVertexAttribArray(index);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on specifie nos donnees */
</span></span><span class=line><span class=cl>glVertexPointer(2, GL_FLOAT, 0, pos);
</span></span><span class=line><span class=cl>glVertexAttribPointer(index, 1, GL_FLOAT, 0, 0, attribs);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(program);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* dessin */
</span></span><span class=line><span class=cl>glDrawArrays(GL_TRIANGLES, 0, 3);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>glUseProgram(0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* on desactive les tableaux */
</span></span><span class=line><span class=cl>glDisableVertexAttribArray(index);
</span></span><span class=line><span class=cl>glDisableClientState(GL_VERTEX_ARRAY);
</span></span></code></pre></td></tr></table></div></div><p>Ce chapitre touche à sa fin ; nous y avons vu deux méthodes pour transmettre des informations à nos shaders : l’une où l’on envoyait une “simple” variable, allant de l’entier à la matrice 4×4, et l’autre où l’on pouvait envoyer des données différentes à chacun de nos sommets.</p><a href=#téléchargement><h2 id=téléchargement><span class=hanchor arialabel=Anchor># </span>Téléchargement</h2></a><p>Comme promis, voici un programme exemple, afin que vous voyez comment on peut mélanger efficacement tout ce qu’on vient de voir.</p><p><a href=http://yno.goldzoneweb.info/sdz/ch5.zip rel=noopener>Télécharger l’exemple de code et le makefile Linux.</a></p><p><a href=http://yno.goldzoneweb.info/sdz/ch5-2.zip rel=noopener>Télécharger l’exemple utilisant les vertex arrays.</a></p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_780_069218cc8e24432ca.gif width=auto alt="Image utilisateur"></p><p><em>Screenshot de l’application exemple.</em></p><p>Comme d’habitude, l’exemple ne présente rien d’extraordinaire, toutefois ne vous inquiétez pas ; nous verrons dans la prochaine partie de ce tutoriel comment réaliser différents effets graphiques grâce aux shaders, afin d’embellir nos scènes 3D :)</p><p>Le tuto n’est pas fini, d’autres chapitres/parties sont en cours de rédaction ;)</p><hr><a href=#les-vecteurs><h2 id=les-vecteurs><span class=hanchor arialabel=Anchor># </span>Les vecteurs</h2></a><p>Cette annexe risque d’être votre plus grande alliée si vous voulez réellement comprendre le fonctionnement de la plupart des effets que nous étudierons dans la partie 3. Nous allons ici étudier ce qu’est un vecteur, ce qu’est la <strong>normalisation</strong> d’un vecteur, comment on fait le <strong>produit scalaire</strong> de deux vecteurs, comment on fait leur <strong>produit vectoriel</strong>, mais surtout, à quoi tout cela peut servir. Je me doute que vous avez probablement déjà appris ces concepts à l’école, mais vous a-t-on déjà donné une utilisation pratique de ces outils mathématiques forts pratiques que sont les vecteurs ? Non ? Et bien je vais vous en donner une :) Vous verrez, lorsqu’on a un objectif, l’apprentissage d’un concept est tout de suite plus simple.</p><a href=#les-vecteurs-notions-de-base><h2 id=les-vecteurs-notions-de-base><span class=hanchor arialabel=Anchor># </span>Les vecteurs, notions de base</h2></a><p>Il est avant-tout important de savoir additionner et soustraire deux vecteurs, ces opérations très simples sont la base des vecteurs mais on les utilise tout le temps, il est donc important de les maîtriser.</p><p>Attention préparez-vous, car ce chapitre va pleuvoir de schémas. Je me baserai sur une illustration 2D, mais les calculs que je ferai sont tout à fait appliquables en 3D, et heuresement, car c’est notre objectif.</p><a href=#un-vecteur-cest-quoi-><h2 id=un-vecteur-cest-quoi-><span class=hanchor arialabel=Anchor># </span>Un vecteur, c’est quoi ?</h2></a><p>Cette section est bien sûr réservée aux néophytes, si vous savez déjà ce qu’est un vecteur, passez tout de suite au gros titre suivant.</p><p>Vous pouvez comparer un vecteur avec une <strong>direction</strong>. Un vecteur marche aussi bien en 1D, qu’en 2D et qu’en 3D, les principes sont les mêmes.</p><p>Oui mais un vecteur, ça ressemble à quoi ?</p><p>Je vous propose de voir mon premier schéma, qui illustre un plan 2D et un vecteur dessiné dans ce plan :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_f0a8f712d45045f19.gif width=auto alt="Image utilisateur"></p><p>Cette barre rouge au milieu est un vecteur, comme vous le voyez, elle représente une direction. Ce vecteur v s’écrit comme ceci :</p><p>v(1; 1)</p><p>Le premier chiffre représente la composante x, et le second la composante y. Pour les vecteurs 3D, il y a une 3eme composate : la composante z. Ici notre vecteur peut être transformé en vecteur 3D, il aura donc une composante z nulle :</p><p>v(1; 1; 0)</p><p>Puisqu’un vecteur représente une direction, on part du principe qu’un vecteur commence toujours au point (0; 0).</p><a href=#laddition-de-vecteurs><h2 id=laddition-de-vecteurs><span class=hanchor arialabel=Anchor># </span>L’addition de vecteurs</h2></a><p>L’addition de vecteurs sert à obtenir une coordonnée finale dans l’espace résultante de plusieurs vecteurs. Comme l’illustre le schéma ci-dessous, mes deux vecteurs additionnés donnent naissance à un 3eme point qui est le résultat de l’addition des vecteurs a et b :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_45f0e10445954e96a.gif width=auto alt="Image utilisateur"></p><p>Vous pouvez toujours additionner un vecteur à un autre, et ainsi vous ballader librement dans l’espace, c’est un peu le principe qui est utilisé pour les <strong>caméras</strong> dans les jeux vidéos : la position de la caméra est représentée par un vecteur auquel on en additionne d’autres afin de <strong>déplacer</strong> la caméra.</p><p>Pour additionner deux vecteurs mathématiquement, on procède à l’addition de chaque composante du vecteur a par la même composante chez le vecteur b :</p><p>a(1; 0) + b(0; 1) = v(1; 1)</p><p>Soit :</p><p>v.x = a.x + b.x v.y = a.y + b.y</p><p>Essayons d’additionner plusieurs vecteurs entres eux. Nous allons additionner 3 vecteurs : a, b et c. Voici ces trois vecteurs :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_e41b112201d04ecca.gif width=auto alt="Image utilisateur"></p><p>Euh, comment on additionne tout ça ?</p><p>Je vais vous représenter tout ces vecteurs autrement. On peut schématiser l’addition comme ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_185e9da2b6054550b.gif width=auto alt="Image utilisateur"></p><p>Ici, le vecteur résultant, v, se calcule ainsi :</p><p>v.x = a.x + b.x + c.x v.y = a.y + b.y + c.y</p><p>Ce qui donne :</p><p>v.x = -2 + 2 + 1 v.y = 1 + 2 + -2</p><p>Nous obtenons donc le vecteur v(1; 1).</p><p>Notez que l’ordre d’addition n’a pas d’importance : 2+1 = 1+2 Voyez ci-dessous l’illustration d’un autre ordre d’addition : on retombe exactement au même endroit qu’avant (1; 1) :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_710_fcbe277decaf4a0e9.gif width=auto alt="Image utilisateur"></p><a href=#laddition-de-vecteurs-pour-trouver-une-moyenne><h3 id=laddition-de-vecteurs-pour-trouver-une-moyenne><span class=hanchor arialabel=Anchor># </span>L’addition de vecteurs pour trouver une moyenne</h3></a><p>L’addition de vecteurs peut également servir à trouver un vecteur moyen entre plusieurs vecteurs, en fait c’est ce que nous avons fait jusqu’à maintenant, mais à présent si nous considérons la position résultante de l’addition de plusieurs vecteurs comme une <strong>direction</strong> et non une position, nous obtenons en fait la direction moyenne de tous les vecteurs additionnés.</p><p>Reprenons notre premier schéma sur l’addition des vecteurs :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_45f0e10445954e96a.gif width=auto alt="Image utilisateur"></p><p>Nous voyons ici que le vecteur résultant est positionné exactement entre a et b. Il est souvent utile de connaître une moyenne entre plusieurs directions, à présent vous savez comment faire, il suffit d’additionner toutes ces directions entres elles.</p><a href=#la-soustraction-de-vecteurs><h2 id=la-soustraction-de-vecteurs><span class=hanchor arialabel=Anchor># </span>La soustraction de vecteurs</h2></a><p>La soustraction de vecteurs est utilisée pour connaître le vecteur qui va d’un point à un autre. Supposez que vous ayez les coordonnées dans l’espace de deux objets A et B, et que vous vouliez connaître le vecteur qui va de A vers B, ou de B vers A, il va vous falloir utiliser la soustraction de vecteurs.</p><p>Ca me servira à quoi de connaître le vecteur qui va de A vers B ?</p><p>Imaginez par exemple que vous vouliez programmer une animation fluide qui déplace l’objet A vers l’objet B, il vous faudra connaître la direction dans laquelle déplacer A, la soustraction de vecteurs est inévitable.</p><p>Voici un schéma de base pour illustrer ce que nous recherchons :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_9b1d25760d014eaf8.gif width=auto alt="Image utilisateur"></p><p>Nous allons calculer le vecteur v en soustrayant A à B. Cela fonctionne exactement de la même façon que l’addition, rien de plus simple :</p><p>v.x = B.x - A.x v.y = B.y - A.y</p><p>Ce qui revient à effectuer le calcul suivant :</p><p>v.x = -2 - 3 v.y = 1 - 2</p><p>Nous obtenons le vecteur v(-5; -1). Si nous le traçons dans le plan, nous obtenons… ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_9ab2680615e34561b.gif width=auto alt="Image utilisateur"></p><p>Héé, c’est pas du tout ça !</p><p>Mais si, il suffit de placer l’origine du vecteur sur le point A et nous obtenons ce que nous cherchions.</p><hr><a href=#longueur-et-normalisation><h2 id=longueur-et-normalisation><span class=hanchor arialabel=Anchor># </span>Longueur et normalisation</h2></a><a href=#une-question-de-longueur><h2 id=une-question-de-longueur><span class=hanchor arialabel=Anchor># </span>Une question de longueur</h2></a><p>Avant de voir ce qu’est la <strong>normalisation</strong> d’un vecteur, il nous faut d’abord voir ce qu’est sa <strong>longueur</strong> et ce qu’elle représente.</p><a href=#la-longueur-dun-vecteur-cest-quoi-><h3 id=la-longueur-dun-vecteur-cest-quoi-><span class=hanchor arialabel=Anchor># </span>La longueur d’un vecteur, c’est quoi ?</h3></a><p>La longueur d’un vecteur, c’est la distance qui sépare le point (0; 0) du point pointé par le vecteur dont on veut connaître la longueur. Lorsque nous dessinons ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_7db73c6554c54e6cb.gif width=auto alt="Image utilisateur"></p><p>Il est aisé de s’appercevoir que la longueur du vecteur v est de <strong>1</strong>. En revanche, la longueur d’un vecteur comme nous en avons vu tout à l’heure :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_f0a8f712d45045f19.gif width=auto alt="Image utilisateur"></p><p>est moins évidente, il nous faut la calculer.</p><a href=#calculer-la-longueur-dun-vecteur><h3 id=calculer-la-longueur-dun-vecteur><span class=hanchor arialabel=Anchor># </span>Calculer la longueur d’un vecteur</h3></a><p>Vous connaîssez probablement Pythagore, ce Grec philosophe et mathématicien de l’antiquité ? Non ? Mais alors connaîssez-vous seulement son théorème ? Si vous ne le connaîssez pas, vous risquez d’avoir quelques difficultés à comprendre cette partie du chapitre.</p><p>La longueur d’un vecteur se calcule ainsi :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_f93afa7099b0476b9.gif width=auto alt="Image utilisateur"></p><p>Dans le cas d’un vecteur à 3 dimensions, le calcul est le même, il suffit de rajouter la composante z comme ceci :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_8eeb270d72b849799.gif width=auto alt="Image utilisateur"></p><p>longueur est égal à la longueur du vecteur v. Il est possible d’illustrer le calcul de la longueur de notre vecteur à deux dimensions v :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_d29e16361dd54ffbb.gif width=auto alt="Image utilisateur"></p><p>Nous remarquons ici la présence d’un triangle rectangle, sur lequel on a en fait tout simplement appliqué le théorème de Pythagore ;)</p><a href=#la-normalisation><h2 id=la-normalisation><span class=hanchor arialabel=Anchor># </span>La normalisation</h2></a><p>La normalisation d’un vecteur revient à donner une <strong>norme</strong> de <strong>1</strong> à sa longueur. Ce qui veut dire que la longueur d’un vecteur normalisé est toujours de <strong>1</strong>.</p><a href=#représentation-de-la-normalisation><h3 id=représentation-de-la-normalisation><span class=hanchor arialabel=Anchor># </span>Représentation de la normalisation</h3></a><p>Il est possible d’illustrer la normalisation d’un vecteur par un simple schéma :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_b20a32530e914fe7a.gif width=auto alt="Image utilisateur"></p><p>Soit 1 le rayon de ce cercle, tout vecteur partant du point (0; 0) et ayant une longueur de 1 touchera pile poil un endroit de la courbe de ce cercle.</p><p>Quel est l’utilité de la normalisation ?</p><p>L’utilité est difficile à démontrer pour l’instant, nous verrons cela plus bas lorsque nous parlerons du produit scalaire.</p><a href=#calcul-de-la-normalisation><h3 id=calcul-de-la-normalisation><span class=hanchor arialabel=Anchor># </span>Calcul de la normalisation</h3></a><p>Effectuer une normalisation est très simple, surtout si l’on sait calculer la longueur d’un vecteur et qu’on a bien compris le principe de la normalisation.</p><p>Il suffit en fait de diviser chaque composante du vecteur (x, y, z (si 3D)) par la longueur du vecteur, et nous obtenons un vecteur normalisé. Rappelez-vous du calcul de la longueur d’un vecteur, vu plus haut. Nous avons donc une valeur appelée longueur qui est la longueur de notre vecteur v. Puisque la normalisation d’un vecteur signifie qu’il faut diviser chaque composante du vecteur par la longueur du vecteur, le calcul s’effectue ainsi :</p><p>v.x = v.x / longueur; v.y = v.y / longueur;</p><p>Il faut bien sûr rajouter ce calcul :</p><p>v.z = v.z / longueur;</p><p>si le vecteur est en 3D.</p><p>Notez que pour un vecteur 4D (c’est-à-dire avec une composante w), la normalisation de ce dernier revient à diviser chacune de ses trois premières composantes par w au lieu de longueur.</p><p>Si vous recalculez la longueur d’un vecteur normalisé, vous verrez que le résultat sera 1.</p><a href=#une-application-pratique><h3 id=une-application-pratique><span class=hanchor arialabel=Anchor># </span>Une application pratique</h3></a><p>Je vous propose de voir une première utilisation pratique des vecteurs normalisés, car je suis sûr que vous vous demandez à quoi la normalisation peut servir.</p><p>Souvenez-vous de notre schéma avec nos objets A et B, nous avions réussi à créer un vecteur qui allait de A vers B :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_9b1d25760d014eaf8.gif width=auto alt="Image utilisateur"></p><p><em>(notez qu’ici je n’ai pas dessiné le vecteur normalisé)</em></p><p>Supposons que nous normalisons ce vecteur et que nous l’appelons v.</p><p>Avec la normalisation, on sait de combien on se déplace : on se déplace toujours de <strong>1</strong>. Supposons que vous ayez considéré en OpenGL que 1 = 1 mètre, alors vous êtes sûrs qu’en additionnant un vecteur normalisé à un point celui-ci se déplacera d’un mètre dans la direction indiquée par le vecteur.</p><p>Ainsi, en additionnant v à A, nous sommes sûrs et certains que A se déplacera d’un mètre dans la direction de B. Et si nous voulons qu’il se déplace d’un centimètre, comme nous avons un vecteur normalisé, nous n’aurons qu’à diviser celui-ci par 100 avant de l’additionner à A pour qu’il se déplace d’un centimètre.</p><p>Diviser un vecteur par un réel quelconque revient à diviser chaque composante du vecteur par le réel en question, comme pour la normalisation, mais en remplaçant longueur par ce réel. Il en va de même pour la multiplication d’un vecteur par un réel, sauf que cette fois au lieu de diviser on multiplie.</p><p>Et voilà, vous savez maintenant normaliser un vecteur et vous en servir pour une utilisation basique. Nous allons voir maintenant une technique de calcul qui nécessite obligatoirement des vecteurs normalisés : le produit scalaire.</p><hr><a href=#le-produit-scalaire-dot-product><h2 id=le-produit-scalaire-dot-product><span class=hanchor arialabel=Anchor># </span>Le produit scalaire (dot product)</h2></a><p>Le produit scalaire se dit <em>dot product</em> en anglais. Vous avez peut-être déjà entendu parler du produit scalaire, mais savez-vous comment le calculer et surtout, à quoi il peut servir ? Non ? Et bien nous allons voir ça :)</p><a href=#le-produit-scalaire-comme-calculateur-dangles><h2 id=le-produit-scalaire-comme-calculateur-dangles><span class=hanchor arialabel=Anchor># </span>Le produit scalaire comme calculateur d’angles</h2></a><p>Effectuer le produit scalaire de deux vecteurs, c’est connaître l’angle qu’il y a entre deux vecteurs. Voici un schéma qui illustre assez bien ce que nous voulons calculer :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_b7277dcdb3224bc19.gif width=auto alt="Image utilisateur"></p><p>Bon, là je vous l’accorde, l’angle se devine facilement. Mais il se devine seulement, car en programmation 3D il ne s’agit pas de deviner, il s’agit de calculer.</p><p>Si nous prenons deux vecteurs, (3; 2; 5) et (0; 2; 1) par exemple, comment, à partir de ces données, pourriez-vous calculer l’angle qui sépare ces deux vecteurs ? Le produit scalaire sert à calculer cela.</p><p>Ça marche aussi en 3D ?</p><p>Bien sûr ! sinon cela n’aurait aucun intérêt.</p><p>Nous supposerons par la suite que tous nos vecteurs sont normalisés.</p><a href=#le-calcul-du-produit-scalaire><h2 id=le-calcul-du-produit-scalaire><span class=hanchor arialabel=Anchor># </span>Le calcul du produit scalaire</h2></a><p>En supposant que vous ayez deux vecteurs, a et b, et que vous souhaitez connaître leur produit scalaire, le calcul est, pour des vecteurs 2D :</p><p>dot = (a.x * b.x) + (a.y * b.y)</p><p>Et en 3D, on rajoute la composante Z, aussi simplement que cela :</p><p>dot = (a.x * b.x) + (a.y * b.y) + (a.z * b.z)</p><p>Euh, c’est bien joli ce dot, mais c’est quoi ? C’est la valeur de l’angle ?</p><p>Non, mais c’est le cosinus de l’angle.</p><p>Si dot vaut <strong>1</strong>, les deux vecteurs pointent dans la même direction (0°). Si dot vaut <strong>0</strong>, alors les deux vecteurs pointent dans deux directions qui sont à angle droit (90°).</p><p>Et donc logiquement, quand dot est entre 0 et 1, l’angle est compris entre 90° et 0°.</p><p>Mais moi je veux un angle en degrès précis, ça va me servir à quoi sinon ? Et que vaut dot quand les vecteurs sont séparés par plus de 90° ? Et puis à quoi ça sert de calculer le produit scalaire ?</p><p>Tout d’abord, pour obtenir l’angle, il suffit d’utiliser la simple fonction mathématique arc cosinus (cos-1() sur les calculatrices) sur notre valeur dot. Mais attention, arc cosinus ne fonctionne pas sur des nombres négatifs, et lorsque l’angle qui sépare deux vecteurs est supérieur à 90°, dot prend alors une valeur négative, et on ne peut alors plus calculer l’angle qui sépare nos vecteurs.</p><p>Mais rassurez-vous, en 3D cela sera inutile, nous nous contenterons de vérifier si dot se situe entre 0 et 1, sinon on considèrera sa valeur comme étant de 0.</p><p>Ah ouais, mais alors il sert à quoi ce produit scalaire ?</p><p>Pour vous répondre en quelques mots : à calculer le taux de reception de lumière d’un plan. Nous étudierons cela plus en détail lorsque nous apprendrons à gérer la lumière dans la 3eme partie du tutoriel.</p><p>Pour clore, retenez que :</p><ul><li><p>Le produit scalaire sert à calculer l’angle entre deux vecteurs.</p></li><li><p>Le produit scalaire ne fonctionne <strong>que</strong> sur des vecteurs normalisés !</p></li></ul><hr><a href=#le-produit-vectoriel-cross-product><h2 id=le-produit-vectoriel-cross-product><span class=hanchor arialabel=Anchor># </span>Le produit vectoriel (cross product)</h2></a><p>Le produit vectoriel sert à calculer le vecteur perpendiculaire à deux autres vecteurs. Le produit vectoriel se dit <em>cross product</em> (produit croisé) en anglais, mais vous voudriez peut-être savoir à quoi cela sert avant d’apprendre à le calculer ? Pas de problème.</p><a href=#notion-de-normale-dune-face><h2 id=notion-de-normale-dune-face><span class=hanchor arialabel=Anchor># </span>Notion de “normale” d’une face</h2></a><p>Nous allons commencer simplement.</p><p>Toute face (surface plane) possède une <strong>normale</strong>. Prenons par exemple votre table de bureau, c’est une surface plane. Sa normale pointe pile poil vers le plafond (vers le haut).</p><p>Voici comment schématiser la normale d’une face :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_ae9852d9b75e4915a.png width=auto alt="Image utilisateur"></p><p>Voici un cube. J’ai dessiné (à l’aide de Blender) pour chaque face du cube, sa normale. Comme vous pouvez le voir, la normale d’une face plane est un vecteur qui est perpendiculaire à la face.</p><p>Quel est le rapport avec le produit vectoriel ?</p><p>Et bien le produit vectoriel permet de calculer cette normale, uniquement grâce aux positions des sommets qui la composent :)</p><a href=#calcul-du-produit-vectoriel><h2 id=calcul-du-produit-vectoriel><span class=hanchor arialabel=Anchor># </span>Calcul du produit vectoriel</h2></a><p>Il est temps maintenant de représenter le produit vectoriel, ainsi que de montrer le calcul qu’il faut faire pour le trouver.</p><p>Le calcul du produit vectoriel se fait à partir de deux vecteurs et permet d’obtenir un autre vecteur. Ce vecteur obtenu est perpendiculaire aux deux autres vecteurs… tout comme la normale d’une face est perpendiculaire à la face elle même.</p><p>Nous pouvons faire l’analogie avec le produit vectoriel et la normale d’une face. En effet, voyez plutôt ce schéma :</p><p><img src=https://deuxfois.github.io/quartz//../../../_resources/uploads.siteduzero.com_files_690_c89a026e6f5b43558.gif width=auto alt="Image utilisateur"></p><p>Cette illustration résume assez bien tout ce que nous venons de voir :) Nous pouvons voir d’une part les vecteurs a et b, d’autre part le vecteur n, qui n’est autre que le résultat du produit vectoriel de a et b, en effet, n est perpendiculaire à a et b. Mais il est aussi perpendiculaire à la face, il représente donc sa normale.</p><p>Nous venons de voir qu’avec deux vecteurs qui longent les bords d’une face, nous pouvons obtenir la normale de cette face</p><p>Et comment on les trouve ces vecteurs qui longent les bords de notre face ? (a et b)</p><p>Revoyez la première partie de ce chapitre, et plus précisément l’endroit qui parle de la soustraction de vecteurs… vous devriez trouver assez aisément ;) Rappelez-vous que nous connaissons les positions des sommets qui constituent notre face.</p><p>Mais ça ne nous dit pas le plus important : comment on calcule ça ?</p><p>Oh ça, c’est le moins important, il s’agit d’une grosse formule barbare, l’important c’est de bien savoir ce que permet de faire le produit vectoriel.</p><p>Voici le calcul du produit vectoriel :</p><p>n.x = (a.y * b.z) - (a.z * b.y) n.y = (a.z * b.x) - (a.x * b.z) n.z = (a.x * b.y) - (a.y * b.x)</p><p>Notez que si vous échangez les vecteurs a et b dans les calculs, le vecteur obtenu sera exactement le vecteur opposé à celui que vous auriez obtenu sans échanger a et b.</p><p>Mais alors comment connaître le bon ordre de calcul pour obtenir la bonne normale de notre face ?</p><p>Il n’existe pas de méthode magique pour cela… Comment savoir quelle doit être la normale de votre face ? Il n’y a pas de “haut” en 3D, ni nulle part d’ailleurs, tout est relatif. Les sommets des triangles dans les maillages sont généralement donné dans un ordre conventionnel, ce qui permet de détermnier l’orientation de la face.</p><p>Les vecteurs ne sont pas une notion simple à aborder, il est possible qu’il vous fasse du temps avant de vous y faire. Prenez le temps de relire tranquillement chaque passage de ce chapitre afin de vous familiariser avec les vecteurs, c’est essentiel croyez-moi, car nous les utiliserons en permanence par la suite. Il est donc important que vous vous sentiez à l’aise avec ceux-ci.</p><p>Pour finir, je vais vous renvoyer sur les articles de Wikipedia à propos de tout ce que nous avons appris, ça vaut toujours le coup d’oeil.</p><ul><li><p><a href=http://fr.wikipedia.org/wiki/Vecteur rel=noopener>Le vecteur.</a></p></li><li><p><a href=http://fr.wikipedia.org/wiki/Produit_scalaire rel=noopener>Le produit scalaire.</a></p></li><li><p><a href=http://fr.wikipedia.org/wiki/Produit_vectoriel rel=noopener>Le produit vectoriel.</a></p></li></ul><p>Et voilà, c’est la fin de cette annexe, n’hésitez pas à venir la consulter régulièrement si vous vous sentez bloqué par la suite.</p><p>Merci au site
<a href=http://www.developpez.com/ rel=noopener>www.developpez.com</a> et aux membres de sa section programmation 3D, grâce auxquels j’ai acquis la plupart des mes connaissances actuelles en terme de programmation 3D.</p><p>Les commentaires, critiques ou corrections sont les bienvenus. Si vous pensez avoir trouvé une incohérence ou si vous avez mal compris quelque chose, n’hésitez pas à m’en faire part, je serai heureux de pouvoir améliorer le tutoriel pour vous ;)</p><p>*
<a href=http://creativecommons.org/licenses/by-sa/2.0/fr/ rel=noopener><img src=https://deuxfois.github.io/quartz//../../../_resources/88x31_f68b4c5b8aa1497ab41e05225e616157.png width=auto alt="Image utilisateur"></a>Cette création est mise à disposition sous un
<a href=http://creativecommons.org/licenses/by-sa/2.0/fr/ rel=noopener>contrat Creative Commons</a>.*</p><hr></article><hr><div class=page-end><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://deuxfois.github.io/quartz/js/graph.941f1fb9796c621d529a1c4fa5144021.js></script></div></div></div></body></html>